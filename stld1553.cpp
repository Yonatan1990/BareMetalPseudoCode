// Description  : A source file that contains the implementation of stld1553 library's exported functions
// Version      : 1.0.0.0
// Author       : Sital Technology R&D
//
// Modification history:
//
// Modified on 13.11.14: sital_mRt_Set_Error() - returning 0 in case that no error requested instead of error code


//#include "stdafx.h"
#include <stdio.h>
#include <string.h>
#include "OperatingSystemDependencies.h"
#include "InterProcessSemaphore.h"
#include "stld1553.h"
#include "stld1553_returnCodes.h"
#include "stld1553_driverInterface.h"
#include "stld1553_memoryManager.h"
#include "stld1553_internal.h"



#ifdef _MANAGED
#pragma managed(push, off)
#endif



// Constants.
#ifndef stld1553Library_SINGLE_USER_EXISTS
#define GLOBAL_SEMAPHORE_NAME	"Global\\Stld1553.dll.Semaphore" // The name of the semaphore used by this library to synchronize relevant operations between its different user applications (currently a single semaphore is used for all initialized devices).
#endif // stld1553Library_SINGLE_USER_EXISTS



// static variables.
#ifndef stld1553Library_SINGLE_USER_EXISTS
static const InterProcessSemaphore* s_ipspSemaphore = ((InterProcessSemaphore*)NULL); // A pointer to the semaphore used by this library to synchronize relevant operations between its different user applications (currently a single semaphore is used for all initialized devices).
#endif // stld1553Library_SINGLE_USER_EXISTS
static DeviceStateStructure s_dssaDevices[sitalMaximum_DEVICES] = {}; // An array of device state information.
static BOOLEAN s_bIsDeviceStatesArrayInitialized = FALSE; // A flag that says whether the device states have already been initialized.
static U16BIT s_wDistortedHardwareOpcode = opcode_HARDWARE_BORDER; // An hardware opcode whose commands should be distorted from now on (sitalOpcode_*) according to the configured distortion manner (see s_wDistortionManner below), or opcode_HARDWARE_BORDER if no command distortion is required.
static U16BIT s_wDistortionManner = sitalOpcodeDistortion_None; // A requested manner of command distortion (sitalOpcodeDistortion_*).
static U16BIT s_wDistortionParameter = 0U; // An optionally required parameter as specified in the definition of the currently configured distortion manner.

static mRtDeviceStruct_Type mrtDeviceStructDB[sitalMaximum_DEVICES] = {}; // Creating a Database for MRT mode only devices 
static mRtBusListStruct_Type mrtBusListStructDB[MAX_BUSLISTS] = {}; // Creating a Database for MRT mode only - Buslists
static mRtElementsStruct_Type mrtElementsStructDB[MAX_ELEMENTS + 1] = {}; // Creating a Database for MRT mode only - Elements. Allocated MAX_ELEMENTS + 1 elements for the compress to support deletion from buslist
static mRtDataBlockStruct_Type mrtDataBlockStructDB[MAX_BLOCKSIZE] = {}; // Creating a Database for MRT mode only - DataBlocks

// ARINC429
static ArincDeviceStruct ArincDevices[sitalMaximum_CARDS_ARINC429][sitalMaximum_DEVICES_ARINC429] = {};//{{true, false, false}, {true, false, false}, {true, false, false}, {true, false, false}, {true, false, false}, {true, false, false}, {true, false, false}, {true, false, false},
																										//{false, false, false},{false, false, false},{false, false, false},{false, false, false}, {false, false, false},{false, false, false},{false, false, false},{false, false, false},
																										//{false, false, false},{false, false, false},{false, false, false},{false, false, false}, {false, false, false},{false, false, false},{false, false, false},{false, false, false}};	







// Internal functions.

/// <summary>
/// Initialize this library, load required helper libraries, and verify they are of a suitable version.
///
/// Note:
/// - This function must be called when this library is loaded (e.g., by function DllMain in case the operating system is WIN32).
///
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT initializeLibrary (void)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.

	/// If required initialization operations weren't made yet:
	///		Load required helper libraries.
	///		Initialize device states.
	///		Flag the accomplishment of library initialization.
	if (FALSE == s_bIsDeviceStatesArrayInitialized)
	{
		// Call the operating-system-specific version of the library loader function.
		S16BIT swResult; // Result of operation or function call.
		swResult = helperLibraries_Load ();
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}

		U16BIT wMajorVersionOfThisLibrary, wMinorVersionOfThisLibrary, wBuildNumberOfThisLibrary, wRevisionNumberOfThisLibrary; // Version numbers of this library.
		U16BIT wMajorVersionOfLoadedDriverInterfaceLibrary, wMinorVersionOfLoadedDriverInterfaceLibrary, wBuildNumberOfLoadedDriverInterfaceLibrary, wRevisionNumberOfLoadedDriverInterfaceLibrary; // Version numbers of the loaded driver-interface-library.
		swResult = sitalDriverInterfaceLibrary_GetVersion (&wMajorVersionOfLoadedDriverInterfaceLibrary, &wMinorVersionOfLoadedDriverInterfaceLibrary, &wBuildNumberOfLoadedDriverInterfaceLibrary, &wRevisionNumberOfLoadedDriverInterfaceLibrary);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
		swResult = sitalStld1553_GetLibraryVersion (&wMajorVersionOfThisLibrary, &wMinorVersionOfThisLibrary, &wBuildNumberOfThisLibrary, &wRevisionNumberOfThisLibrary);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
		if ((wMajorVersionOfLoadedDriverInterfaceLibrary != wMajorVersionOfThisLibrary) || 
			/*(wMinorVersionOfLoadedDriverInterfaceLibrary != wMinorVersionOfThisLibrary) ||*/ 
			(wBuildNumberOfLoadedDriverInterfaceLibrary != wBuildNumberOfThisLibrary))
		{
			return sitalReturnCode_VERSION_ERROR;
		}

		DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= s_dssaDevices;
		for (U16BIT ui=0x0000U; ui<sitalMaximum_DEVICES; ui++)
		{
			dsspDeviceState->bIsOpened = FALSE;
			dsspDeviceState->wCurrentState = sitalDeviceState_RESET;
			dsspDeviceState++;
		}
		for (U16BIT bl = 0 ; bl < MAX_BUSLISTS ; bl++)
		{
			mrtBusListStructDB[bl].Mode = UnInitialized;
			mrtBusListStructDB[bl].NumOfElements = 0;
		}
		for (U16BIT el = 0 ; el < MAX_ELEMENTS ; el++)
		{
			mrtElementsStructDB[el].Mode = UnInitialized;			
		}
		for (U16BIT db = 0 ; db < MAX_BLOCKSIZE ; db++)
		{
			mrtDataBlockStructDB[db].Mode = UnInitialized;			
		}

		s_bIsDeviceStatesArrayInitialized = TRUE;
	}

#ifndef stld1553Library_SINGLE_USER_EXISTS
	/// Create a semaphore for this library to synchronize relevant operations between its different user applications.
	if (((InterProcessSemaphore*)NULL) == s_ipspSemaphore)
	{
		s_ipspSemaphore = new InterProcessSemaphore (GLOBAL_SEMAPHORE_NAME, 1);
		if (((int)0U) != ((InterProcessSemaphore*)s_ipspSemaphore)->Create ())
		{
			return sitalReturnCode_SEMAPHORE_OPERATION_ERROR;
		}
	}
#endif // stld1553Library_SINGLE_USER_EXISTS

	return sitalReturnCode_SUCCESS;
}



/// <summary>
/// Uninitialize this library.
///
/// Note:
/// - This function must be called when this library is unloaded (e.g., by function DllMain in case the operating system is WIN32).
///
/// @return 0	Function successfully completed
/// @return negative integer	Error condition or function failed
/// </summary>
S16BIT uninitializeLibrary (void)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.

#ifdef CREATE_DRIVER_LOG
	/// Instruct the device driver interface library to close the log file.
	sitalProcess_Log_Stop (TRUE);
#endif /// CREATE_DRIVER_LOG

	return 0;
}


/// <summary>
/// Use the current image of the registers to actually update the registers of given device.
/// Make suitable adaptations according to the configuration of given device.
///
/// Note:
/// - This function assumes that given device ID is legal.
/// - This function assumes that given device has already been initialized.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT device_Register_UpdateDevice (S16BIT swDevice)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.

	/// Use the current image of the registers to actually adaptively update the registers of given device.
	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	U16BIT wRegisterValue; // The current value of a target register, or the value to set for a target register.
	S16BIT swResult; // Result of operation or function call.

	U32BIT dwRegisterOffset; // The address of a register in device memory.
	dwRegisterOffset = sitalRegisterAddress_CONFIGURATION_1;
	wRegisterValue = dsspDeviceState->hrsRegistersImage.waRegister[dwRegisterOffset];
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, dwRegisterOffset, sitalDeviceMemorySection_Registers, registerMask_ALL_BITS_ON, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	dwRegisterOffset = sitalRegisterAddress_ERRORINJ1;
	wRegisterValue = dsspDeviceState->hrsRegistersImage.waRegister[dwRegisterOffset];
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, dwRegisterOffset, sitalDeviceMemorySection_Registers, registerMask_ALL_BITS_ON, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	dwRegisterOffset = sitalRegisterAddress_ERRORINJ2;
	wRegisterValue = dsspDeviceState->hrsRegistersImage.waRegister[dwRegisterOffset];
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, dwRegisterOffset, sitalDeviceMemorySection_Registers, registerMask_ALL_BITS_ON, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	dwRegisterOffset = sitalRegisterAddress_CONFIGURATION_2;
	wRegisterValue = dsspDeviceState->hrsRegistersImage.waRegister[dwRegisterOffset];
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, dwRegisterOffset, sitalDeviceMemorySection_Registers, registerMask_ALL_BITS_ON, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	dwRegisterOffset = sitalRegisterAddress_CONFIGURATION_3;
	wRegisterValue = dsspDeviceState->hrsRegistersImage.waRegister[dwRegisterOffset];
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, dwRegisterOffset, sitalDeviceMemorySection_Registers, registerMask_ALL_BITS_ON, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	dwRegisterOffset = sitalRegisterAddress_CONFIGURATION_4;
	// With BCs enable expanded BC control word.
	U16BIT wBcControlWordMask;  // BC control word mask.
	wBcControlWordMask = ((U16BIT)( (sitalMode_BC == dsspDeviceState->wMode) ? sitalConfigurationRegister4_BC_ENHANCED_CONTROL_WORD : 0U ));
	wRegisterValue = ( dsspDeviceState->hrsRegistersImage.waRegister[dwRegisterOffset] | wBcControlWordMask );
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, dwRegisterOffset, sitalDeviceMemorySection_Registers, registerMask_ALL_BITS_ON, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	dwRegisterOffset = sitalRegisterAddress_CONFIGURATION_5;
	wRegisterValue = dsspDeviceState->hrsRegistersImage.waRegister[dwRegisterOffset];
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, dwRegisterOffset, sitalDeviceMemorySection_Registers, registerMask_ALL_BITS_ON, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	dwRegisterOffset = sitalRegisterAddress_CONFIGURATION_6;
	wRegisterValue = dsspDeviceState->hrsRegistersImage.waRegister[dwRegisterOffset];
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, dwRegisterOffset, sitalDeviceMemorySection_Registers, registerMask_ALL_BITS_ON, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	dwRegisterOffset = sitalRegisterAddress_CONFIGURATION_7;
	wRegisterValue = dsspDeviceState->hrsRegistersImage.waRegister[dwRegisterOffset];
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, dwRegisterOffset, sitalDeviceMemorySection_Registers, registerMask_ALL_BITS_ON, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	dwRegisterOffset = sitalRegisterAddress_INTERRUPT_MASK_1;
	// In case of a real device also use the current internal and external configuration of the IMR (low word).
	U16BIT wImrConfiguration; // The configuration of the IMR.
	wImrConfiguration = ((U16BIT)( (sitalAccess_CARD == dsspDeviceState->wAccess) ? (dsspDeviceState->dwInternalImr | dsspDeviceState->dwExternalImr) : 0U ));
	wRegisterValue = ( dsspDeviceState->hrsRegistersImage.waRegister[dwRegisterOffset] | wImrConfiguration );
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, dwRegisterOffset, sitalDeviceMemorySection_Registers, registerMask_ALL_BITS_ON, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	dwRegisterOffset = sitalRegisterAddress_INTERRUPT_MASK_2;
	// In case of a real device also use the current internal and external configuration of the IMR (high word).
	wImrConfiguration = ((U16BIT)( (sitalAccess_CARD == dsspDeviceState->wAccess) ? ((dsspDeviceState->dwInternalImr >> 16U) | (dsspDeviceState->dwExternalImr >> 16U)) : 0U ));
	wRegisterValue = (U16BIT)( dsspDeviceState->hrsRegistersImage.waRegister[dwRegisterOffset] | wImrConfiguration );
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, dwRegisterOffset, sitalDeviceMemorySection_Registers, registerMask_ALL_BITS_ON, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

#ifdef UPDATE_THE_BC_CONTROL_WORD_REGISTER_0x04
	// Register 0x04 is a read-only register.
	// The following code, which updates this register, appears in the library of DDC for unknown reason.
	dwRegisterOffset = sitalRegisterAddress_BC_CONTROL_WORD;
	wRegisterValue = dsspDeviceState->hrsRegistersImage.waRegister[dwRegisterOffset];
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, dwRegisterOffset, sitalDeviceMemorySection_Registers, registerMask_ALL_BITS_ON, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
#endif // UPDATE_THE_BC_CONTROL_WORD_REGISTER_0x04

	dwRegisterOffset = sitalRegisterAddress_BC_GENERAL_PURPOSE_FLAG;
	wRegisterValue = dsspDeviceState->hrsRegistersImage.waRegister[dwRegisterOffset];
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, dwRegisterOffset, sitalDeviceMemorySection_Registers, registerMask_ALL_BITS_ON, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	dwRegisterOffset = sitalRegisterAddress_BC_RT_MT_QUEUE_POINTER;
	wRegisterValue = dsspDeviceState->hrsRegistersImage.waRegister[dwRegisterOffset];
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, dwRegisterOffset, sitalDeviceMemorySection_Registers, registerMask_ALL_BITS_ON, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

#ifdef UPDATE_THE_REMAINING_FRAME_TIME_REGISTER_0x0B
	// Register 0x0B is a read-only register.
	// The following code, which updates this register, appears in the library of DDC for unknown reason.
	dwRegisterOffset = sitalRegisterAddress_BC_REMAINING_FRAME_TIME;
	wRegisterValue = dsspDeviceState->hrsRegistersImage.waRegister[dwRegisterOffset];
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, dwRegisterOffset, sitalDeviceMemorySection_Registers, registerMask_ALL_BITS_ON, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
#endif // UPDATE_THE_REMAINING_FRAME_TIME_REGISTER_0x0B

	dwRegisterOffset = sitalRegisterAddress_BC_INITIAL_INSTRUCTION_POINTER;
	wRegisterValue = dsspDeviceState->hrsRegistersImage.waRegister[dwRegisterOffset];
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, dwRegisterOffset, sitalDeviceMemorySection_Registers, registerMask_ALL_BITS_ON, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	if (sitalModeVariant_NO_TIME_TAG_RESET != (sitalModeVariant_NO_TIME_TAG_RESET & dsspDeviceState->wModeVariants))
	{
		dwRegisterOffset = sitalRegisterAddress_TIME_TAG;
		wRegisterValue = dsspDeviceState->hrsRegistersImage.waRegister[dwRegisterOffset];
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, dwRegisterOffset, sitalDeviceMemorySection_Registers, registerMask_ALL_BITS_ON, &wRegisterValue);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Update the value of the image of given register as follows:
/// - Clear all the bits that are turned on in the mask in the image of the target register.
/// - Write the relevant portion of given new value (that is, the bits of the value whose counterparts are set in the mask) to the image of the target register.
///
/// Note:
/// - This function assumes that given device ID is legal.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wRegisterAddress (in)	The address of the target register in the registers section of the device
/// @param wMask (in)	The mask to use with the value of the register
/// @param wValue (in)	The value to write into the register
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT device_Register_UpdateImage (	S16BIT swDevice,
										U16BIT wRegisterAddress,
										U16BIT wMask,
										U16BIT wValue)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (sitalRegisterAddress_BORDER <= wRegisterAddress)
	{
		return sitalReturnCode_INVALID_REGISTER_ADDRESS;
	}

	/// Point to the image of the target register.
	U16BIT* wpTargetRegister;	// Pointer to the image of the target register.
	wpTargetRegister = &(s_dssaDevices[swDevice].hrsRegistersImage.waRegister[wRegisterAddress]);

	/// Clear all the bits that are turned on in the mask in the image of the target register.
	*wpTargetRegister &= (~wMask);

	/// Write the relevant portion of given new value (that is, the bits of the value whose counterparts are set in the mask) to the image of the target register.
	*wpTargetRegister |= (wValue & wMask);

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Get the relevant portion of the value of the image of given register.
///
/// Note:
/// - This function assumes that given device ID is legal.
/// - This function assumes that given device has already been initialized.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wRegisterAddress (in)	The address of the target register in the registers section of the device
/// @param wMask (in)	The mask to use with the value of the register
/// @param wpValue (out)	A pointer to a variable in which the value of the image of the register is returned
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT device_Register_GetImage (	S16BIT swDevice,
									U16BIT wRegisterAddress,
									U16BIT wMask,
									U16BIT* wpValue)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (sitalRegisterAddress_BORDER <= wRegisterAddress)
	{
		return sitalReturnCode_INVALID_REGISTER_ADDRESS;
	}

	if (((U16BIT*)NULL) == wpValue)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Get the value of the image of the target register.
	(*wpValue) = s_dssaDevices[swDevice].hrsRegistersImage.waRegister[wRegisterAddress];

	/// Mask all irrelevant bits.
	(*wpValue) = ((*wpValue) & wMask);

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Reset given device.
///
/// Note:
/// - This library avoids using any dynamic memory allocations, and this function therefore has no memory allocations to release.
/// - Once this function successfully completes, given device is reset, and must be reinitialized before any further use.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT device_Reset (S16BIT swDevice)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if ((((S16BIT)0) > swDevice) || (((S16BIT)sitalMaximum_DEVICES) <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	/// If given device is already reset:
	///		Return.
	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalDeviceState_RESET == dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_SUCCESS;
	}

	/// Disable Interrupts with given device.
	U16BIT wRegisterValue; // The current value of a target register, or the value to set for a target register.
	wRegisterValue = 0U;
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_INTERRUPT_MASK_1, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	wRegisterValue = 0U;
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_INTERRUPT_MASK_2, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// If given device is currently running a frame:
	///		Stop given device from running.
	///		Sign it as ready.
	if (sitalDeviceState_RUN == dsspDeviceState->wCurrentState)
	{
		wRegisterValue = (sitalStartResetRegister_INTERRUPT_RESET | sitalStartResetRegister_TIME_TAG_RESET);
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_START_OR_RESET, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
		dsspDeviceState->wCurrentState = sitalDeviceState_READY;
		//S16BIT swResult; // Result of operation or function call.
		//swResult = sitalProcess_Log_PrintLine ("#StldDll.Device.State.Change: device - %i, old - %i, new - %i\n", swDevice, dsspDeviceState->wCurrentState, sitalDeviceState_READY);
	}

	/// If memory and register address space has been assigned AND resetting the time tag register is enabled:
	///		Reset given device.
	if	(
		((sitalAccess_CARD == dsspDeviceState->wAccess) || (sitalAccess_USER == dsspDeviceState->wAccess))
		&&
		(sitalModeVariant_NO_TIME_TAG_RESET != (sitalModeVariant_NO_TIME_TAG_RESET & dsspDeviceState->wModeVariants))
		)
	{
		wRegisterValue = sitalStartResetRegister_RESET;
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_START_OR_RESET, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
	}

	//S16BIT swResult; // Result of operation or function call.
	//swResult = sitalProcess_Log_PrintLine ("#StldDll.Device.State.Change: device - %i, old - %i, new - %i\n", swDevice, dsspDeviceState->wCurrentState, sitalDeviceState_RESET);
	dsspDeviceState->wCurrentState = sitalDeviceState_RESET;

	/// Inform the device driver about the up-to-date mode of given device.
	swResult = sitalDevice_SetMode (swDevice, 0);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Device ISR that simply records occurring interrupts and the informed IRQ masks.
/// Used in order to test device interrupts.
///
/// @param iisp (in)	A pointer to the structure in which the interrupt is described
/// @return FALSE	if no error encountered while handling the reported interrupt
/// @return TRUE	if there is an error condition
/// </summary>
S16BIT _DECL device_TestIsr (const InterruptInformationStructure* iisp)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return TRUE.

	S16BIT swResult; // Result of operation or function call.
	if (((InterruptInformationStructure*)NULL) == iisp)
	{
		swResult = sitalProcess_Log_PrintLine ("#StldDll.Rt.Isr.Error: null_info\n");
		return TRUE;
	}

	if (sizeof(InterruptInformationStructure) > iisp->dwStructureSize)
	{
		swResult = sitalProcess_Log_PrintLine ("#StldDll.Rt.Isr.Error: info_size - %i\n", iisp->dwStructureSize);
		return TRUE;
	}

	if (BRMC_INTERRUPT_FLAG_SEVERE_PROBLEM == (BRMC_INTERRUPT_FLAG_SEVERE_PROBLEM & iisp->wFlags))
	{
		swResult = sitalProcess_Log_PrintLine ("#StldDll.Rt.Isr.Error: unit - %i, flags - %04X\n", iisp->swDevice, iisp->wFlags);
		return TRUE;
	}

	/// Record the interrupt and the informed IRQ status.
	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[iisp->swDevice]);
	dsspDeviceState->dwInterruptCount++;
	dsspDeviceState->dwIrqStatus = iisp->dwIrqStatus;

	return FALSE;
}


/// <summary>
/// Handle a BC interrupt.
///
/// Note:
/// - This function assumes that given device ID is legal.
/// - This function assumes that given device has already been initialized as BC.
///
/// @param iisp (in)	A pointer to the structure in which the interrupt is described
/// @return FALSE	if no error encountered while handling the reported interrupt
/// @return TRUE	if there is an error condition
/// </summary>
S16BIT _DECL bc_HandleInterrupt (const InterruptInformationStructure* iisp)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return TRUE.
	S16BIT swResult; // Result of operation or function call.
	//swResult = sitalProcess_Log_PrintLine ("#StldDll.Bc.Isr.Trace: 1\n");

	if (((InterruptInformationStructure*)NULL) == iisp)
	{
		swResult = sitalProcess_Log_PrintLine ("#StldDll.Bc.Isr.Error: null_info\n");
		return TRUE;
	}

	if (sizeof(InterruptInformationStructure) > iisp->dwStructureSize)
	{
		swResult = sitalProcess_Log_PrintLine ("#StldDll.Bc.Isr.Error: info_size - %i\n", iisp->dwStructureSize);
		return TRUE;
	}

	if (BRMC_INTERRUPT_FLAG_SEVERE_PROBLEM == (BRMC_INTERRUPT_FLAG_SEVERE_PROBLEM & iisp->wFlags))
	{
		swResult = sitalProcess_Log_PrintLine ("#StldDll.Bc.Isr.Error: unit - %i, flags - %04X\n", iisp->swDevice, iisp->wFlags);
		return TRUE;
	}

	/// If any message transmission related interrupt occurred:
	///		If a host buffer has been assigned to given device:
	///			Update the contents of given device's host buffer.
	// Note:
	// - Message transmission related interrupts are interrupts that inform on either the end of the active part of a minor frame, the fact that a minor frame accomplished its frame time, or time tag rollover.
	// - When writing minor frames to device memory, this library inserts, among the others, the following commands:
	//   - A command to issue an interrupt (IRQ-3) at the end of the minor frame and its following low asynchronous messages (if any).
	//     (This interrupt is issued only if IRQ is enabled.)
	//   - A command to issue an interrupt (IRQ-2) at the end of the idle time artificially added at the end of the minor frame to accomplish the requested frame time.
	//swResult = sitalProcess_Log_PrintLine ("#StldDll.Bc.Isr.Trace: 2\n");
	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[iisp->swDevice]);
	if (0U != ((sitalInterruptRegister2_BC_IRQ2 | sitalInterruptRegister2_BC_IRQ3 | sitalInterruptRegister1_TIME_TAG_ROLLOVER) & iisp->dwIrqStatus))
	{
		if (0U != dsspDeviceState->bsBcState.hbsHostBuffer.dwHostBufferSize)
		{
			//swResult = sitalProcess_Log_PrintLine ("#StldDll.Bc.Isr.Trace: 3\n");
			swResult = sitalBc_Gpq_HandleNewEntries (iisp->swDevice);
		}
	}

	/// If the user set an ISR and any of the enabled interrupts really occurred:
	///		Call the user's ISR.
	//swResult = sitalProcess_Log_PrintLine ("#StldDll.Bc.Isr.Trace: 4, is_isr - %i, imr - %X, isr - %x, match - %i\n", (((USER_ISR_FUNCTION)NULL) != dsspDeviceState->funcpUserIsr), dsspDeviceState->dwExternalImr, iisp->dwIrqStatus, (0U != (dsspDeviceState->dwExternalImr & iisp->dwIrqStatus)));
	if ((((USER_ISR_FUNCTION)NULL) != dsspDeviceState->funcpUserIsr) && (0U != (dsspDeviceState->dwExternalImr & iisp->dwIrqStatus)))
	{
		dsspDeviceState->funcpUserIsr (iisp->swDevice, iisp->dwIrqStatus);
	}

	return FALSE;
}


/// <summary>
/// Handle a RT interrupt.
///
/// Note:
/// - This function assumes that given device ID is legal.
/// - This function assumes that given device has already been initialized as RT.
///
/// @param iisp (in)	A pointer to the structure in which the interrupt is described
/// @return FALSE	if no error encountered while handling the reported interrupt
/// @return TRUE	if there is an error condition
/// </summary>
S16BIT _DECL rt_HandleInterrupt (const InterruptInformationStructure* iisp)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return TRUE.

	S16BIT swResult; // Result of operation or function call.
	if (((InterruptInformationStructure*)NULL) == iisp)
	{
		swResult = sitalProcess_Log_PrintLine ("#StldDll.Rt.Isr.Error: null_info\n");
		return TRUE;
	}

	if (sizeof(InterruptInformationStructure) > iisp->dwStructureSize)
	{
		swResult = sitalProcess_Log_PrintLine ("#StldDll.Rt.Isr.Error: info_size - %i\n", iisp->dwStructureSize);
		return TRUE;
	}

	if (BRMC_INTERRUPT_FLAG_SEVERE_PROBLEM == (BRMC_INTERRUPT_FLAG_SEVERE_PROBLEM & iisp->wFlags))
	{
		swResult = sitalProcess_Log_PrintLine ("#StldDll.Rt.Isr.Error: unit - %i, flags - %04X\n", iisp->swDevice, iisp->wFlags);
		return TRUE;
	}

	/// If any relevant message reception related interrupt occurred:
	///		Update the host buffer assigned with given RT device.
	// Note:
	// - Message reception interrupts related interrupts are interrupts concerned with the filling state of the command stack or a common circular buffer.
	// - While a common circular buffer isn't set, interrupts concerned with the filling state of a common circular buffer aren't expected to occur at all.
	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[iisp->swDevice]);
	if (0U != ((sitalInterruptRegister2_RT_COMMAND_STACK_HALF_ROLLOVER | sitalInterruptRegister2_RT_CIRCULAR_BUFFER_HALF_ROLLOVER | sitalInterruptRegister1_BC_RT_COMMAND_STACK_ROLLOVER | sitalInterruptRegister1_RT_CIRCULAR_BUFFER_ROLLOVER | sitalInterruptRegister1_TIME_TAG_ROLLOVER) & iisp->dwIrqStatus))
	{
		swResult = sitalRt_HostBuffer_Message_Record (iisp->swDevice);
	}

	/// If the user set an ISR and any of the enabled interrupts really occurred:
	///		Call the user's ISR.
	if ((((USER_ISR_FUNCTION)NULL) != dsspDeviceState->funcpUserIsr) && (0U != (dsspDeviceState->dwExternalImr & iisp->dwIrqStatus)))
	{
		dsspDeviceState->funcpUserIsr (iisp->swDevice, iisp->dwIrqStatus);
	}

	return FALSE;
}


/// <summary>
/// Handle a MT interrupt.
///
/// Note:
/// - This function assumes that given device ID is legal.
/// - This function assumes that given device has already been initialized as MT.
///
/// @param iisp (in)	A pointer to the structure in which the interrupt is described
/// @return FALSE	if no error encountered while handling the reported interrupt
/// @return TRUE	if there is an error condition
/// </summary>
S16BIT _DECL mt_HandleInterrupt (const InterruptInformationStructure* iisp)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return TRUE.

	S16BIT swResult; // Result of operation or function call.
	if (((InterruptInformationStructure*)NULL) == iisp)
	{
		swResult = sitalProcess_Log_PrintLine ("#StldDll.Mt.Isr.Error: null_info\n");
		return TRUE;
	}

	if (sizeof(InterruptInformationStructure) > iisp->dwStructureSize)
	{
		swResult = sitalProcess_Log_PrintLine ("#StldDll.Mt.Isr.Error: info_size - %i\n", iisp->dwStructureSize);
		return TRUE;
	}

	if (BRMC_INTERRUPT_FLAG_SEVERE_PROBLEM == (BRMC_INTERRUPT_FLAG_SEVERE_PROBLEM & iisp->wFlags))
	{
		swResult = sitalProcess_Log_PrintLine ("#StldDll.Mt.Isr.Error: unit - %i, flags - %04X\n", iisp->swDevice, iisp->wFlags);
		return TRUE;
	}

	/// If any relevant message reception related interrupt occurred:
	///		Update the host buffer assigned with given MT device.
	// Note:
	// - Message reception interrupts related interrupts are interrupts concerned with the filling state of the command stack.
	//swResult = sitalProcess_Log_PrintLine ("#StldDll.Mt.Isr.Entered: unit - %i, irq_status - %08X\n", iisp->swDevice, iisp->dwIrqStatus);
	if (0U != ((sitalInterruptRegister2_MT_DATA_STACK_HALF_ROLLOVER | sitalInterruptRegister2_MT_COMMAND_STACK_HALF_ROLLOVER | sitalInterruptRegister1_MT_DATA_STACK_ROLLOVER | sitalInterruptRegister1_MT_COMMAND_STACK_ROLLOVER | sitalInterruptRegister1_TIME_TAG_ROLLOVER) & iisp->dwIrqStatus))
	{
		swResult = sitalMt_HostBuffer_Message_Record (iisp->swDevice);
	}

	/// If the user set an ISR and any of the enabled interrupts really occurred:
	///		Call the user's ISR.
	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[iisp->swDevice]);
	if ((((USER_ISR_FUNCTION)NULL) != dsspDeviceState->funcpUserIsr) && (0U != (dsspDeviceState->dwExternalImr & iisp->dwIrqStatus)))
	{
		dsspDeviceState->funcpUserIsr (iisp->swDevice, iisp->dwIrqStatus);
	}

	return FALSE;
}


/// <summary>
/// Handle a RTMT interrupt.
///
/// Note:
/// - This function assumes that given device ID is legal.
/// - This function assumes that given device has already been initialized as RTMT.
///
/// @param iisp (in)	A pointer to the structure in which the interrupt is described
/// @return FALSE	if no error encountered while handling the reported interrupt
/// @return TRUE	if there is an error condition
/// </summary>
S16BIT _DECL rtmt_HandleInterrupt (const InterruptInformationStructure* iisp)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return TRUE.

	S16BIT swResult; // Result of operation or function call.
	if (((InterruptInformationStructure*)NULL) == iisp)
	{
		swResult = sitalProcess_Log_PrintLine ("#StldDll.RtMt.Isr.Error: null_info\n");
		return TRUE;
	}

	if (sizeof(InterruptInformationStructure) > iisp->dwStructureSize)
	{
		swResult = sitalProcess_Log_PrintLine ("#StldDll.RtMt.Isr.Error: info_size - %i\n", iisp->dwStructureSize);
		return TRUE;
	}

	if (BRMC_INTERRUPT_FLAG_SEVERE_PROBLEM == (BRMC_INTERRUPT_FLAG_SEVERE_PROBLEM & iisp->wFlags))
	{
		swResult = sitalProcess_Log_PrintLine ("#StldDll.RtMt.Isr.Error: unit - %i, flags - %04X\n", iisp->swDevice, iisp->wFlags);
		return TRUE;
	}

//	printf("mess");
	/// If any relevant message reception related interrupt occurred:
	///		Update the host buffer assigned with given RT device.
	// Note:
	// - Message reception interrupts related interrupts are interrupts concerned with the filling state of the command stack or a common circular buffer.
	// - While a common circular buffer isn't set, interrupts concerned with the filling state of a common circular buffer aren't expected to occur at all.
	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[iisp->swDevice]);
	if (0U != ((sitalInterruptRegister2_RT_COMMAND_STACK_HALF_ROLLOVER | sitalInterruptRegister2_RT_CIRCULAR_BUFFER_HALF_ROLLOVER | sitalInterruptRegister1_BC_RT_COMMAND_STACK_ROLLOVER | sitalInterruptRegister1_RT_CIRCULAR_BUFFER_ROLLOVER | sitalInterruptRegister1_TIME_TAG_ROLLOVER) & iisp->dwIrqStatus))
	{
		swResult = sitalRt_HostBuffer_Message_Record (iisp->swDevice);
	}

	/// If any relevant message reception related interrupt occurred:
	///		Update the host buffer assigned with given MT device.
	// Note:
	// - Message reception interrupts related interrupts are interrupts concerned with the filling state of the command stack.
	if (0U != ((sitalInterruptRegister2_MT_DATA_STACK_HALF_ROLLOVER | sitalInterruptRegister2_MT_COMMAND_STACK_HALF_ROLLOVER | sitalInterruptRegister1_MT_DATA_STACK_ROLLOVER | sitalInterruptRegister1_MT_COMMAND_STACK_ROLLOVER | sitalInterruptRegister1_TIME_TAG_ROLLOVER) & iisp->dwIrqStatus))
	{
		swResult = sitalMt_HostBuffer_Message_Record (iisp->swDevice);
	}

	/// If the user set an ISR and any of the enabled interrupts really occurred:
	///		Call the user's ISR.
	if ((((USER_ISR_FUNCTION)NULL) != dsspDeviceState->funcpUserIsr) && (0U != (dsspDeviceState->dwExternalImr & iisp->dwIrqStatus)))
	{
		dsspDeviceState->funcpUserIsr (iisp->swDevice, iisp->dwIrqStatus);
	}

	return FALSE;
}


/// <summary>
/// Configure given BC device into default state.
///
/// Note:
/// - This function assumes that given device ID is legal.
/// - This function assumes that given device has already been initialized as BC.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT bc_ConfigureDefault (S16BIT swDevice)
{
	/// @pseudocode

	/// Get given device's card information, and find out what type of interrupt signal (i.e., level or pulse) should be used with it.
	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	sitalCardInformationStructure cisCardInformation;
	cisCardInformation.dwStructureSize = sizeof(sitalCardInformationStructure);
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalCard_GetInformation (dsspDeviceState->dcsDeviceCapabilities.swCard, &cisCardInformation);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	U16BIT wInterruptMode; // Proper configuration for type of interrupt signal (sitalIrqMode_*) in the light of the operating system and card type.
	wInterruptMode = (U16BIT)( (BRMC_CAP_IRQ_PULSE == (BRMC_CAP_IRQ_PULSE & cisCardInformation.wFlags)) ? sitalIrqMode_PULSE : sitalIrqMode_LEVEL );

	/// Configure given device with default setup.
	swResult = sitalDevice_Irq_Configure (swDevice, wInterruptMode, sitalIrqClear_NO_AUTO_CLEAR);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	swResult = sitalDevice_Clock_SetFrequency (swDevice, sitalClockSetup_16MHZ);
	if ((sitalReturnCode_SUCCESS != swResult) && (sitalReturnCode_NOT_SUPPORTED != swResult))
	{
		return swResult;
	}
	swResult = sitalDevice_ConfigureDecoder (swDevice, sitalInputDevice_DoubleEnded, sitalExpendedXing_Enable);
	if ((sitalReturnCode_SUCCESS != swResult) && (sitalReturnCode_NOT_SUPPORTED != swResult))
	{
		return swResult;
	}
	swResult = sitalDevice_SetResponseTimeout (swDevice, sitalResponseTimeout_18US);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	swResult = sitalDevice_TimeTag_SetResolution (swDevice, sitalTimeTagResolution_2US);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	swResult = sitalDevice_ConfigureRamParityCheck (swDevice, sitalRamParityCheck_DISABLE);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_1, (U16BIT)sitalConfigurationRegister1_FUNCTION_BC, (U16BIT)registerMask_ALL_BITS_ON);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_3, (U16BIT)sitalConfigurationRegister3_ENHANCED_MODE, (U16BIT)registerMask_ALL_BITS_ON);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_6, (U16BIT)(sitalConfigurationRegister6_ENHANCED_CPU_ACCESS | sitalConfigurationRegister6_BC_ENHANCED), (U16BIT)registerMask_ALL_BITS_ON);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	return sitalReturnCode_SUCCESS;
}

/// <summary>
/// Configure Multi RT device default state.
///
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return other sitalReturnCode_*	Function failed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT mrt_ConfigureDefault (S16BIT swDevice)
{
	
	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Configure given RT device into default state.
///
/// Note:
/// - This function assumes that given device ID is legal.
/// - This function assumes that given device has already been initialized as RT.
///
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return other sitalReturnCode_*	Function failed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT rt_ConfigureDefault (S16BIT swDevice)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.

	/// Get given device's card information, and find out what type of interrupt signal (i.e., level or pulse) should be used with it.
	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	sitalCardInformationStructure cisCardInformation;
	cisCardInformation.dwStructureSize = sizeof(sitalCardInformationStructure);
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalCard_GetInformation (dsspDeviceState->dcsDeviceCapabilities.swCard, &cisCardInformation);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	U16BIT wInterruptMode; // Proper configuration for type of interrupt signal (sitalIrqMode_*) in the light of the operating system and card type.
	wInterruptMode = (U16BIT)( (BRMC_CAP_IRQ_PULSE == (BRMC_CAP_IRQ_PULSE & cisCardInformation.wFlags)) ? sitalIrqMode_PULSE : sitalIrqMode_LEVEL );

	/// Configure given device with default setup.
	swResult = sitalDevice_Irq_Configure (swDevice, wInterruptMode, sitalIrqClear_NO_AUTO_CLEAR);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	swResult = sitalDevice_Clock_SetFrequency (swDevice, sitalClockSetup_16MHZ);
	if ((sitalReturnCode_SUCCESS != swResult) && (sitalReturnCode_NOT_SUPPORTED != swResult))
	{
		return swResult;
	}
	swResult = sitalDevice_ConfigureDecoder (swDevice, sitalInputDevice_DoubleEnded, sitalExpendedXing_Enable);
	if ((sitalReturnCode_SUCCESS != swResult) && (sitalReturnCode_NOT_SUPPORTED != swResult))
	{
		return swResult;
	}
	swResult = sitalDevice_SetResponseTimeout (swDevice, sitalResponseTimeout_18US);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	swResult = sitalDevice_TimeTag_SetResolution (swDevice, sitalTimeTagResolution_2US);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	swResult = sitalDevice_ConfigureRamParityCheck (swDevice, sitalRamParityCheck_DISABLE);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_1, (U16BIT)sitalConfigurationRegister1_FUNCTION_RT, (U16BIT)registerMask_ALL_BITS_ON);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_2, (U16BIT)(sitalConfigurationRegister2_RT_BUSY_LOOKUP_TABLE | sitalConfigurationRegister2_RT_SUBADDRESS_DOUBLE_BUFFER | sitalConfigurationRegister2_RT_ENHANCED_MEMORY_MANAGEMENT | sitalConfigurationRegister2_RT_SEPARATE_BROADCAST_DATA), (U16BIT)registerMask_ALL_BITS_ON);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_3, (U16BIT)(sitalConfigurationRegister3_ENHANCED_MODE | sitalConfigurationRegister3_RT_ENHANCED_MODE_CODE_HANDLING), (U16BIT)registerMask_ALL_BITS_ON);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_6, (U16BIT)(sitalConfigurationRegister6_ENHANCED_CPU_ACCESS | sitalConfigurationRegister6_RT_MT_END_OF_MESSAGE_COMMAND_INCREMENT), (U16BIT)registerMask_ALL_BITS_ON);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Set internal address source.
	swResult = sitalRt_AddressSource_Set (swDevice, (U16BIT)sitalRtAddressSource_INTERNAL);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Configure given MT device into default state.
///
/// Note:
/// - This function assumes that given device ID is legal.
/// - This function assumes that given device has already been initialized as MT.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT mt_ConfigureDefault (S16BIT swDevice)
{
	/// @pseudocode

	/// Get given device's card information, and find out what type of interrupt signal (i.e., level or pulse) should be used with it.
	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	sitalCardInformationStructure cisCardInformation;
	cisCardInformation.dwStructureSize = sizeof(sitalCardInformationStructure);
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalCard_GetInformation (dsspDeviceState->dcsDeviceCapabilities.swCard, &cisCardInformation);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	U16BIT wInterruptMode; // Proper configuration for type of interrupt signal (sitalIrqMode_*) in the light of the operating system and card type.
	wInterruptMode = (U16BIT)( (BRMC_CAP_IRQ_PULSE == (BRMC_CAP_IRQ_PULSE & cisCardInformation.wFlags)) ? sitalIrqMode_PULSE : sitalIrqMode_LEVEL );

	/// Configure given device with default setup.
	swResult = sitalDevice_Irq_Configure (swDevice, wInterruptMode, sitalIrqClear_NO_AUTO_CLEAR);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	swResult = sitalDevice_Clock_SetFrequency (swDevice, sitalClockSetup_16MHZ);
	if ((sitalReturnCode_SUCCESS != swResult) && (sitalReturnCode_NOT_SUPPORTED != swResult))
	{
		return swResult;
	}
	swResult = sitalDevice_ConfigureDecoder (swDevice, sitalInputDevice_DoubleEnded, sitalExpendedXing_Enable);
	if ((sitalReturnCode_SUCCESS != swResult) && (sitalReturnCode_NOT_SUPPORTED != swResult))
	{
		return swResult;
	}
	swResult = sitalDevice_SetResponseTimeout (swDevice, sitalResponseTimeout_18US);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	swResult = sitalDevice_TimeTag_SetResolution (swDevice, sitalTimeTagResolution_2US);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	swResult = sitalDevice_ConfigureRamParityCheck (swDevice, sitalRamParityCheck_DISABLE);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	swResult = sitalMt_MessageMonitoring_Enable (swDevice, sitalRtAddress_ALL, sitalMessageDirection_BOTH, sitalRtSubaddressMask_ALL);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_1, (U16BIT)(sitalConfigurationRegister1_FUNCTION_MT | sitalConfigurationRegister1_MT_MESSAGE_MONITOR_ENABLED), (U16BIT)registerMask_ALL_BITS_ON);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_3, (U16BIT)sitalConfigurationRegister3_ENHANCED_MODE, (U16BIT)registerMask_ALL_BITS_ON);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_6, (U16BIT)sitalConfigurationRegister6_RT_MT_INTERRUPT_STATUS_QUEUE, (U16BIT)registerMask_ALL_BITS_ON); // Note: Yet unsupported by the h/w.
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Configure given RT&MT device into default state.
///
/// Note:
/// - This function assumes that given device ID is legal.
/// - This function assumes that given device has already been initialized as RT&MT.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT rtmt_ConfigureDefault (S16BIT swDevice)
{
	/// @pseudocode

	/// Get given device's card information, and find out what type of interrupt signal (i.e., level or pulse) should be used with it.
	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	sitalCardInformationStructure cisCardInformation;
	cisCardInformation.dwStructureSize = sizeof(sitalCardInformationStructure);
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalCard_GetInformation (dsspDeviceState->dcsDeviceCapabilities.swCard, &cisCardInformation);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	U16BIT wInterruptMode; // Proper configuration for type of interrupt signal (sitalIrqMode_*) in the light of the operating system and card type.
	wInterruptMode = (U16BIT)( (BRMC_CAP_IRQ_PULSE == (BRMC_CAP_IRQ_PULSE & cisCardInformation.wFlags)) ? sitalIrqMode_PULSE : sitalIrqMode_LEVEL );

	/// Configure given device with default setup.
	swResult = sitalDevice_Irq_Configure (swDevice, wInterruptMode, sitalIrqClear_NO_AUTO_CLEAR);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	swResult = sitalDevice_Clock_SetFrequency (swDevice, sitalClockSetup_16MHZ);
	if ((sitalReturnCode_SUCCESS != swResult) && (sitalReturnCode_NOT_SUPPORTED != swResult))
	{
		return swResult;
	}
	swResult = sitalDevice_ConfigureDecoder (swDevice, sitalInputDevice_DoubleEnded, sitalExpendedXing_Enable);
	if ((sitalReturnCode_SUCCESS != swResult) && (sitalReturnCode_NOT_SUPPORTED != swResult))
	{
		return swResult;
	}
	swResult = sitalDevice_SetResponseTimeout (swDevice, sitalResponseTimeout_18US);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	swResult = sitalDevice_TimeTag_SetResolution (swDevice, sitalTimeTagResolution_2US);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	swResult = sitalDevice_ConfigureRamParityCheck (swDevice, sitalRamParityCheck_DISABLE);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	swResult = sitalMt_MessageMonitoring_Enable (swDevice, sitalRtAddress_ALL, sitalMessageDirection_BOTH, sitalRtSubaddressMask_ALL);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_1, (U16BIT)(sitalConfigurationRegister1_FUNCTION_RT | sitalConfigurationRegister1_MT_MESSAGE_MONITOR_ENABLED), (U16BIT)registerMask_ALL_BITS_ON);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_2, (U16BIT)(sitalConfigurationRegister2_RT_BUSY_LOOKUP_TABLE | sitalConfigurationRegister2_RT_SUBADDRESS_DOUBLE_BUFFER | sitalConfigurationRegister2_RT_ENHANCED_MEMORY_MANAGEMENT | sitalConfigurationRegister2_RT_SEPARATE_BROADCAST_DATA), (U16BIT)registerMask_ALL_BITS_ON);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_3, (U16BIT)(sitalConfigurationRegister3_ENHANCED_MODE | sitalConfigurationRegister3_RT_ENHANCED_MODE_CODE_HANDLING), (U16BIT)registerMask_ALL_BITS_ON);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_6, (U16BIT)(sitalConfigurationRegister6_ENHANCED_CPU_ACCESS | sitalConfigurationRegister6_RT_MT_END_OF_MESSAGE_COMMAND_INCREMENT /*| sitalConfigurationRegister6_RT_MT_INTERRUPT_STATUS_QUEUE */), (U16BIT)registerMask_ALL_BITS_ON);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Set internal address source.
	swResult = sitalRt_AddressSource_Set (swDevice, sitalRtAddressSource_INTERNAL);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Read all yet unread GPQ entries from given BC device into the user's or library's host GPQs as appropriate according their header values (see the relevant notes below).
/// Then copy into given GPQ entry the next unread entry from the desired host GPQ according to given request initiator.
/// In case it is the user application who initiated this GPQ reading request, the returned GPQ entry is removed from its host GPQ.
///
/// Note:
/// - This function assumes that given device ID is legal.
/// - This function assumes that given device has already been initialized as BC.
/// - This function assumes that given device is currently at state of either ready or run.
/// - This function assumes that parameter gespGpqEntry isn't NULL.
/// - This function returns both GPQ entries that:
///   - Were filled by BC commands that have been explicitly inserted to the running frame by the user.
///     Important: Such commands should use GPQ headers other than those used by the library (sitalGeneralPurposeQueueFlag_*)!
///   - Are regularly filled by BC commands that have been inserted to the running frame by this library (i.e., framing commands,
///     see the documentation for function sitalBc_Start).
/// - This function reads all available GPQ entries, internally stores them, and removes them from the GPQ.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param gespGpqEntry (out)	A pointer to the GPQ entry structure to fill with the now-read GPQ entry
/// @param bIsUserInitiatedGpqReadRequest (in)	A flag that says whether it is the user application who initiated this GPQ read request
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return sitalReturnCode_ReadGpqEntry_NO_NEW_ONES	No entries were read
/// @return sitalReturnCode_ReadGpqEntry_READ_NEW_ENTRY	One entry was read
/// @return sitalReturnCode_ReadGpqEntry_READ_NEW_ENTRY_AND_DETECTED_OVERRUN	One entry was read, and one other or more were lost
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT bc_Gpq_Read (S16BIT swDevice, sitalGpqEntryStructure* gespGpqEntry, BOOLEAN bIsUserInitiatedGpqReadRequest)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (((sitalGpqEntryStructure*)NULL) == gespGpqEntry)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Clear the pointed target GPQ entry.
	gespGpqEntry->wHeader = 0U;
	gespGpqEntry->wData = 0U;

	/// Read the number of the GPQ entry that's going to be filled by the device when so instructed in the next time.
	U16BIT wAddressOfNextFilledGpqEntry; // The device memory address of the GPQ entry that's going to be filled next by the device.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, sitalRegisterAddress_BC_GENERAL_PURPOSE_QUEUE_POINTER, sitalDeviceMemorySection_Registers, 1U, &wAddressOfNextFilledGpqEntry);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// If the GPQ pointer points to the GPQ data instead of the GPQ header of the last inserted entry as it was read while the device was in the middle of adding another entry to the queue:
	///		Artificially revert to pointing the last GPQ header.
	if (0U != (wAddressOfNextFilledGpqEntry % bcMemoryObjectSize_GPQ_ENTRY))
	{
		wAddressOfNextFilledGpqEntry -= (wAddressOfNextFilledGpqEntry % bcMemoryObjectSize_GPQ_ENTRY);
	}
	U16BIT wIndexOfNextFilledGpqEntry; // The index of the GPQ entry that's going to be filled next by the device.
	wIndexOfNextFilledGpqEntry = GPQ_ENTRY_INDEX(wAddressOfNextFilledGpqEntry);

	/// Record the initial count of lost GPQ entries.
	GeneralPurposeQueueStateStructure* gpqsspGpqState; // A pointer to a GPQ state structure.
	gpqsspGpqState = &(dsspDeviceState->bsBcState.gpqssGpqState);
	U16BIT wPreviousCountOfLostGpqEntries; // The count of lost GPQ entries as it is when this function is being entered.
	wPreviousCountOfLostGpqEntries = gpqsspGpqState->wLostGpqEntryCount;

	/// Locate the pointer to the presumably last handled GPQ entry.
	U16BIT dwIndexOfPreviouslyReadGpqEntry; // The index of GPQ entry that has been read in the previous call to this function.
	if (0U == gpqsspGpqState->wIndexOfNextReadGpqEntry)
	{
		// Last time reached the start of the stack, so the presumably last handled GPQ entry was the last one.
		dwIndexOfPreviouslyReadGpqEntry = (sitalBcCounter_GPQ_ENTRIES - 1U);
	}
	else
	{
		// The presumably last handled GPQ entry is simply one entry backward.
		dwIndexOfPreviouslyReadGpqEntry = (gpqsspGpqState->wIndexOfNextReadGpqEntry - 1U);
	}

	/// Read the presumably last handled GPQ entry.
	/// If it contains a non zero:
	///		Properly increment the count of lost entries.
	///		Move to the entry past the one to be next filled.
	// Note that if the presumably last handled GPQ entry has been really previously handled, it must have been zeroed (see the code below).
	// Therefore, if it isn't zeroed, it says that GPQ overrun has occurred, along which this entry has been refilled.
	// In this case we really don't know how many overruns really have happened since the last call to this function, but assume a single one.
	// So assuming, it's clear that:
	// - The number of entries we just lost is the sum of the following:
	//   - The total number of entries in the GPQ
	//   - The number of entries between the one that should have had read now and the one that is currently pointed by the GPQ pointer register
	// - The oldest unhandled GPQ entry that now exists is the entry next to the one currently pointed by the GPQ pointer register
	U16BIT wPreviouslyReadGpqEntry; // The current contents of the first word of the GPQ entry that has been read in the previous call to this function.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, GPQ_ENTRY_ADDRESS(dwIndexOfPreviouslyReadGpqEntry), sitalDeviceMemorySection_Ram, 1U, &wPreviouslyReadGpqEntry);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	if (0U != wPreviouslyReadGpqEntry)
	{
		if (wIndexOfNextFilledGpqEntry < gpqsspGpqState->wIndexOfNextReadGpqEntry)
		{
			gpqsspGpqState->wLostGpqEntryCount += (sitalBcCounter_GPQ_ENTRIES + (sitalBcCounter_GPQ_ENTRIES - (gpqsspGpqState->wIndexOfNextReadGpqEntry - wIndexOfNextFilledGpqEntry)));
		}
		else
		{
			gpqsspGpqState->wLostGpqEntryCount += (sitalBcCounter_GPQ_ENTRIES + (wIndexOfNextFilledGpqEntry - gpqsspGpqState->wIndexOfNextReadGpqEntry));
		}

		gpqsspGpqState->wIndexOfNextReadGpqEntry = (wIndexOfNextFilledGpqEntry + 1U);
		if (sitalBcCounter_GPQ_ENTRIES == gpqsspGpqState->wIndexOfNextReadGpqEntry)
		{
			gpqsspGpqState->wIndexOfNextReadGpqEntry = 0U;
		}
	}

	///	If configured to collect operational statistics for given device:
	///		Update GPQ fullness statistics for the GPQ given device.
	if (TRUE == dsspDeviceState->bIsOperationalStatisticsCollected)
	{
		gpqsspGpqState->wFullnessPercentage = (U16BIT)( (double)100.0 * (((gpqsspGpqState->wIndexOfNextReadGpqEntry > wIndexOfNextFilledGpqEntry) ? sitalBcCounter_GPQ_ENTRIES : 0U) + wIndexOfNextFilledGpqEntry - gpqsspGpqState->wIndexOfNextReadGpqEntry) / sitalBcCounter_GPQ_ENTRIES );
		gpqsspGpqState->wMaximumFullnessPercentage = ( (gpqsspGpqState->wMaximumFullnessPercentage < gpqsspGpqState->wFullnessPercentage) ? gpqsspGpqState->wFullnessPercentage : gpqsspGpqState->wMaximumFullnessPercentage );
	}

	/// Loop over all newly detected device GPQ entries from the oldest unread entry and on:
	///		Read each new entry .
	///		Zero each device GPQ entry after reading it.
	///		Cyclically promote the index of the next entry to read in the device GPQ.
	///		Store each new entry within the user's or the library's host GPQ, as appropriate according the new entry's header.
	sitalGpqEntryStructure gesHelperGpqEntry; // A helper GPQ entry.
	HostGeneralPurposeQueueStructure* hgpqspHostGpq; // A pointer to a target host GPQs.
	hgpqspHostGpq = ((HostGeneralPurposeQueueStructure*)NULL);
	while (gpqsspGpqState->wIndexOfNextReadGpqEntry != wIndexOfNextFilledGpqEntry)
	{
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, GPQ_ENTRY_ADDRESS(gpqsspGpqState->wIndexOfNextReadGpqEntry), sitalDeviceMemorySection_Ram, bcMemoryObjectSize_GPQ_ENTRY, (U16BIT*)&gesHelperGpqEntry);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}

		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Zero, GPQ_ENTRY_ADDRESS(gpqsspGpqState->wIndexOfNextReadGpqEntry), sitalDeviceMemorySection_Ram, bcMemoryObjectSize_GPQ_ENTRY, ((U16BIT*)NULL));
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}

		gpqsspGpqState->wIndexOfNextReadGpqEntry += 1U;
		if (sitalBcCounter_GPQ_ENTRIES == gpqsspGpqState->wIndexOfNextReadGpqEntry)
		{
			gpqsspGpqState->wIndexOfNextReadGpqEntry = 0U;
		}

		switch (gesHelperGpqEntry.wHeader)
		{
		case sitalGeneralPurposeQueueFlag_END_OF_MAJOR_FRAME:
		case sitalGeneralPurposeQueueFlag_END_OF_MINOR_FRAME:
		case sitalGeneralPurposeQueueFlag_WATCHDOG_TIMEOUT:
			hgpqspHostGpq = &(dsspDeviceState->bsBcState.hgpqsLibraryGpqContents);
			break;

		default:
			hgpqspHostGpq = &(dsspDeviceState->bsBcState.hgpqsUserGpqContents);
			break;
		}

		memcpy (&(hgpqspHostGpq->sgesaHostGpq[hgpqspHostGpq->wIndexOfNextFilledGpqEntry]), &gesHelperGpqEntry, (bcMemoryObjectSize_GPQ_ENTRY << 1U));

		hgpqspHostGpq->wIndexOfNextFilledGpqEntry += 1U;
		if (sitalBcCounter_GPQ_ENTRIES == hgpqspHostGpq->wIndexOfNextFilledGpqEntry)
		{
			hgpqspHostGpq->wIndexOfNextFilledGpqEntry = 0U;
		}
	}

	/// Determine what host GPQ contents structure shall be used in order to fill the pointed GPQ entry structure.
	hgpqspHostGpq = ( (TRUE == bIsUserInitiatedGpqReadRequest) ? &(dsspDeviceState->bsBcState.hgpqsUserGpqContents) : &(dsspDeviceState->bsBcState.hgpqsLibraryGpqContents) );

	/// If no new GPQ entries were detected in the requested source host GPQ:
	///		Return an appropriate indication.
	if (hgpqspHostGpq->wIndexOfNextReadGpqEntry == wIndexOfNextFilledGpqEntry)
	{
		return sitalReturnCode_ReadGpqEntry_NO_NEW_ONES;
	}

	// There's at least one new GPQ entry in the requested source host GPQ.
	/// Copy one new entry from the requested source host GPQ to the pointed GPQ entry structure.
	void* vp; // A pointer to a void.
	vp = memcpy (gespGpqEntry, &(hgpqspHostGpq->sgesaHostGpq[hgpqspHostGpq->wIndexOfNextReadGpqEntry]), (bcMemoryObjectSize_GPQ_ENTRY << 1U));

	/// If the requested source host GPQ is the user's host GPQ:
	///		Remove the entry that has been just read from the source host GPQ.
	if (TRUE == bIsUserInitiatedGpqReadRequest)
	{
		if (hgpqspHostGpq->wIndexOfNextReadGpqEntry != hgpqspHostGpq->wIndexOfNextFilledGpqEntry)
		{
			hgpqspHostGpq->wIndexOfNextReadGpqEntry += 1U;
			if (sitalBcCounter_GPQ_ENTRIES == hgpqspHostGpq->wIndexOfNextReadGpqEntry)
			{
				hgpqspHostGpq->wIndexOfNextReadGpqEntry = 0U;
			}
		}
	}

	/// If one new GPQ entry have been read and no overrun has been detected in the requested source host GPQ:
	///		Return an appropriate indication.
	if (wPreviousCountOfLostGpqEntries == gpqsspGpqState->wLostGpqEntryCount)
	{
		return sitalReturnCode_ReadGpqEntry_READ_NEW_ENTRY;
	}

	/// If one new GPQ entry have been read after an overrun has been detected in the requested source host GPQ:
	///		Return an appropriate indication.
	return sitalReturnCode_ReadGpqEntry_READ_NEW_ENTRY_AND_DETECTED_OVERRUN;
}


/// <summary>
/// Set given effect with the state of given GFP condition of given BC device.
///
/// Note:
/// - This function assumes that given device ID is legal.
/// - This function assumes that given device has already been initialized as BC.
/// - This function assumes that given GPF condition is legal.
/// - This function assumes that given effect is legal.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wGpfNumber (in)	 General-purpose-flag-related condition code (sitalBcGpf_GFP*)
/// @param wEffect (in)	 Requested effect (sitalBcGpfEffect_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT bc_Gpf_SetState (S16BIT swDevice, U16BIT wGpfNumber, U16BIT wEffect)
{
	/// @pseudocode

	/// If real effect requested:
	///		Build a suitable effect-causing mask.
	///		If the device isn't currently running:
	///			Update the GPF register image.
	///		Else:
	///			Update the GPF register.
	// Note:
	// Along this update zeros are written to the clear and set bits of all the other GPF conditions at the GPF register.
	// As this is exactly like calling this function with a 'leave' request for each condition bit, this makes no effect on them.
	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalBcGpfEffect_LEAVE != wEffect)
	{
		static const U16BIT s_waGpfEffectCausingMask[] // Array of GPF bit effect-causing masks.
							= { bcGpfEffect_LEAVE, bcGpfEffect_SET, bcGpfEffect_CLEAR, bcGpfEffect_TOGGLE };

							S16BIT swResult; // Result of operation or function call.
		U16BIT wBitSpecificGpfEffectCausingMask; // A mask that's specifically constructed to cause given effect on given GPF bit.
		wBitSpecificGpfEffectCausingMask = (s_waGpfEffectCausingMask[wEffect] << wGpfNumber);

		if (sitalDeviceState_READY == dsspDeviceState->wCurrentState)
		{
			swResult = device_Register_UpdateImage (swDevice, sitalRegisterAddress_BC_GENERAL_PURPOSE_FLAG, registerMask_ALL_BITS_ON, wBitSpecificGpfEffectCausingMask);
		}
		else
		if (sitalDeviceState_RUN == dsspDeviceState->wCurrentState)
		{
			S16BIT swResult; // Result of operation or function call.
			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_BC_GENERAL_PURPOSE_FLAG, sitalDeviceMemorySection_Registers, 1U, &wBitSpecificGpfEffectCausingMask);
			if (sitalReturnCode_SUCCESS != swResult)
			{
				return swResult;
			}
		}
		else
		{
			return sitalReturnCode_INVALID_STATE;
		}
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Write the commands defined by the user for given frame in the memory of given BC device that has previously been allocated for it.
/// (See further information in the documentation for function sitalBc_Command_Create).
///
/// Note:
/// - This function assumes that given device ID is legal.
/// - This function assumes that given device has already been initialized as BC.
/// - This function assumes that the user has requested given device to execute one of the currently defined major frames.
/// - This function assumes that given frame ID is legal.
/// - This function assumes that given frame has already been created.
/// - This function assumes that each of the user defined commands included in given frame has already been created.
/// - This function assumes that the relevant parameters of each of the user defined commands included in given frame have principally valid values.
///   More specifically:
///   - If some command has a single parameter, and this parameter is a message ID, then this function assumes that it contains a value that may
///     principally serve as a message ID, but it does not assume that the designated message has actually been defined.
/// - This function assumes that given pointer to nesting stack isn't null.
/// - This function assumes that the pointed nesting stack properly describes the current frame nesting thread in its current state.
///   (See the documentation for function sitalBc_Start.)
/// - This function passes its called ones a proper and up-to-date nesting stack.
///   In case this function succeeds in building given frame into device memory, it return the nesting stack to its caller in the way it received it;
///   But in case it fails, it does not bother to return a proper nesting stack, as in this case the contents of this stack would be anyway ignored.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wFrameId (in)	A unique ID designating a frame (0-(sitalBcCounter_FRAMES-1))
/// @param nsspNestingStack (in)	A pointer to a nesting stack
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT bc_Frame_WriteCommands (S16BIT swDevice, U16BIT wFrameId, NestingStackStructure* nsspNestingStack)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.

	/// Initialize a helper buffer.
	// A helper buffer of static size is used to decrease the number of device memory write operations, as dynamic allocations are totally avoided by this library.
	S16BIT swResult; // Result of operation or function call.
	//swResult = sitalProcess_Log_PrintLine ("#StldDll.Frame.Commands.Write: unit - %i, frame - %i, nest_stack_size - %i\n", swDevice, wFrameId, nsspNestingStack->wCurrentSizeOfStack);
	U16BIT waHelperBuffer[frameCommandWritingHelperBuffer_COMMAND_COUNT * bcMemoryObjectSize_COMMAND]; // Helper host buffer that prepares a writing to device.
	memset (waHelperBuffer, 0, sizeof(waHelperBuffer));

	/// Calculate the writing border offset from the beginning of the helper buffer.
	// This border is the offset where no additional commands are allowed for writing into the helper buffer.
	// Now, recall that:
	// - In case a software opcode is encountered, it is translated into a series of hardware opcodes.
	// - A call to the high priority asynchronous messages Tx subroutine are added when relevant right after message transmitter commands.
	// Therefore, writing another command to the buffer is allowed only if there's enough additional space for the translation of a software opcode
	// plus a call command.
	U16BIT wNewCommandBorderOffset; // The writing border offset from the beginning of the helper buffer.
	wNewCommandBorderOffset = (sizeof(waHelperBuffer) - ((parsedOpcodeCount_MAXIMUM + asynchronousMessaging_HIGH_PRIORITY_MESSAGE_TX_CALL_COMMAND_COUNT) * bcMemoryObjectSize_COMMAND));

	/// Get the address in device memory where the commands that make up given frame should be written.
	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	HostFrameStructure* hfspFrame; // A pointer to a host frame structure.
	hfspFrame = &(dsspDeviceState->bsBcState.hfsaFrame[wFrameId]);
	U32BIT dwCurrentUserCommandAddress; // The address in device memory where the next command should be written.
	dwCurrentUserCommandAddress = hfspFrame->dwUserCommandsBaseAddress;

	/// Calculate the device memory addresses of the commands included in given frame in order to facilitate the resolve of jump commands.
	U16BIT wCommandId; // The ID of the currently processed command of given frame.
	HostCommandStructure* hcspCommand; // A pointer to a host command structure.
	U32BIT* dwpCurrentCommandAddress; // A pointer to the currently calculated address of user defined command.
	dwpCurrentCommandAddress = hfspFrame->dwaCommandAddress;
	BOOLEAN bIsHighPriorityAsunchronousMessaging; // A flag that says whether high priority asynchronous messaging supported.
	bIsHighPriorityAsunchronousMessaging = ( (sitalBcSetupOption_ASYNCHRONOUS_HIGH_PRIORITY_MODE == (sitalBcSetupOption_ASYNCHRONOUS_HIGH_PRIORITY_MODE & dsspDeviceState->bsBcState.dwOptions)) ? TRUE : FALSE );
	BOOLEAN bIsMessageTxCommand; // A flag that says whether current command is a message transmitter command.
	S32BIT iCommand; // Command index.
	for (iCommand=0; iCommand<((S32BIT)(hfspFrame->wCommandCount)); iCommand++, dwpCurrentCommandAddress++)
	{
		(*dwpCurrentCommandAddress) = dwCurrentUserCommandAddress;

		wCommandId = ((U16BIT)(hfspFrame->swaCommandId[iCommand]));
		hcspCommand = &(dsspDeviceState->bsBcState.hcsaCommand[wCommandId]);
		if (sitalOpcode_TIME_CONDITIONED_MESSAGE_TX == hcspCommand->wOpcode)
		{
			dwCurrentUserCommandAddress += (parsedOpcodeCount_TIME_CONDITIONED_MESSAGE_TX * bcMemoryObjectSize_COMMAND);
			bIsMessageTxCommand = TRUE;
		}
		else
		if ((sitalOpcode_EXECUTE_MESSAGE == hcspCommand->wOpcode) || (sitalOpcode_EXECUTE_AND_FLIP == hcspCommand->wOpcode))
		{
			dwCurrentUserCommandAddress += bcMemoryObjectSize_COMMAND;
			bIsMessageTxCommand = TRUE;
		}
		else
		{
			dwCurrentUserCommandAddress += bcMemoryObjectSize_COMMAND;
			bIsMessageTxCommand = FALSE;
		}
		if ((TRUE == bIsMessageTxCommand) && (TRUE == bIsHighPriorityAsunchronousMessaging))
		{
			dwCurrentUserCommandAddress += (asynchronousMessaging_HIGH_PRIORITY_MESSAGE_TX_CALL_COMMAND_COUNT * bcMemoryObjectSize_COMMAND);
		}
	}
	dwCurrentUserCommandAddress = hfspFrame->dwUserCommandsBaseAddress;

	/// Loop over all the user defined commands that are part of given frame:
	///		Process each command in light of its defined condition and parameter.
	///		Write it into the helper buffer.
	///		If that's a JMP command:
	///			Turn the U32BIT representation back into S32BIT representation to allow negative jump offsets.
	///			Calculate the target jump address while considering the type of the adjacent (or jumped over) commands.
	///		If that's a XQF command:
	///			Record the address at device memory where the message address parameter is written
	///		If that's a message transmitter command and high priority asynchronous messages Tx is supported:
	///			Add a command that calls to the high priority asynchronous messages Tx subroutine.
	///		If the writing border offset was reached:
	///			Write the current contents of the helper buffer into device memory.
	///			Properly promote the address in device memory where the next command should be written.
	///			Retreat to the point the beginning of the helper buffer.
	U16BIT* wpCurrentWrittenWord; // A pointer to the word in the helper buffer where to write next.
	wpCurrentWrittenWord = waHelperBuffer;
	U16BIT wWordCount; // The counter of words that were already written to the helper buffer.
	wWordCount = 0U;
	HostMessageStructure* hmspMessage; // A pointer to a host message structure.
	HostDataBlockStructure* hdbspDataBlock; // A pointer to a host data block structure.
	for (iCommand=0; iCommand<hfspFrame->wCommandCount; iCommand++, dwpCurrentCommandAddress++)
	{
		wCommandId = ((U16BIT)(hfspFrame->swaCommandId[iCommand]));
		hcspCommand = &(dsspDeviceState->bsBcState.hcsaCommand[wCommandId]);
		U16BIT wParameter; // A command parameter.
		wParameter = 0U; // An assignment that prevents a casual compilation warning.
		BOOLEAN bIsHardwareOpcode; // A flag that says whether current command contains a hardware opcode.
		bIsHardwareOpcode = TRUE;
		bIsMessageTxCommand = FALSE;
		switch (hcspCommand->wOpcode)
		{
		case sitalOpcode_TRAP:
		case sitalOpcode_HALT:
		case sitalOpcode_WAIT_END_OF_FRAME:
		case sitalOpcode_START_FRAME_TIMER:
		case sitalOpcode_PUSH_TIME_TAG_COUNTER:
		case sitalOpcode_PUSH_BLOCK_STATUS_WORD:
		case sitalOpcode_WAIT_FOR_TRIGGER:
			{
				wParameter = 0U;
				break;
			}

		case sitalOpcode_EXECUTE_MESSAGE:
			{
				bIsMessageTxCommand = TRUE;
				hmspMessage = &(dsspDeviceState->bsBcState.hmsaMessage[hcspCommand->dwParameter1]);
				if (TRUE == hmspMessage->bIsFreeForUse)
				{
					return sitalReturnCode_UNDEFINED_MESSAGE_BLOCK;
				}
				wParameter = ((U16BIT)(hmspMessage->dwAddress));
				break;
			}

		case sitalOpcode_JUMP:
			{
				S32BIT sdwCommandOffset; // The requested backward/forward offset (in user defined commands).
				sdwCommandOffset = ((S32BIT)(hcspCommand->dwParameter1)); // The U32BIT representation is turned back into S32BIT representation to allow negative jump offsets.
				S32BIT sdwTargetCommandIndex; // The index of the jump target command.
				sdwTargetCommandIndex = ((S32BIT)iCommand + sdwCommandOffset);
				if ((0U > sdwTargetCommandIndex) || (((S32BIT)(hfspFrame->wCommandCount)) <= sdwTargetCommandIndex))
				{
					return sitalReturnCode_UNRESOLVED_JUMP;
				}
				wParameter = hfspFrame->dwaCommandAddress[sdwTargetCommandIndex];
				break;
			}

		case sitalOpcode_CALL_SUBROUTINE:
			{
				swResult = bc_Frame_Write (swDevice, ((U16BIT)(hcspCommand->dwParameter1)), nsspNestingStack);
				if (sitalReturnCode_SUCCESS != swResult)
				{
					return swResult;
				}
				//swResult = sitalProcess_Log_PrintLine ("#StldDll.Frame.Commands.Write.Returned: unit - %i, frame - %i, nest_stack_size - %i, wrote_frame - %i\n", swDevice, wFrameId, nsspNestingStack->wCurrentSizeOfStack, hcspCommand->dwParameter1);
				HostFrameStructure* hfspNestedFrame; // A pointer to a host frame structure.
				hfspNestedFrame = &(dsspDeviceState->bsBcState.hfsaFrame[hcspCommand->dwParameter1]);
				wParameter = ((U16BIT)(hfspNestedFrame->dwAddress));
				break;
			}

		case sitalOpcode_RETURN_FROM_SUBROUTINE:
			{
				if (sitalBcFrameType_MAJOR == hfspFrame->wFrameType)
				{
					return sitalReturnCode_ILLEGAL_FRAME;
				}
				wParameter = 0U;
				break;
			}

		case sitalOpcode_INTERRUPT_REQUEST:
		case sitalOpcode_DELAY:
		case sitalOpcode_COMPARE_TO_FRAME_TIMER:
		case sitalOpcode_COMPARE_TO_MESSAGE_TIMER:
		case sitalOpcode_UPDATE_GENERAL_PURPOSE_FLAG:
		case sitalOpcode_LOAD_TIME_TAG_COUNTER:
		case sitalOpcode_LOAD_FRAME_TIMER:
		case sitalOpcode_PUSH_VALUE:
		case sitalOpcode_PUSH_INDERCT_VALUE:
		case sitalOpcode_FOCUS_ON_VARIABLE:
		case sitalOpcode_PUSH_VARIABLE:
		case sitalOpcode_ADD_TO_VARIABLE:
		case sitalOpcode_LOAD_TO_VARIABLE:
		case sitalOpcode_COMPARE_VARIABLE:
			{
				wParameter = (U16BIT)(hcspCommand->dwParameter1);
				break;
			}

		case sitalOpcode_EXECUTE_AND_FLIP:
			{
				bIsMessageTxCommand = TRUE;
				hmspMessage = &(dsspDeviceState->bsBcState.hmsaMessage[hcspCommand->dwParameter1]);
				if ((TRUE == hmspMessage->bIsFreeForUse) || (bcMemoryObjectSize_DUAL_MESSAGE != hmspMessage->wDeviceMemorySize))
				{
					return sitalReturnCode_UNDEFINED_MESSAGE_BLOCK;
				}
				wParameter = ((U16BIT)(hmspMessage->dwAddress));

				hdbspDataBlock = &(dsspDeviceState->bsBcState.hdbsaDataBlock[hmspMessage->swDataBlockIdForMessage1]);
				hdbspDataBlock->dwOwnerMessageXqfCommandAddress = (dwCurrentUserCommandAddress + wWordCount);
				break;
			}

		case sitalOpcode_TIME_CONDITIONED_MESSAGE_TX:
			{
				bIsMessageTxCommand = TRUE;
				hmspMessage = &(dsspDeviceState->bsBcState.hmsaMessage[hcspCommand->dwParameter1]);
				if (TRUE == hmspMessage->bIsFreeForUse)
				{
					return sitalReturnCode_UNDEFINED_MESSAGE_BLOCK;
				}

				// Calculate parameters required for the hardware opcodes that replace this software opcode.
				U16BIT wMessageTime; // The rounded up time (in us) required to transmit the requested message.
				wMessageTime = (U16BIT)( (hmspMessage->wMessageTxTime / 100U) + ((0U != (hmspMessage->wMessageTxTime % 100)) ? 1U : 0U) );
				U16BIT wActualMinorFrameTime; // The Tx time actually assigned for given frame.
				wActualMinorFrameTime = U16BIT( (0U == dsspDeviceState->bsBcState.wWatchDogTimeout) ? 0xFFFFU : (dsspDeviceState->bsBcState.wWatchDogTimeout + hfspFrame->wFrameTime) );
				U16BIT wEndTimeStamp; // The time stamp when the frame (including the following low priority asynchronous messages, if required, and the message here specified) must end.
				wEndTimeStamp = (wActualMinorFrameTime - hfspFrame->wFrameTime + wMessageTime);

				U16BIT wNumberOfGeneralPurposeFlag; // The number of the GPF to clear once the desired message is successfully transmitted.
				wNumberOfGeneralPurposeFlag = (U16BIT)(0x000FU & hcspCommand->wCondition);

				U32BIT dwPostCommandAddress; // The device memory address of the command that immediately follows the last command into which this software command is translated into and the possibly following call to the high priority asynchronous message Tx subroutine.
				dwPostCommandAddress = ( bcMemoryObjectSize_COMMAND * ( parsedOpcodeCount_TIME_CONDITIONED_MESSAGE_TX + ( (TRUE == bIsHighPriorityAsunchronousMessaging) ? asynchronousMessaging_HIGH_PRIORITY_MESSAGE_TX_CALL_COMMAND_COUNT : 0U ) ) );

				// Flag that's a software opcode.
				bIsHardwareOpcode = FALSE;

				// Prepare the series of hardware commands that replace this software command.
				swResult = sitalBc_Command_GetWord (sitalOpcode_JUMP, hcspCommand->wCondition, wpCurrentWrittenWord);
				wpCurrentWrittenWord++;
				(*wpCurrentWrittenWord) = (U16BIT)dwPostCommandAddress;
				wpCurrentWrittenWord++;
				wWordCount += bcMemoryObjectSize_COMMAND;
				swResult = sitalBc_Command_GetWord (sitalOpcode_COMPARE_TO_FRAME_TIMER, sitalOpcodeCondition_ALWAYS, wpCurrentWrittenWord);
				wpCurrentWrittenWord++;
				(*wpCurrentWrittenWord) = wEndTimeStamp;
				wpCurrentWrittenWord++;
				wWordCount += bcMemoryObjectSize_COMMAND;
				swResult = sitalBc_Command_GetWord (sitalOpcode_JUMP, sitalOpcodeCondition_GREATER_THAN, wpCurrentWrittenWord);
				wpCurrentWrittenWord++;
				(*wpCurrentWrittenWord) = (U16BIT)dwPostCommandAddress;
				wpCurrentWrittenWord++;
				wWordCount += bcMemoryObjectSize_COMMAND;
				swResult = sitalBc_Command_GetWord (sitalOpcode_EXECUTE_MESSAGE, sitalOpcodeCondition_ALWAYS, wpCurrentWrittenWord);
				wpCurrentWrittenWord++;
				(*wpCurrentWrittenWord) = (U16BIT)hmspMessage->dwAddress;
				wpCurrentWrittenWord++;
				wWordCount += bcMemoryObjectSize_COMMAND;
				swResult = sitalBc_Command_GetWord (sitalOpcode_UPDATE_GENERAL_PURPOSE_FLAG, sitalOpcodeCondition_ALWAYS, wpCurrentWrittenWord);
				wpCurrentWrittenWord++;
				(*wpCurrentWrittenWord) = (U16BIT)(0x0100U << wNumberOfGeneralPurposeFlag); // Clear specified GPF.
				wpCurrentWrittenWord++;
				wWordCount += bcMemoryObjectSize_COMMAND;
				break;
			}

		default:
			{
				// Irrelevant: All possible cases were already handled.
				break;
			}
		}

		// If that's a hardware opcode, write the current command into the helper buffer.
		if (TRUE == bIsHardwareOpcode)
		{
			swResult = sitalBc_Command_GetWord (hcspCommand->wOpcode, hcspCommand->wCondition, wpCurrentWrittenWord);
			wpCurrentWrittenWord++;
			(*wpCurrentWrittenWord) = wParameter;
			wpCurrentWrittenWord++;
			wWordCount += bcMemoryObjectSize_COMMAND;
		}

		// Add a command that calls to the high priority asynchronous messages Tx subroutine if relevant and that's a message transmitter command.
		if ( (TRUE == bIsHighPriorityAsunchronousMessaging) && (TRUE == bIsMessageTxCommand) )
		{
			swResult = sitalBc_Command_GetWord (sitalOpcode_CALL_SUBROUTINE, sitalOpcodeCondition_GP6_1, wpCurrentWrittenWord);
			wpCurrentWrittenWord++;
			(*wpCurrentWrittenWord) = ((U16BIT)(dsspDeviceState->bsBcState.dwAddressOfHighAsynchronousTxSubroutine));
			wpCurrentWrittenWord++;
			wWordCount += bcMemoryObjectSize_COMMAND;
		}

		// If the writing border offset was reached, write the current contents of the helper buffer into device memory.
		if (wNewCommandBorderOffset <= wWordCount)
		{
			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, dwCurrentUserCommandAddress, sitalDeviceMemorySection_Ram, wWordCount, waHelperBuffer);
			if (sitalReturnCode_SUCCESS != swResult)
			{
				return swResult;
			}

			dwCurrentUserCommandAddress += wWordCount;
			wpCurrentWrittenWord = waHelperBuffer;
			wWordCount = 0U;
		}
	}

	///	If the helper buffer contains any contents that were still unwritten to device memory:
	///		Write the current contents of the helper buffer into device memory.
	if (0U < wWordCount)
	{
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, dwCurrentUserCommandAddress, sitalDeviceMemorySection_Ram, wWordCount, waHelperBuffer);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Write given frame in the memory of given BC device that has previously been allocated for it.
/// While doing so, add major frame's framing commands to the commands that have been defined for it by the user.
///
/// Note:
/// - This function assumes that given device ID is legal.
/// - This function assumes that given device has already been initialized as BC.
/// - This function assumes that the user has requested given device to execute one of the currently defined major frames.
/// - This function assumes that given frame ID is legal.
/// - This function assumes that given frame has already been created.
/// - This function assumes that given frame is a major frame.
/// - This function assumes that given frame was already allocated device memory for both its framing and user defined commands.
///   (See further information on framing commands in the documentation for function sitalBc_Start).
/// - This function assumes that given pointer to nesting stack isn't null.
/// - This function assumes that the pointed nesting stack properly describes the current frame nesting thread in its current state.
///   (See further information about the nesting stack in the documentation for function sitalBc_Start.)
/// - This function passes its called ones a proper and up-to-date nesting stack.
///   In case this function succeeds in building given frame into device memory, it return the nesting stack to its caller in the way it received it;
///   But in case it fails, it does not bother to return a proper nesting stack, as in this case the contents of this stack would be anyway ignored.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wFrameId (in)	A unique ID designating a frame (0-(sitalBcCounter_FRAMES-1))
/// @param nsspNestingStack (in)	A pointer to a nesting stack
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT bc_Frame_WriteMajor (S16BIT swDevice, U16BIT wFrameId, NestingStackStructure* nsspNestingStack)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.

	/// Initialize a helper buffer.
	// A helper buffer of static size is used to decrease the number of device memory write operations, as dynamic allocations are totally avoided by this library.
	U16BIT waFramingCommands[addedFramingCommandsCount_MajorFrame_MAXIMUM_TOTAL * bcMemoryObjectSize_COMMAND]; // Helper host buffer that prepares a writing to device.
	memset (waFramingCommands, 0, sizeof(waFramingCommands));

	/// Create those framing commands that precede the user commands.
	S16BIT swResult; // Result of operation or function call.
	//swResult = sitalProcess_Log_PrintLine ("#StldDll.Frame.Major.Head.Write: unit - %i, frame - %i, nest_stack_size - %i\n", swDevice, wFrameId, nsspNestingStack->wCurrentSizeOfStack);
	U16BIT* wpCurrentWrittenWord; // A pointer to the currently written word.
	wpCurrentWrittenWord = waFramingCommands;
	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	U16BIT wWordCount; // Word counter.
	wWordCount = 0U;
	// F 00 - focus-variable No.8
	swResult = sitalBc_Command_GetWord (sitalOpcode_FOCUS_ON_VARIABLE, sitalOpcodeCondition_ALWAYS, wpCurrentWrittenWord);
	wpCurrentWrittenWord++;
	(*wpCurrentWrittenWord) = 8U;
	wpCurrentWrittenWord++;
	wWordCount += bcMemoryObjectSize_COMMAND;
	// F 01 - load-focused-variable with the LSWord of iterations count
	swResult = sitalBc_Command_GetWord (sitalOpcode_LOAD_TO_VARIABLE, sitalOpcodeCondition_ALWAYS, wpCurrentWrittenWord);
	wpCurrentWrittenWord++;
	(*wpCurrentWrittenWord) = (U16BIT)(0x0000FFFFU & ((U32BIT)dsspDeviceState->bsBcState.sdwMajorFrameIterationCount));
	wpCurrentWrittenWord++;
	wWordCount += bcMemoryObjectSize_COMMAND;
	// F 02 - focus-variable No.9
	swResult = sitalBc_Command_GetWord (sitalOpcode_FOCUS_ON_VARIABLE, sitalOpcodeCondition_ALWAYS, wpCurrentWrittenWord);
	wpCurrentWrittenWord++;
	(*wpCurrentWrittenWord) = 9U;
	wpCurrentWrittenWord++;
	wWordCount += bcMemoryObjectSize_COMMAND;
	// F 03 - load-focused-variable with the MSWord of iterations count
	swResult = sitalBc_Command_GetWord (sitalOpcode_LOAD_TO_VARIABLE, sitalOpcodeCondition_ALWAYS, wpCurrentWrittenWord);
	wpCurrentWrittenWord++;
	(*wpCurrentWrittenWord) = (U16BIT)((0xFFFF0000U & ((U32BIT)dsspDeviceState->bsBcState.sdwMajorFrameIterationCount)) >> 16U);
	wpCurrentWrittenWord++;
	wWordCount += bcMemoryObjectSize_COMMAND;

	/// Write to device memory those framing commands that precede the iterated user commands.
	HostFrameStructure* hfspFrame; // A pointer to a host frame structure.
	hfspFrame = (HostFrameStructure*)&(dsspDeviceState->bsBcState.hfsaFrame[wFrameId]);
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, hfspFrame->dwAddress, sitalDeviceMemorySection_Ram, wWordCount, waFramingCommands);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Record the address in device memory where this frame's user defined commands should be written.
	hfspFrame->dwUserCommandsBaseAddress = (hfspFrame->dwAddress + (U32BIT)wWordCount);

	/// Write this frame's user defined commands in device memory.
	//   04 - perform the series of commands assigned for this frame by the user (iteration-body)
	swResult = bc_Frame_WriteCommands (swDevice, wFrameId, nsspNestingStack);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Create those framing commands that follow the user commands.
	//wResult = sitalProcess_Log_PrintLine ("#StldDll.Frame.Major.Tail.Write: unit - %i, frame - %i, nest_stack_size - %i\n", swDevice, wFrameId, nsspNestingStack->wCurrentSizeOfStack);
	wpCurrentWrittenWord = waFramingCommands;
	wWordCount = 0U;
	// F 05 - jump always(if running forever)-or-never(if running 1 or more times) to-address-04
	U16BIT wCondition; // A command condition.
	wCondition = (U16BIT)( (-1 == dsspDeviceState->bsBcState.sdwMajorFrameIterationCount) ? sitalOpcodeCondition_ALWAYS : sitalOpcodeCondition_NEVER );
	swResult = sitalBc_Command_GetWord (sitalOpcode_JUMP, wCondition, wpCurrentWrittenWord);
	wpCurrentWrittenWord++;
	(*wpCurrentWrittenWord) = ((U16BIT)(hfspFrame->dwUserCommandsBaseAddress));
	wpCurrentWrittenWord++;
	wWordCount += bcMemoryObjectSize_COMMAND;
	// F 06 - focus-variable No.8
	swResult = sitalBc_Command_GetWord (sitalOpcode_FOCUS_ON_VARIABLE, sitalOpcodeCondition_ALWAYS, wpCurrentWrittenWord);
	wpCurrentWrittenWord++;
	(*wpCurrentWrittenWord) = 8U;
	wpCurrentWrittenWord++;
	wWordCount += bcMemoryObjectSize_COMMAND;
	// F 07 - decrement-focused-variable by-1
	swResult = sitalBc_Command_GetWord (sitalOpcode_ADD_TO_VARIABLE, sitalOpcodeCondition_ALWAYS, wpCurrentWrittenWord);
	wpCurrentWrittenWord++;
	(*wpCurrentWrittenWord) = (U16BIT)0xFFFFU; // -1.
	wpCurrentWrittenWord++;
	wWordCount += bcMemoryObjectSize_COMMAND;
	// F 08 - compare-focused-variable to-zero
	swResult = sitalBc_Command_GetWord (sitalOpcode_COMPARE_VARIABLE, sitalOpcodeCondition_ALWAYS, wpCurrentWrittenWord);
	wpCurrentWrittenWord++;
	(*wpCurrentWrittenWord) = 0U;
	wpCurrentWrittenWord++;
	wWordCount += bcMemoryObjectSize_COMMAND;
	// F 09 - jump if-not-equal to-address-04
	swResult = sitalBc_Command_GetWord (sitalOpcode_JUMP, sitalOpcodeCondition_NOT_EQUAL, wpCurrentWrittenWord);
	wpCurrentWrittenWord++;
	(*wpCurrentWrittenWord) = ((U16BIT)(hfspFrame->dwUserCommandsBaseAddress));
	wpCurrentWrittenWord++;
	wWordCount += bcMemoryObjectSize_COMMAND;
	// F 10 - focus-variable No.9
	swResult = sitalBc_Command_GetWord (sitalOpcode_FOCUS_ON_VARIABLE, sitalOpcodeCondition_ALWAYS, wpCurrentWrittenWord);
	wpCurrentWrittenWord++;
	(*wpCurrentWrittenWord) = 9U;
	wpCurrentWrittenWord++;
	wWordCount += bcMemoryObjectSize_COMMAND;
	// F 11 - compare-focused-variable to-zero
	swResult = sitalBc_Command_GetWord (sitalOpcode_COMPARE_VARIABLE, sitalOpcodeCondition_ALWAYS, wpCurrentWrittenWord);
	wpCurrentWrittenWord++;
	(*wpCurrentWrittenWord) = 0U;
	wpCurrentWrittenWord++;
	wWordCount += bcMemoryObjectSize_COMMAND;
	// F 12 - jump if-equal to-address-15
	U32BIT dwPostLoopAddress; // The address of this frame's post-loop commands.
	dwPostLoopAddress = (hfspFrame->dwAddress + hfspFrame->wActualSize - (3U * bcMemoryObjectSize_COMMAND)); // The third command from the end is at logical address 15 (see below).
	swResult = sitalBc_Command_GetWord (sitalOpcode_JUMP, sitalOpcodeCondition_EQUAL, wpCurrentWrittenWord);
	wpCurrentWrittenWord++;
	(*wpCurrentWrittenWord) = (U16BIT)dwPostLoopAddress;
	wpCurrentWrittenWord++;
	wWordCount += bcMemoryObjectSize_COMMAND;
	// F 13 - decrement-focused-variable by-1
	swResult = sitalBc_Command_GetWord (sitalOpcode_ADD_TO_VARIABLE, sitalOpcodeCondition_ALWAYS, wpCurrentWrittenWord);
	wpCurrentWrittenWord++;
	(*wpCurrentWrittenWord) = (U16BIT)0xFFFFU; // -1.
	wpCurrentWrittenWord++;
	wWordCount += bcMemoryObjectSize_COMMAND;
	// F 14 - jump to-address-04
	swResult = sitalBc_Command_GetWord (sitalOpcode_JUMP, sitalOpcodeCondition_ALWAYS, wpCurrentWrittenWord);
	wpCurrentWrittenWord++;
	(*wpCurrentWrittenWord) = ((U16BIT)(hfspFrame->dwUserCommandsBaseAddress));
	wpCurrentWrittenWord++;
	wWordCount += bcMemoryObjectSize_COMMAND;
	// F 15 - push-to-general-purpose-queue major-frame-ended-flag
	swResult = sitalBc_Command_GetWord (sitalOpcode_PUSH_VALUE, sitalOpcodeCondition_ALWAYS, wpCurrentWrittenWord);
	wpCurrentWrittenWord++;
	(*wpCurrentWrittenWord) = sitalGeneralPurposeQueueFlag_END_OF_MAJOR_FRAME;
	wpCurrentWrittenWord++;
	wWordCount += bcMemoryObjectSize_COMMAND;
	// F 16 - push-to-general-purpose-queue major-frame-ID
	swResult = sitalBc_Command_GetWord (sitalOpcode_PUSH_VALUE, sitalOpcodeCondition_ALWAYS, wpCurrentWrittenWord);
	wpCurrentWrittenWord++;
	(*wpCurrentWrittenWord) = hfspFrame->wId;
	wpCurrentWrittenWord++;
	wWordCount += bcMemoryObjectSize_COMMAND;
	// F 17 - halt
	swResult = sitalBc_Command_GetWord (sitalOpcode_HALT, sitalOpcodeCondition_ALWAYS, wpCurrentWrittenWord);
	wpCurrentWrittenWord++;
	(*wpCurrentWrittenWord) = 0U;
	wpCurrentWrittenWord++;
	wWordCount += bcMemoryObjectSize_COMMAND;

	/// Write to device memory those framing commands that precede the iterated user commands.
	U32BIT dwTrailingFramingCommandsAddress; // The address of this frame's trailing framing commands.
	dwTrailingFramingCommandsAddress = (hfspFrame->dwAddress + hfspFrame->wActualSize - wWordCount);
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, dwTrailingFramingCommandsAddress, sitalDeviceMemorySection_Ram, wWordCount, waFramingCommands);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Write given frame in the memory of given BC device that has previously been allocated for it.
/// While doing so, add minor frame's framing commands to the commands that have been defined for it by the user.
/// As one part of the framing commands that are added to minor frames calls the low priority asynchronous message Tx subroutine (in case this is
/// supported with given device), and as that subroutine is [possibly reallocated device memory and] rebuilt when the user actually later requests the
/// transmission of the low priority asynchronous messages, then also update the list of device memory addresses where the address of that subroutine
/// will be later on recorded at the proper moments along frame run.
/// (See further information in the documentation for function sitalBc_Start).
///
/// Note:
/// - This function assumes that given device ID is legal.
/// - This function assumes that given device has already been initialized as BC.
/// - This function assumes that the user has requested given device to execute one of the currently defined major frames.
/// - This function assumes that given frame ID is legal.
/// - This function assumes that given frame has already been created.
/// - This function assumes that given frame is a minor frame.
/// - This function assumes that given pointer to nesting stack isn't null.
/// - This function assumes that the pointed nesting stack properly describes the current frame nesting thread in its current state.
///   (See the documentation for function sitalBc_Start.)
/// - This function passes its called ones a proper and up-to-date nesting stack.
///   In case this function succeeds in building given frame into device memory, it return the nesting stack to its caller in the way it received it;
///   But in case it fails, it does not bother to return a proper nesting stack, as in this case the contents of this stack would be anyway ignored.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wFrameId (in)	A unique ID designating a frame (0-(sitalBcCounter_FRAMES-1))
/// @param nsspNestingStack (in)	A pointer to a nesting stack
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT bc_Frame_WriteMinor (S16BIT swDevice, U16BIT wFrameId, NestingStackStructure* nsspNestingStack)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.

	// Calculate frame time.
	/// If the executed major frame specifies a frame time to enforce on its nested minor frames:
	///		The frame time specified for the executed major frame is used as frame time.
	/// Else:
	///		The frame time specified for given minor frame is used as frame time.
	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	HostFrameStructure* hfspFrame; // A pointer to a host frame structure.
	hfspFrame = (HostFrameStructure*)&(dsspDeviceState->bsBcState.hfsaFrame[wFrameId]);
	U16BIT wMinorFrameTime; // The Tx time principally assigned for given minor frame.
	wMinorFrameTime = ( (0U == dsspDeviceState->bsBcState.hfspRunningMajorFrame->wFrameTime) ? hfspFrame->wFrameTime : dsspDeviceState->bsBcState.hfspRunningMajorFrame->wFrameTime );

	// Calculate overall/actual frame time.
	/// If watchdog timeout has been defined for given BC device:
	///		The overall frame time is the sum of the frame time and the watchdog timeout.
	/// Else:
	///		The overall frame time is the maximum possible time.
	U16BIT wActualMinorFrameTime; // The Tx time actually assigned for given minor frame.
	wActualMinorFrameTime = (U16BIT)( (0U == dsspDeviceState->bsBcState.wWatchDogTimeout) ? 0xFFFFU : (dsspDeviceState->bsBcState.wWatchDogTimeout + wMinorFrameTime) );

	/// Calculate the frame timer's time stamp when the frame must end.
	U16BIT wEndTimeStamp; // The time stamp when the frame (including the following low priority asynchronous messages, if required) must end.
	wEndTimeStamp = (wActualMinorFrameTime - wMinorFrameTime);

	/// Set proper condition flags.
	BOOLEAN bIsLowPriorityAsynchronousMessagingSupported; // A flag that says whether low priority asynchronous messaging supported.
	bIsLowPriorityAsynchronousMessagingSupported = (BOOLEAN)( (sitalBcSetupOption_ASYNCHRONOUS_LOW_PRIORITY_MODE == (sitalBcSetupOption_ASYNCHRONOUS_LOW_PRIORITY_MODE & dsspDeviceState->bsBcState.dwOptions)) ? TRUE : FALSE );
	BOOLEAN bIsHighPriorityAsynchronousMessagingSupported; // A flag that says whether high priority asynchronous messaging supported.
	bIsHighPriorityAsynchronousMessagingSupported = (BOOLEAN)( (sitalBcSetupOption_ASYNCHRONOUS_HIGH_PRIORITY_MODE == (sitalBcSetupOption_ASYNCHRONOUS_HIGH_PRIORITY_MODE & dsspDeviceState->bsBcState.dwOptions)) ? TRUE : FALSE );
	BOOLEAN bIsHostBufferAssigned; // A flag that says whether a host buffer has been assigned for given BC device.
	bIsHostBufferAssigned = (BOOLEAN)(0U != dsspDeviceState->bsBcState.hbsHostBuffer.dwHostBufferSize);
	BOOLEAN bIsInterruptingEnabledWithFrame; // A flag that says whether interrupt should be issued in regard with given minor frame.
	bIsInterruptingEnabledWithFrame = (BOOLEAN)( (sitalBcFrameFlag_MINOR_FRAME_IRQ_DISABLE != (sitalBcFrameFlag_MINOR_FRAME_IRQ_DISABLE & hfspFrame->wFlags)) ? TRUE : FALSE );

	/// Initialize a helper buffer.
	// A helper buffer of static size is used to decrease the number of device memory write operations, as dynamic allocations are totally avoided by this library.
	U16BIT waFramingCommands[addedFramingCommandsCount_MinorFrame_MAXIMUM_TOTAL * bcMemoryObjectSize_COMMAND]; // Helper host buffer that prepares a writing to device.
	memset (waFramingCommands, 0, sizeof(waFramingCommands));

	/// Create those framing commands that precede the user commands.
	S16BIT swResult; // Result of operation or function call.
	//swResult = sitalProcess_Log_PrintLine ("#StldDll.Frame.Minor.Head.Write: unit - %i, frame - %i, nest_stack_size - %i, lo_async - %c, hi_async_%c, host_buf - %c, i/r_en - %c\n", swDevice, wFrameId, nsspNestingStack->wCurrentSizeOfStack, YES_NO(bIsLowPriorityAsynchronousMessagingSupported), YES_NO(bIsHighPriorityAsynchronousMessagingSupported), YES_NO(bIsHostBufferAssigned), YES_NO(bIsInterruptingEnabledWithFrame));
	U16BIT* wpCurrentWrittenWord; // A pointer to the currently written word.
	wpCurrentWrittenWord = waFramingCommands;
	U16BIT wWordCount; // Word counter.
	wWordCount = 0U;
	// F 00 - load-frame-time
	swResult = sitalBc_Command_GetWord (sitalOpcode_LOAD_FRAME_TIMER, sitalOpcodeCondition_ALWAYS, wpCurrentWrittenWord);
	wpCurrentWrittenWord++;
	(*wpCurrentWrittenWord) = wActualMinorFrameTime;
	wpCurrentWrittenWord++;
	wWordCount += bcMemoryObjectSize_COMMAND;
	// F 01 - start-frame-time
	swResult = sitalBc_Command_GetWord (sitalOpcode_START_FRAME_TIMER, sitalOpcodeCondition_ALWAYS, wpCurrentWrittenWord);
	wpCurrentWrittenWord++;
	(*wpCurrentWrittenWord) = 0U;
	wpCurrentWrittenWord++;
	wWordCount += bcMemoryObjectSize_COMMAND;

	/// Write to device memory those framing commands that precede the iterated user commands.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, hfspFrame->dwAddress, sitalDeviceMemorySection_Ram, wWordCount, waFramingCommands);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Record the address in device memory where this frame's user defined commands should be written.
	hfspFrame->dwUserCommandsBaseAddress = (hfspFrame->dwAddress + (U32BIT)wWordCount);

	/// Write this frame's user defined commands in device memory.
	//   02 - perform the series of commands assigned for this frame by the user (usually a series of message-Tx commands)
	swResult = bc_Frame_WriteCommands (swDevice, wFrameId, nsspNestingStack);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	//wResult = sitalProcess_Log_PrintLine ("#StldDll.Frame.Minor.Write.Returned: unit - %i, frame - %i, nest_stack_size - %i, lo_async - %c, hi_async_%c, host_buf - %c, i/r_en - %c\n", swDevice, wFrameId, nsspNestingStack->wCurrentSizeOfStack, YES_NO(bIsLowPriorityAsynchronousMessagingSupported), YES_NO(bIsHighPriorityAsynchronousMessagingSupported), YES_NO(bIsHostBufferAssigned), YES_NO(bIsInterruptingEnabledWithFrame));

	/// Create those framing commands that follow the user commands.
	//wResult = sitalProcess_Log_PrintLine ("#StldDll.Frame.Minor.Tail.Write: unit - %i, frame - %i, nest_stack_size - %i, lo_async - %c, hi_async_%c, host_buf - %c, i/r_en - %c\n", swDevice, wFrameId, nsspNestingStack->wCurrentSizeOfStack, YES_NO(bIsLowPriorityAsynchronousMessagingSupported), YES_NO(bIsHighPriorityAsynchronousMessagingSupported), YES_NO(bIsHostBufferAssigned), YES_NO(bIsInterruptingEnabledWithFrame));
	wpCurrentWrittenWord = waFramingCommands;
	wWordCount = 0U;
	// F 03 - call if-GPF-7-is-on(if low asynchronous message Tx is supported)-or-never(otherwise) the-low-asynchronous-message-Tx-subroutine
	U16BIT wCondition; // A command condition.
	wCondition = (U16BIT)( (TRUE == bIsLowPriorityAsynchronousMessagingSupported) ? sitalOpcodeCondition_GP7_1 : sitalOpcodeCondition_NEVER );
	swResult = sitalBc_Command_GetWord (sitalOpcode_CALL_SUBROUTINE, wCondition, wpCurrentWrittenWord);
	wpCurrentWrittenWord++;
	(*wpCurrentWrittenWord) = 0U;
	wpCurrentWrittenWord++;
	wWordCount += bcMemoryObjectSize_COMMAND;
	// F 04 - push-to-general-purpose-queue minor-frame-ended-flag
	swResult = sitalBc_Command_GetWord (sitalOpcode_PUSH_VALUE, sitalOpcodeCondition_ALWAYS, wpCurrentWrittenWord);
	wpCurrentWrittenWord++;
	(*wpCurrentWrittenWord) = sitalGeneralPurposeQueueFlag_END_OF_MINOR_FRAME;
	wpCurrentWrittenWord++;
	wWordCount += bcMemoryObjectSize_COMMAND;
	// F 05 - push-to-general-purpose-queue minor-frame-ID
	swResult = sitalBc_Command_GetWord (sitalOpcode_PUSH_VALUE, sitalOpcodeCondition_ALWAYS, wpCurrentWrittenWord);
	wpCurrentWrittenWord++;
	(*wpCurrentWrittenWord) = hfspFrame->wId;
	wpCurrentWrittenWord++;
	wWordCount += bcMemoryObjectSize_COMMAND;
	// F 06 - issue-interrupt always(if interrupts are supported with given minor frame)-or-never(otherwise) IRQ-3
	wCondition = (U16BIT)( (TRUE == bIsInterruptingEnabledWithFrame) ? sitalOpcodeCondition_ALWAYS : sitalOpcodeCondition_NEVER );
	swResult = sitalBc_Command_GetWord (sitalOpcode_INTERRUPT_REQUEST, wCondition, wpCurrentWrittenWord);
	wpCurrentWrittenWord++;
	(*wpCurrentWrittenWord) = (1U << 3U);
	wpCurrentWrittenWord++;
	wWordCount += bcMemoryObjectSize_COMMAND;
	// F 07 - compare-frame-time always(if high asynchronous message Tx is supported)-or-never(otherwise) to-expected-time
	wCondition = (U16BIT)( (TRUE == bIsHighPriorityAsynchronousMessagingSupported) ? sitalOpcodeCondition_ALWAYS : sitalOpcodeCondition_NEVER );
	swResult = sitalBc_Command_GetWord (sitalOpcode_COMPARE_TO_FRAME_TIMER, wCondition, wpCurrentWrittenWord);
	wpCurrentWrittenWord++;
	(*wpCurrentWrittenWord) = wEndTimeStamp;
	wpCurrentWrittenWord++;
	wWordCount += bcMemoryObjectSize_COMMAND;
	// F 08 - push-to-general-purpose-queue if-greater-than(if high asynchronous message Tx is supported)-or-never(otherwise) frame-time-overflow-flag
	wCondition = (U16BIT)( (TRUE == bIsHighPriorityAsynchronousMessagingSupported) ? sitalOpcodeCondition_GREATER_THAN : sitalOpcodeCondition_NEVER );
	swResult = sitalBc_Command_GetWord (sitalOpcode_PUSH_VALUE, wCondition, wpCurrentWrittenWord);
	wpCurrentWrittenWord++;
	(*wpCurrentWrittenWord) = sitalGeneralPurposeQueueFlag_WATCHDOG_TIMEOUT;
	wpCurrentWrittenWord++;
	wWordCount += bcMemoryObjectSize_COMMAND;
	// F 09 - push-to-general-purpose-queue if-greater-than(if high asynchronous message Tx is supported)-or-never(otherwise) minor-frame-ID
	wCondition = (U16BIT)( (TRUE == bIsHighPriorityAsynchronousMessagingSupported) ? sitalOpcodeCondition_GREATER_THAN : sitalOpcodeCondition_NEVER );
	swResult = sitalBc_Command_GetWord (sitalOpcode_PUSH_VALUE, wCondition, wpCurrentWrittenWord);
	wpCurrentWrittenWord++;
	(*wpCurrentWrittenWord) = hfspFrame->wId;
	wpCurrentWrittenWord++;
	wWordCount += bcMemoryObjectSize_COMMAND;
	// F 10 - compare-frame-time to-expected-time (passive-time-spending-loop)
	swResult = sitalBc_Command_GetWord (sitalOpcode_COMPARE_TO_FRAME_TIMER, sitalOpcodeCondition_ALWAYS, wpCurrentWrittenWord);
	wpCurrentWrittenWord++;
	(*wpCurrentWrittenWord) = wEndTimeStamp;
	wpCurrentWrittenWord++;
	wWordCount += bcMemoryObjectSize_COMMAND;
	// F 11 - call if-GPF-7-is-on(if high asynchronous message Tx is supported)-or-never(otherwise) the-high-asynchronous-message-Tx-subroutine
	wCondition = (U16BIT)( (TRUE == bIsHighPriorityAsynchronousMessagingSupported) ? sitalOpcodeCondition_GP6_1 : sitalOpcodeCondition_NEVER );
	swResult = sitalBc_Command_GetWord (sitalOpcode_CALL_SUBROUTINE, wCondition, wpCurrentWrittenWord);
	wpCurrentWrittenWord++;
	(*wpCurrentWrittenWord) = ((U16BIT)(dsspDeviceState->bsBcState.dwAddressOfHighAsynchronousTxSubroutine));
	wpCurrentWrittenWord++;
	wWordCount += bcMemoryObjectSize_COMMAND;
	// F 12 - jump if-less-than to-address-10
	U32BIT dwTimeSpendingLoopAddress; // The address of this frame's post-Tx passive-time-spending-loop commands.
	dwTimeSpendingLoopAddress = (hfspFrame->dwAddress + hfspFrame->wActualSize - (5 * bcMemoryObjectSize_COMMAND)); // The fifth command from the end is at logical address 10 (see above).
	swResult = sitalBc_Command_GetWord (sitalOpcode_JUMP, sitalOpcodeCondition_LESS_THAN, wpCurrentWrittenWord);
	wpCurrentWrittenWord++;
	(*wpCurrentWrittenWord) = (U16BIT)dwTimeSpendingLoopAddress;
	wpCurrentWrittenWord++;
	wWordCount += bcMemoryObjectSize_COMMAND;
	// F 13 - issue-interrupt if-good-message(if both high asynchronous message Tx is supported and host buffer is assigned)-or-never(otherwise) IRQ-2
	wCondition = (U16BIT)( ((TRUE == bIsHighPriorityAsynchronousMessagingSupported) && (TRUE == bIsHostBufferAssigned))? sitalOpcodeCondition_GOOD_MESSAGE : sitalOpcodeCondition_NEVER );
	swResult = sitalBc_Command_GetWord (sitalOpcode_INTERRUPT_REQUEST, wCondition, wpCurrentWrittenWord);
	wpCurrentWrittenWord++;
	(*wpCurrentWrittenWord) = (1U << 2U);
	wpCurrentWrittenWord++;
	wWordCount += bcMemoryObjectSize_COMMAND;
	// F 14 - return
	swResult = sitalBc_Command_GetWord (sitalOpcode_RETURN_FROM_SUBROUTINE, sitalOpcodeCondition_ALWAYS, wpCurrentWrittenWord);
	wpCurrentWrittenWord++;
	(*wpCurrentWrittenWord) = 0U;
	wpCurrentWrittenWord++;
	wWordCount += bcMemoryObjectSize_COMMAND;

	/// Write to device memory those framing commands that precede the iterated user commands.
	U32BIT dwTrailingFramingCommandsAddress; // The address of this frame's trailing framing commands.
	dwTrailingFramingCommandsAddress = (hfspFrame->dwAddress + hfspFrame->wActualSize - wWordCount);
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, dwTrailingFramingCommandsAddress, sitalDeviceMemorySection_Ram, wWordCount, waFramingCommands);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	///	Record the address where the address of the low priority message Tx subroutine shall be written once this subroutine is built in device memory.
	// This is actually the address of the parameter of command 03 (see above).
	dsspDeviceState->bsBcState.dwaLowAsynchronousTxSubroutineCallAddress[dsspDeviceState->bsBcState.wNestedMinorFrameCount] = (dwTrailingFramingCommandsAddress + 1U);

	/// Count this nested minor frame.
	dsspDeviceState->bsBcState.wNestedMinorFrameCount++;

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Unless already did so with given frame, actually allocate it enough memory within given BC device, and write it there.
/// While doing so, add suitable framing commands to the commands that have been defined for it by the user.
/// As one part of the framing commands that are added for minor frames is a calls to the low priority asynchronous message Tx subroutine, if this is
/// supported with given device, and as that subroutine is [possibly reallocated device memory and] rebuilt when the user actually later requests the
/// transmission of the low priority asynchronous messages, then also create a list of device memory addresses where the address of that subroutine
/// will be later on recorded at the proper moments along frame run.
/// Prohibit illegal nesting of frames.
/// Verify that the currently ongoing process of writing a major frame in device memory is causing no overflow of the frame nesting stack.
/// (See further information in the documentation for function sitalBc_Start).
///
/// Note:
/// - This function assumes that given device ID is legal.
/// - This function assumes that given device has already been initialized as BC.
/// - This function assumes that the user has requested given device to execute one of the currently defined major frames.
/// - This function assumes that given frame ID is legal.
/// - This function does not assume that given frame has already been created.
/// - This function assumes that given pointer to nesting stack isn't null.
/// - This function assumes that the pointed nesting stack properly describes the current frame nesting thread in its current state.
///   (See the documentation for function sitalBc_Start.)
/// - This function expects all frames that were not yet actually created in device memory to be properly signed.
/// - This function does not perform any cleaning operations in case any errors are detected; that's left for function sitalBc_Start.
/// - This function passes its called ones a proper and up-to-date nesting stack.
///   In case this function succeeds in building given frame into device memory, it return the nesting stack to its caller in the way it received it;
///   But in case it fails, it does not bother to return a proper nesting stack, as in this case the contents of this stack would be anyway ignored.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wFrameId (in)	A unique ID designating a frame (0-(sitalBcCounter_FRAMES-1))
/// @param nsspNestingStack (in)	A pointer to a nesting stack
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT bc_Frame_Write (S16BIT swDevice, U16BIT wFrameId, NestingStackStructure* nsspNestingStack)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (sitalBcMaximum_FRAME_NESTING_STACK == nsspNestingStack->wCurrentSizeOfStack)
	{
		return sitalReturnCode_FRAME_NESTING_STACK_OVERFLOW;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	HostFrameStructure* hfspFrame; // A pointer to a host frame structure.
	hfspFrame = (HostFrameStructure*)&(dsspDeviceState->bsBcState.hfsaFrame[wFrameId]);
	if (TRUE == hfspFrame->bIsFreeForUse)
	{
		return sitalReturnCode_UNDEFINED_NODE;
	}

	HostFrameStructure* hfspWrittenMajorFrame; // A pointer to the host's frame structure of the major frame that's now written in device memory.
	hfspWrittenMajorFrame = dsspDeviceState->bsBcState.hfspRunningMajorFrame;
	if (hfspWrittenMajorFrame->wId == wFrameId)
	{
		// Given frame ID is the currently executed major frame; verify it isn't nested within itself.
		if (0U != hfspFrame->wActualSize)
		{
			return sitalReturnCode_NESTED_MAJOR_FRAME;
		}
	}
	else
	if (sitalBcFrameType_MAJOR == hfspFrame->wFrameType)
	{
		// Given frame ID designates a major frame different from the currently executed major frame, and that's kind of nesting is prohibited.
		return sitalReturnCode_NESTED_MAJOR_FRAME;
	}

	for (U16BIT i=0U; i<nsspNestingStack->wCurrentSizeOfStack; i++)
	{
		if (nsspNestingStack->waFrameIdStack[i] == wFrameId)
		{
			// Given minor frame has already been nested along the current thread of frame nesting.
			return sitalReturnCode_FRAME_NESTING_RECURSION;
		}
	}

	/// if given frame ID designates a minor frame that has already been written in device memory:
	///		return.
	// A minor frame may reappear within a major frame as long as it is not creating a recursion, an option that was just eliminated.
	// Note that the following condition may fulfill only in case given frame ID designates a minor frame (see a relevant condition above).
	if (0U != hfspFrame->wActualSize)
	{
		return sitalReturnCode_SUCCESS;
	}

	/// Push given frame ID into the nesting stack.
	// This has to be done before this function calls itself, what may happen below, so that above checks may be performed then.
	// Note that the following command may not cause stack overflow (see a relevant condition above).
	nsspNestingStack->waFrameIdStack[nsspNestingStack->wCurrentSizeOfStack] = wFrameId;
	nsspNestingStack->wCurrentSizeOfStack++;

	/// Allocate memory in the bottom section of given device where given frame will be written.
	/// Record the base address of this allocation.
	U32BIT dwAllocationSize; // The size (in words) of the device memory allocation.
	dwAllocationSize = hfspFrame->wDeviceMemorySize;
	BOOLEAN bIsAllocationSuccessfullyAccomplished; // A flag that says whether the allocation actually succeeded.
	U32BIT dwAllocationBaseAddress; // The address in device memory where a suitable segment of memory has been allocated for the newly created object.
	S16BIT swResult; // Result of operation or function call.
	//swResult = sitalProcess_Log_PrintLine ("#StldDll.Frame.Write: unit - %i, frame - %i, nest_stack_size - %i\n", swDevice, wFrameId, nsspNestingStack->wCurrentSizeOfStack);
	swResult = Device_Memory_BottomSection_AllocateContinuity ((HostDeviceMemoryMapStructure*)&(dsspDeviceState->hdmmsDeviceMemoryMap), &dwAllocationSize, 5, &bIsAllocationSuccessfullyAccomplished, &dwAllocationBaseAddress);
	if ( (sitalReturnCode_SUCCESS != swResult) || (FALSE == bIsAllocationSuccessfullyAccomplished) )
	{
		return sitalReturnCode_ALLOCATION_FAIL;
	}
	hfspFrame->dwAddress = dwAllocationBaseAddress;

	/// Flag given frame as already written.
	// This has to be done before this function is revisited along a possible recursion, what may happen below, so that above checks may be performed then.
	hfspFrame->wActualSize = hfspFrame->wDeviceMemorySize;

	/// if given frame ID designates a major frame:
	///		Write given frame to device memory wrapped with framing commands suitable for a major frame.
	/// Else:
	///		Write given frame to device memory wrapped with framing commands suitable for a minor frame.
	if (sitalBcFrameType_MAJOR == hfspFrame->wFrameType)
	{
		swResult = bc_Frame_WriteMajor (swDevice, wFrameId, nsspNestingStack);
	}
	else // Minor frame.
	{
		swResult = bc_Frame_WriteMinor (swDevice, wFrameId, nsspNestingStack);
	}
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	// Given frame and all its nested minor frames were successfully written in device memory.
	/// Pop given frame ID from the nesting stack.
	nsspNestingStack->wCurrentSizeOfStack--;

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Allocate in given BC device memory for given message, compose its contents, and write these contents into the allocated device memory.
///
/// Note:
/// - See further information in the documentation for function sitalBc_Message_Create.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swMessageId (in)	A unique ID designating a message (0-(sitalBcCounter_MESSAGES-1))
/// @param swDataBlockIdForMessage1 (in)	A unique ID designating the data block of message 1 (0-(sitalBcCounter_DATA_BLOCKS-1))
/// @param wBcControlWordForMessage1 (in)	The BC control word of message 1 (An or-ed combination of sitalBcControlWord_*)
/// @param wCommandWord1ForMessage1 (in)	Command word 1 of message 1
/// @param wCommandWord2ForMessage1 (in)	Command word 2 of message 1
/// @param wGapTimeForMessage1 (in)	The gap of message 1 (>=0)
/// @param swDataBlockIdForMessage2 (in)	A unique ID designating the data block of message 2 (0-(sitalBcCounter_DATA_BLOCKS-1))
/// @param wBcControlWordForMessage2 (in)	The BC control word of message 2 (An or-ed combination of sitalBcControlWord_*)
/// @param wCommandWord1ForMessage2 (in)	Command word 1 of message 2
/// @param wCommandWord2ForMessage2 (in)	Command word 2 of message 2
/// @param wGapTimeForMessage2 (in)	The gap of message 2 (>=0)
/// @param dwOptions (in)	Message options (An or-ed combination of sitalBcControlWord_* and sitalBcMessageOption_*)
/// @param hmspMessage (out)	A pointer to host structure of the message to write into
/// @param hdbspDataBlock1 (in)	A pointer to host structure of data block 1 of the message to write into
/// @param hdbspDataBlock2 (in)	A pointer to host structure of data block 2 of the message to write into, or NULL in case of a non dual message
/// @param bIsNewMessage (in)	A flag that says whether this function is called in order to create a new message (or, otherwise, only in order to modify an already existing one)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT bc_Message_Write (	S16BIT swDevice,
							S16BIT swMessageId,
							S16BIT swDataBlockIdForMessage1,
							U16BIT wBcControlWordForMessage1,
							U16BIT wCommandWord1ForMessage1,
							U16BIT wCommandWord2ForMessage1,
							U16BIT wGapTimeForMessage1,
							S16BIT swDataBlockIdForMessage2,
							U16BIT wBcControlWordForMessage2,
							U16BIT wCommandWord1ForMessage2,
							U16BIT wCommandWord2ForMessage2,
							U16BIT wGapTimeForMessage2,
							U32BIT dwOptions,
							HostMessageStructure* hmspMessage,
							HostDataBlockStructure* hdbspDataBlock1,
							HostDataBlockStructure* hdbspDataBlock2,
							BOOLEAN bIsNewMessage)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.

	/// Determine the size of given message.
	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalBcMessageOption_DUAL_MESSAGE == (sitalBcMessageOption_DUAL_MESSAGE & hmspMessage->dwOptions))
	{
		if (TRUE == dsspDeviceState->bLimitedOperationDevice)
		{
			// A limited-performance device is restricted from using command words in which bit #4 of the word-count-or-mode-code field is on.
			if ( (0x0010U == (0x0010U & wCommandWord1ForMessage1)) || (0x0010U == (0x0010U & wCommandWord2ForMessage1)) || (0x0010U == (0x0010U & wCommandWord1ForMessage2)) || (0x0010U == (0x0010U & wCommandWord2ForMessage2)) )
			{
				printf("A limited-performance device is restricted from using command words in which bit #4 of the word-count-or-mode-code field is on.");
				return sitalReturnCode_LIMITED_DEVICE;
			}

			// A limited-performance device is restricted from using bus-B.
			if ( (sitalBcControlWord_BUS_A == (sitalBcControlWord_BUS & wBcControlWordForMessage1)) || (sitalBcControlWord_BUS_A == (sitalBcControlWord_BUS & wBcControlWordForMessage2)) )
			{
				printf("A limited-performance device is restricted on using bus-B");
				return sitalReturnCode_LIMITED_DEVICE;
			}
		}

		// A dual message is requested.
		hmspMessage->wActualSize = bcMemoryObjectSize_DUAL_MESSAGE;
	}
	else
	{
		if (TRUE == dsspDeviceState->bLimitedOperationDevice)
		{
			// A limited-performance device is restricted from using command words in which bit #4 of the word-count-or-mode-code field is on.
			if ( (0x0010U == (0x0010U & wCommandWord1ForMessage1)) || (0x0010U == (0x0010U & wCommandWord2ForMessage1)) )
			{
				printf("A limited-performance device is restricted from using command words in which bit #4 of the word-count-or-mode-code field is on.");
				return sitalReturnCode_LIMITED_DEVICE;
			}

			// A limited-performance device is restricted from using bus-B.
			if ( (sitalBcControlWord_BUS_A == (sitalBcControlWord_BUS & wBcControlWordForMessage1)) )
			{
				printf("A limited-performance device is restricted on using bus-B.");
				return sitalReturnCode_LIMITED_DEVICE;
			}
		}

		// A single message is requested, discern between a regular message and a RT-to-RT message.
		if (sitalBcControlWord_RT_TO_RT == (sitalBcControlWord_RT_TO_RT & wBcControlWordForMessage1))
		{
			hmspMessage->wActualSize = bcMemoryObjectSize_LARGE_MESSAGE;
		}
		else
		{
			hmspMessage->wActualSize = bcMemoryObjectSize_NORMAL_MESSAGE;
		}
	}

	/// Build the described message in a host memory buffer, and then copy it into device memory.
	U16BIT waMessageBuffer[bcMemoryObjectSize_DUAL_MESSAGE]; // A buffer that may contain the longest possible message.
	U16BIT* wpHelper; // A helper word pointer.
	wpHelper = waMessageBuffer;
	/* Set word  0: */ (*wpHelper++) = wBcControlWordForMessage1;
	/* Set word  1: */ (*wpHelper++) = wCommandWord1ForMessage1;
	/* Set word  2: */ (*wpHelper++) = ((U16BIT)(hdbspDataBlock1->dwAddress));
	/* Set word  3: */ (*wpHelper++) = wGapTimeForMessage1;
	/* Set word  4: */ (*wpHelper++) = 0U;
	/* Set word  5: */ (*wpHelper++) = 0U;
	/* Set word  6: */ (*wpHelper++) = 0U;
	/* Set word  7: */ (*wpHelper++) = 0U;
	/* Set word  8: */ (*wpHelper++) = wCommandWord2ForMessage1;
	/* Set word  9: */ (*wpHelper++) = 0U;
	/* Set word 10: */ (*wpHelper++) = 0U;
	/* Set word 11: */ (*wpHelper++) = 0U;
	/* Set word 12: */ (*wpHelper++) = 0U;
	/* Set word 13: */ (*wpHelper++) = 0U;
	/* Set word 14: */ (*wpHelper++) = 0U;
	/* Set word 15: */ (*wpHelper++) = 0U;
	/* Set word 16: */ (*wpHelper++) = wBcControlWordForMessage2;
	/* Set word 17: */ (*wpHelper++) = wCommandWord1ForMessage2;
	/* Set word 18: */ (*wpHelper++) = (U16BIT)((((HostDataBlockStructure*)NULL) == hdbspDataBlock2) ? 0U : hdbspDataBlock2->dwAddress);
	/* Set word 19: */ (*wpHelper++) = wGapTimeForMessage2;
	/* Set word 20: */ (*wpHelper++) = 0U;
	/* Set word 21: */ (*wpHelper++) = 0U;
	/* Set word 22: */ (*wpHelper++) = 0U;
	/* Set word 23: */ (*wpHelper++) = 0U;
	/* Set word 24: */ (*wpHelper++) = wCommandWord2ForMessage2;
	/* Set word 25: */ (*wpHelper++) = 0U;
	/* Set word 26: */ (*wpHelper++) = 0U;
	/* Set word 27: */ (*wpHelper++) = 0U;
	/* Set word 28: */ (*wpHelper++) = 0U;
	/* Set word 29: */ (*wpHelper++) = 0U;
	/* Set word 30: */ (*wpHelper++) = 0U;
	/* Set word 31: */ (*wpHelper++) = 0U;

	/// If this is a newly created message:
	///		Allocate and initialize a corresponding host structure for the new message.
	/// Else:
	///		Update the corresponding host structure for the new message.
	// A dual message is statically allocated for each message, never mind whether a normal, RT-to-RT, or dual message is actually required (see further information in the documentation for function sitalBc_Message_Create).
	S16BIT swResult; // Result of operation or function call.
	if (TRUE == bIsNewMessage)
	{
		//const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
		//							= &(s_dssaDevices[swDevice]);
		U32BIT dwAllocationSize; // The size (in words) of the device memory allocation.
		dwAllocationSize = bcMemoryObjectSize_DUAL_MESSAGE;
		BOOLEAN bIsAllocationSuccessfullyAccomplished; // A flag that says whether the allocation actually succeeded.
		U32BIT dwAllocationBaseAddress; // The address in device memory where a suitable segment of memory has been allocated for the newly created object.
		swResult = Device_Memory_TopSection_AllocateContinuity ((HostDeviceMemoryMapStructure*)&(dsspDeviceState->hdmmsDeviceMemoryMap), bcAddressMap_FREE_MEMORY, (dsspDeviceState->dcsDeviceCapabilities.dwRamSize - 1U), &dwAllocationSize, 5, &bIsAllocationSuccessfullyAccomplished, &dwAllocationBaseAddress);
		if ( (sitalReturnCode_SUCCESS != swResult) || (FALSE == bIsAllocationSuccessfullyAccomplished) )
		{
			return sitalReturnCode_ALLOCATION_FAIL;
		}
		hmspMessage->wId = (U16BIT)swMessageId;
		hmspMessage->dwAddress = dwAllocationBaseAddress;
		hmspMessage->wDeviceMemorySize = (U16BIT)dwAllocationSize;
		hmspMessage->wActualSize = bcMemoryObjectSize_DUAL_MESSAGE;
	}
	hmspMessage->dwOptions = dwOptions;
	hmspMessage->swDataBlockIdForMessage1 = swDataBlockIdForMessage1;
	hmspMessage->wBcControlWordForMessage1 = wBcControlWordForMessage1;
	hmspMessage->wCommandWord1ForMessage1 = wCommandWord1ForMessage1;
	hmspMessage->wCommandWord2ForMessage1 = wCommandWord2ForMessage1;
	hmspMessage->swDataBlockIdForMessage2 = swDataBlockIdForMessage2;
	hmspMessage->wBcControlWordForMessage2 = wBcControlWordForMessage2;
	hmspMessage->wCommandWord1ForMessage2 = wCommandWord1ForMessage2;
	hmspMessage->wCommandWord2ForMessage2 = wCommandWord2ForMessage2;
	hmspMessage->wGapTimeForMessage1 = wGapTimeForMessage1;
	hmspMessage->wGapTimeForMessage2 = wGapTimeForMessage2;
	hmspMessage->bIsAsynchronousMessage = FALSE;

	swResult = bc_Message_GetInformation (swDevice, waMessageBuffer, &(hmspMessage->wMessageTxTime), &(hmspMessage->wMessageType), &(hmspMessage->wDataWordCount));
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Copy the new message to device memory.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, hmspMessage->dwAddress, sitalDeviceMemorySection_Ram, hmspMessage->wActualSize, waMessageBuffer);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	hmspMessage->bIsFreeForUse = FALSE;

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Read given message of given BC device in its raw state into given buffer, and then purge given message if so requested.
/// Within returned message block, override the data block address field with a combined word value whose:
/// - Lower byte contains the type of given message.
/// - Higher byte contains the count of data words of given message.
///
/// Note:
/// - This function assumes that given device ID is legal.
/// - This function assumes that given device has already been initialized as BC.
/// - This function assumes that given device is currently at state of either ready or run.
/// - This function assumes that given message ID is legal.
/// - This function assumes that given message has already been created.
/// - This function assumes that given buffer pointer isn't NULL.
/// - This function assumes that given buffer is at least sitalBcMaximum_MESSAGE_SIZE words long.
/// - Given buffer is first zeroed, and then filled as follows:
///   - The target message block is copied into it.
///   - The data stack pointer is replaced with a word whose:
///     - MSByte contains the count of data words for the message that was read.
///     - LSByte contains the type of the message that was read (sitalMessageType_*).
///   - The data words are stored right after the longest possible message block, that is, starting at offset sitalBcMaximum_ACTUAL_MESSAGE_BLOCK.
///     In case of a mode code message with data, this data word is returned as the first (actually the single) data word.
/// - Message data is copied under assumption that the expected number of data words has been actually received, what the caller may verify by checking the block status.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swMessageId (in)	A unique ID designating a message (0-(sitalBcCounter_MESSAGES-1))
/// @param wapBuffer (out)	A pointer to a buffer into which given message is copied
/// @param wIsPurgeRequired (in)	A flag that says whether should zero the end of message bit of the block status word within the message block of given message
/// @return 1	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT bc_Message_GetByIdRaw (	S16BIT swDevice,
								S16BIT swMessageId,
								U16BIT* wapBuffer,
								U16BIT wIsPurgeRequired)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.

	/// Zero given buffer.
	memset (wapBuffer, 0, (sitalBcMaximum_MESSAGE_SIZE << 1U));

	/// Determine the size of the actual part of the raw message block of given message.
	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	HostMessageStructure* hmspMessage; // A pointer to a host message structure.
	hmspMessage = (HostMessageStructure*)&(dsspDeviceState->bsBcState.hmsaMessage[swMessageId]);
	U16BIT wExactMessageBlockSize; // The exact size of the message block of given message.
	wExactMessageBlockSize = (U16BIT)( ((messageTypeComponent_MODE != (messageTypeComponent_MODE & hmspMessage->wMessageType)) && (messageTypeComponent_DATA == (messageTypeComponent_DATA & hmspMessage->wMessageType))) ? bcMemoryObjectSize_RT_TO_RT_MESSAGE : bcMemoryObjectSize_NORMAL_MESSAGE );

	/// Read the whole actual part of the raw message block of given message from device memory.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, hmspMessage->dwAddress, sitalDeviceMemorySection_Ram, wExactMessageBlockSize, wapBuffer);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	// Verify that given message has been completed.
	// Once a message is completed, the end of message bit of the block status word within its message block is set.
	if (sitalBcBlockStatusWord_END_OF_MESSAGE != (sitalBcBlockStatusWord_END_OF_MESSAGE & wapBuffer[bcMessageBlock_OFFSET_OF_BLOCK_STATUS]))
	{
		return sitalReturnCode_MESSAGE_ERROR;
	}

	/// If message purge required:
	///		Zero the end of message bit of the block status word within the message block of given message.
	if (TRUE == wIsPurgeRequired)
	{
		U16BIT wZero; // A zero containing word.
		wZero = 0U;
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, (hmspMessage->dwAddress + bcMessageBlock_OFFSET_OF_BLOCK_STATUS), sitalDeviceMemorySection_Ram, 1U, &wZero);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
	}

	/// If given message has any data words:
	///		Read given message's data words.
	/// Note: In case of mode code messages with data, the single data word is always read from the first data word of the data block.
	if (0U < hmspMessage->wDataWordCount)
	{
		swResult = sitalBc_DataBlock_Read (swDevice, hmspMessage->swDataBlockIdForMessage1, (wapBuffer + sitalBcMaximum_ACTUAL_MESSAGE_BLOCK), hmspMessage->wDataWordCount, 0);
		if (0U > (U16BIT)swResult)
		{
			return swResult;
		}
	}

	/// Store within given buffer the count of data words in this message.
	// Note: Data is copied under assumption that the expected number of data word has been actually received, what the caller may verify by checking the block status.
	// As the message block's data block address field isn't relevant for the caller, who gets the data words within supplied buffer,
	// this field is used to return to the user a combined word value whose:
	// - Lower byte contains the type of given message.
	// - Higher byte contains the count of data words of given message.
	wapBuffer[bcMessageBlock_OFFSET_OF_DATA_BLOCK_ADDRESS] = ( (hmspMessage->wDataWordCount << 8U)  | hmspMessage->wMessageType );

	return 1;
}


/// <summary>
/// Get information about given message of given BC device.
///
/// Note:
/// - This function assumes that given device ID is legal.
/// - This function assumes that given device has already been initialized as BC.
/// - This function assumes that parameter wpMessageBuffer isn't NULL.
/// - Returned message type may be interpreted as either sitalMessageType_* or as an or-ed combination of messageTypeComponent_*.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wpMessageBuffer	A pointer to a buffer that contains the raw message
/// @param wpTxTime	A pointer to a variable in which given message's estimated Tx time is returned, or NULL if this information isn't required
/// @param wpType	A pointer to a variable in which given message's type is returned, or NULL if this information isn't required
/// @param wpTxTime	A pointer to a variable in which count of data words in messages of given type is returned, or NULL if this information isn't required
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT bc_Message_GetInformation (	S16BIT swDevice,
									U16BIT *wpMessageBuffer,
									U16BIT* wpTxTime,
									U16BIT* wpType,
									U16BIT* wpDataWordsCount)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.

	U16BIT wBcControlWord; // Given message's BC control word.
	wBcControlWord = wpMessageBuffer[0];

	U16BIT wCommandWord1; // Given message's command word 1.
	wCommandWord1 = wpMessageBuffer[1];

	U16BIT wSubaddressOrMode; // Given message's subaddress-or-mode field.
	wSubaddressOrMode = (U16BIT)((commandWord_SUBADDRESS_OR_MODE & wCommandWord1) >> commandWord_OFFSET_OF_SUBADDRESS_OR_MODE);

	/// Analyze the message's command word in order to find the type of this message and the number of data words.
	U16BIT wType; // The type of given message.
	U16BIT wDataWordsCount; // The number of data words in given message.
	wType = 0U;
	wDataWordsCount = 0U;
	if (commandWord_BROADCAST == (commandWord_RT_ADDRESS & wCommandWord1))
	{
		wType |= messageTypeComponent_BROADCAST;
	}
	if (commandWord_TX == (commandWord_RX_OR_TX & wCommandWord1))
	{
		wType |= messageTypeComponent_TX;
	}
	if ((sital1553_MODE_CODE1 == wSubaddressOrMode) || (sital1553_MODE_CODE2 == wSubaddressOrMode))
	{
		// Given message contains a mode command.
		wType |= messageTypeComponent_MODE;

		if (commandWord_MODE_WITH_DATA == (commandWord_MODE_WITH_OR_WITHOUT_DATA & wCommandWord1))
		{
			wType |= messageTypeComponent_DATA;
			wDataWordsCount = 1U;
		}
	}
	else
	{
		if (sitalBcControlWord_RT_TO_RT == (sitalBcControlWord_RT_TO_RT & wBcControlWord))
		{
			wType |= messageTypeComponent_DATA;
		}

		wDataWordsCount = (U16BIT)((commandWord_WORD_COUNT_OR_MODE_CODE & wCommandWord1) >> commandWord_OFFSET_OF_WORD_COUNT_OR_MODE_CODE);
		if (0U == wDataWordsCount)
		{
			wDataWordsCount = 32U;
		}
	}

	///	Analyze the message in order to find its overall word count and its gaps count.
	U16BIT wOverallMessageWordsCount; // The overall number of words transmitted on the bus with given message (inc. command, status, and data words).
	U16BIT wGapsCount; // The number of gaps expected along the transmission of given message.
	wOverallMessageWordsCount = wDataWordsCount;

	switch (wType)
	{
	case sitalMessageType_RT_TO_RT:
		wOverallMessageWordsCount += 4U;
		wGapsCount = 2U;
		break;
	case sitalMessageType_BROADCAST_RT_TO_RT:
		wOverallMessageWordsCount += 3U;
		wGapsCount = 1U;
		break;
	case sitalMessageType_BC_TO_RT:
	case sitalMessageType_RT_TO_BC:
	case sitalMessageType_MODE_NO_DATA:
	case sitalMessageType_MODE_DATA_RX:
	case sitalMessageType_MODE_DATA_TX:
		wOverallMessageWordsCount += 2U;
		wGapsCount = 1U;
		break;
	case sitalMessageType_BROADCAST:
	case sitalMessageType_BROADCAST_MODE_NO_DATA:
	case sitalMessageType_BROADCAST_MODE_DATA:
		wOverallMessageWordsCount += 1U;
		wGapsCount = 0U;
		break;
	default:
		return sitalReturnCode_INVALID_MESSAGE_TYPE;
	}

	///	Use given device's response timeout in order to evaluate the estimated transmission time of given message.
	U16BIT wResponseTime; // The response time that's configured for given device.
	wResponseTime = 0U;
	S16BIT swResult; // Result of operation or function call.
	swResult = device_Register_GetImage (swDevice, sitalRegisterAddress_CONFIGURATION_5, sitalConfigurationRegister5_RESPONSE_TIMEOUT_MASK, &wResponseTime);

	switch (wResponseTime)
	{
	case sitalConfigurationRegister5_RESPONSE_TIMEOUT_18US:
		wResponseTime = 19U;
		break;
	case sitalConfigurationRegister5_RESPONSE_TIMEOUT_22US:
		wResponseTime = 22U;
		break;
	case sitalConfigurationRegister5_RESPONSE_TIMEOUT_50US:
		wResponseTime = 50U;
		break;
	case sitalConfigurationRegister5_RESPONSE_TIMEOUT_130US:
		wResponseTime = 130U;
		break;
	default:
		// Irrelevant: All possible cases were already handled.
		break;
	}

	U16BIT wTxTime; // The estimated transmission time (in us) of given message.
	wTxTime = 0U;
	wTxTime = ((U16BIT)((wOverallMessageWordsCount * 20U) + (wGapsCount * wResponseTime) + wpMessageBuffer[3]));

	/// Set analyzed message information within pointed variables.
	if (NULL != wpType)
	{
		(*wpType) = wType;
	}

	if (((U16BIT*)NULL) != wpDataWordsCount)
	{
		(*wpDataWordsCount) = wDataWordsCount;
	}

	if (((U16BIT*)NULL) != wpTxTime)
	{
		(*wpTxTime) = wTxTime;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Record the regular messages and the low and high priority asynchronous messages that were just transmitted as part of given minor frame ID of given BC device in its host buffer.
///
/// Note:
/// - This function assumes that given device ID is legal.
/// - This function assumes that given device has already been initialized as BC.
/// - This function assumes that given frame ID is legal.
/// - This function assumes that given frame has already been created.
/// - This function assumes that given frame is a minor frame.
/// - This function assumes that a host buffer is assigned with given device.
/// - An actually transmitted message is recorded in the host buffer only if there's free space in it.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swFrameId (in)	A unique ID designating a frame (0-(sitalBcCounter_FRAMES-1))
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT bc_HostBuffer_RecordTransmittedMinorFrame (S16BIT swDevice, S16BIT swFrameId)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.

	/// Loop over all the commands included in given frame:
	///		If the current command is a message-transmitter command:
	///			If the host buffer isn't full:
	///				Record in the host buffer the message that was assumably transmitted by current command.
	///				If succeeded to record in the host buffer the message that was assumably transmitted by current command:
	///					Cyclically update the offset where to record the next message in the host buffer of given device.
	///					Update the count of messages for the host buffer of given device.
	///					If configured to collect operational statistics for given device:
	///						Update host buffer fullness statistics for the host buffer given device.
	///			Else:
	///				Increment the count of lost messages.
	///				Purge the message that was assumably transmitted by current command.
	// Note: With all message-transmitter commands, the first parameter is the ID of the transmitted message.
	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	HostFrameStructure* hfspFrame; // A pointer to a host frame structure.
	hfspFrame = (HostFrameStructure*)&(dsspDeviceState->bsBcState.hfsaFrame[swFrameId]);
	S16BIT* wpCommandId; // A pointer to a command ID.
	wpCommandId = hfspFrame->swaCommandId;
	HostCommandStructure* hcspCommand; // A pointer to a host command structure.
	S16BIT swMessageId; // A unique ID designating a message (0-(sitalBcCounter_MESSAGES-1)).
	HostMessageStructure* hmspMessage; // A pointer to a host message structure.
	HostBufferStructure* hbspHostBuffer; // A host buffer structure.
	hbspHostBuffer = (HostBufferStructure*)&(dsspDeviceState->bsBcState.hbsHostBuffer);
	U16BIT waBuffer[sitalBcMaximum_MESSAGE_SIZE]; // A temporary buffer to store a message in its raw state within.
	S16BIT swResult; // Result of operation or function call.
	for (U16BIT iCommandIndex=0; iCommandIndex<hfspFrame->wCommandCount; iCommandIndex++, wpCommandId++)
	{
		hcspCommand = (HostCommandStructure*)&(dsspDeviceState->bsBcState.hcsaCommand[*wpCommandId]);
		if ( (sitalOpcode_TIME_CONDITIONED_MESSAGE_TX == hcspCommand->wOpcode) || (sitalOpcode_EXECUTE_MESSAGE == hcspCommand->wOpcode) || (sitalOpcode_EXECUTE_AND_FLIP == hcspCommand->wOpcode) )
		{
			swMessageId = hcspCommand->dwParameter1;
			hmspMessage = (HostMessageStructure*)&(dsspDeviceState->bsBcState.hmsaMessage[swMessageId]);

			if ((hbspHostBuffer->dwOffsetOfNextMessageToWrite != hbspHostBuffer->dwOffsetOfNextMessageToRead) || (((U32BIT)0U) == hbspHostBuffer->dwMessageCount))
			{
				swResult = bc_Message_GetByIdRaw (swDevice, swMessageId, (hbspHostBuffer->waBuffer + hbspHostBuffer->dwOffsetOfNextMessageToWrite), TRUE);
				if (1 == swResult)
				{
					hbspHostBuffer->dwOffsetOfNextMessageToWrite += sitalBcMaximum_MESSAGE_SIZE;
					hbspHostBuffer->dwOffsetOfNextMessageToWrite = ( (hbspHostBuffer->dwHostBufferSize == hbspHostBuffer->dwOffsetOfNextMessageToWrite) ? 0U : hbspHostBuffer->dwOffsetOfNextMessageToWrite );

					hbspHostBuffer->dwMessageCount = ( (((hbspHostBuffer->dwOffsetOfNextMessageToRead > hbspHostBuffer->dwOffsetOfNextMessageToWrite) ? hbspHostBuffer->dwHostBufferSize : 0U) + hbspHostBuffer->dwOffsetOfNextMessageToWrite - hbspHostBuffer->dwOffsetOfNextMessageToRead) / sitalBcMaximum_MESSAGE_SIZE );

					if (TRUE == dsspDeviceState->bIsOperationalStatisticsCollected)
					{
						hbspHostBuffer->wFullnessPercentage = (U16BIT)( (double)100.0 * (double)(((hbspHostBuffer->dwOffsetOfNextMessageToRead > hbspHostBuffer->dwOffsetOfNextMessageToWrite) ? hbspHostBuffer->dwHostBufferSize : 0U) + hbspHostBuffer->dwOffsetOfNextMessageToWrite - hbspHostBuffer->dwOffsetOfNextMessageToRead) / ((double)(hbspHostBuffer->dwHostBufferSize)) );
						hbspHostBuffer->wMaximumFullnessPercentage = ( (hbspHostBuffer->wMaximumFullnessPercentage < hbspHostBuffer->wFullnessPercentage) ? hbspHostBuffer->wFullnessPercentage : hbspHostBuffer->wMaximumFullnessPercentage );
					}
				}
			}
			else
			{
				hbspHostBuffer->dwLostMessageCount++;
				swResult = bc_Message_GetByIdRaw (swDevice, swMessageId, waBuffer, TRUE);
			}
		}
	}

	/// If low or high priority asynchronous messaging is supported with given device:
	///		Loop over all the currently defined messages of given device:
	///			If the current message is an asynchronous message that was already transmitted:
	///				If the host buffer isn't full:
	///					Record in the host buffer the message that was assumably transmitted by current command.
	///					If succeeded to record in the host buffer the message that was assumably transmitted by current command:
	///						Cyclically update the offset where to record the next message in the host buffer of given device.
	///						Update the count of messages for the host buffer of given device.
	///						If configured to collect operational statistics for given device:
	///							Update host buffer fullness statistics for the host buffer given device.
	///				Else:
	///					Increment the count of lost messages.
	///					Purge the message that was assumably transmitted by current command.
	BOOLEAN bIsLowPriorityAsynchronousMessagingSupported; // A flag that says whether low priority asynchronous messaging supported.
	bIsLowPriorityAsynchronousMessagingSupported = (BOOLEAN)( (sitalBcSetupOption_ASYNCHRONOUS_LOW_PRIORITY_MODE == (sitalBcSetupOption_ASYNCHRONOUS_LOW_PRIORITY_MODE & dsspDeviceState->bsBcState.dwOptions)) ? TRUE : FALSE );
	BOOLEAN bIsHighPriorityAsynchronousMessagingSupported; // A flag that says whether high priority asynchronous messaging supported.
	bIsHighPriorityAsynchronousMessagingSupported = (BOOLEAN)( (sitalBcSetupOption_ASYNCHRONOUS_HIGH_PRIORITY_MODE == (sitalBcSetupOption_ASYNCHRONOUS_HIGH_PRIORITY_MODE & dsspDeviceState->bsBcState.dwOptions)) ? TRUE : FALSE );
	if (bIsLowPriorityAsynchronousMessagingSupported || bIsHighPriorityAsynchronousMessagingSupported)
	{
		hmspMessage = (HostMessageStructure*)dsspDeviceState->bsBcState.hmsaMessage;
		for (U32BIT iMessageIndex=0; iMessageIndex<sitalBcCounter_MESSAGES; iMessageIndex++, hmspMessage++)
		{
#ifndef stld1553Library_SINGLE_USER_EXISTS
			// The execution of the following code must be synchronized in order to avoid its execution by a second caller thread before the first caller had a chance to set flag hmspMessage->bIsAnAlreadyRecordedAsynchronousMessage to TRUE.
			if (((S32BIT)0U) !=+ ((S32BIT)(((InterProcessSemaphore*)s_ipspSemaphore)->Catch (1U))))
			{
				return sitalReturnCode_SYNCHRONIZATION_FAIL;
			}
#endif // stld1553Library_SINGLE_USER_EXISTS

			if ((TRUE == hmspMessage->bIsFreeForUse) && (TRUE == hmspMessage->bIsAsynchronousMessage) && (TRUE == hmspMessage->bIsAnAlreadyTransmittedAsynchronousMessage) && (FALSE == hmspMessage->bIsAnAlreadyRecordedAsynchronousMessage))
			{
				swMessageId = ((S16BIT)(hmspMessage->wId));
				if ((hbspHostBuffer->dwOffsetOfNextMessageToWrite != hbspHostBuffer->dwOffsetOfNextMessageToRead) || (0U == hbspHostBuffer->dwMessageCount))
				{
					swResult = bc_Message_GetByIdRaw (swDevice, swMessageId, (hbspHostBuffer->waBuffer + hbspHostBuffer->dwOffsetOfNextMessageToWrite), TRUE);
					if (1 == swResult)
					{
						hbspHostBuffer->dwOffsetOfNextMessageToWrite += sitalBcMaximum_MESSAGE_SIZE;
						hbspHostBuffer->dwOffsetOfNextMessageToWrite = ( (hbspHostBuffer->dwHostBufferSize == hbspHostBuffer->dwOffsetOfNextMessageToWrite) ? 0 : hbspHostBuffer->dwOffsetOfNextMessageToWrite );

						hbspHostBuffer->dwMessageCount = ( (((hbspHostBuffer->dwOffsetOfNextMessageToRead > hbspHostBuffer->dwOffsetOfNextMessageToWrite) ? hbspHostBuffer->dwHostBufferSize : 0U) + hbspHostBuffer->dwOffsetOfNextMessageToWrite - hbspHostBuffer->dwOffsetOfNextMessageToRead) / sitalBcMaximum_MESSAGE_SIZE );

						if (TRUE == dsspDeviceState->bIsOperationalStatisticsCollected)
						{
							hbspHostBuffer->wFullnessPercentage = (U16BIT)( (double)100.0 * (double)(((hbspHostBuffer->dwOffsetOfNextMessageToRead > hbspHostBuffer->dwOffsetOfNextMessageToWrite) ? hbspHostBuffer->dwHostBufferSize : 0U) + hbspHostBuffer->dwOffsetOfNextMessageToWrite - hbspHostBuffer->dwOffsetOfNextMessageToRead) / ((double)(hbspHostBuffer->dwHostBufferSize)) );
							hbspHostBuffer->wMaximumFullnessPercentage = ( (hbspHostBuffer->wMaximumFullnessPercentage < hbspHostBuffer->wFullnessPercentage) ? hbspHostBuffer->wFullnessPercentage : hbspHostBuffer->wMaximumFullnessPercentage );
						}
					}
				}
				else
				{
					hbspHostBuffer->dwLostMessageCount++;
					swResult = bc_Message_GetByIdRaw (swDevice, swMessageId, waBuffer, TRUE);
				}
				hmspMessage->bIsAnAlreadyRecordedAsynchronousMessage = TRUE;
			}

#ifndef stld1553Library_SINGLE_USER_EXISTS
			if (((S32BIT)0U) != (S32BIT)((InterProcessSemaphore*)s_ipspSemaphore)->Release ())
			{
				return sitalReturnCode_SYNCHRONIZATION_FAIL;
			}
#endif // stld1553Library_SINGLE_USER_EXISTS
		}
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Initialize given device as a RT in accordance with given initialization options.
///
/// Note:
/// - This function assumes that given device ID is legal.
/// - This function assumes that given device is now being initialized as either a RT or a RT&MT.
/// - This function assumes that given device has already been opened, its memory zeroed, its memory map initialized and cleared, and is now at state READY.
/// - This function assumes that given initialization parameters are legal.
/// - This function illegalizes messages for all address type, direction, subaddress, and word-count-or-mode-code combinations.
///   To legalize a specific combination, either of the following functions may be used, as appropriate: sitalRt_DataBlock_MapToSubaddress, sitalRt_MessageLegality_Enable.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wCommandStackSize (in)	The desired size (in words) of the command stack (sitalRtCommandStackSize_*)
/// @param dwOptions (in)	Initialization options (An or-ed combination of sitalRtSetupOption_*, not including b1553a options)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT rt_Initialize (S16BIT swDevice, U16BIT wCommandStackSize, U32BIT dwOptions)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.

	/// Calculate the size (in words) and the alignment desired for the command stack.
	static const U16BIT s_uiaRtCommandStackAlignment[] // Array of RT command stack alignment in device memory (in words) per command stack size (in words).
						= { 8U /* = log2(256) */, 9U /* = log2(512) */, 10U /* = log2(1024) */, 11U /* = log2(2048) */ };
	U16BIT uiCommandStackSizeIndex; // An index to the arrays of RT command stack constants.
	U16BIT wActualCommandStackSize; // The size (in words) of the command stack.
	switch (wCommandStackSize)
	{
	case sitalRtCommandStackSize_256: wActualCommandStackSize = 256U; uiCommandStackSizeIndex = 0U; break;
	case sitalRtCommandStackSize_512: wActualCommandStackSize = 512U; uiCommandStackSizeIndex = 1U; break;
	case sitalRtCommandStackSize_1024: wActualCommandStackSize = 1024U; uiCommandStackSizeIndex = 2U; break;
	case sitalRtCommandStackSize_2048: wActualCommandStackSize = 2048U; uiCommandStackSizeIndex = 3U; break;
	default: wActualCommandStackSize = 0U; uiCommandStackSizeIndex = 0U; break; // Irrelevant: All possible cases were already handled.
	}
	U16BIT uiCommandStackAlignment; // The RT command stack alignment in device memory (in words) that suits given command stack size (in words).
	uiCommandStackAlignment = s_uiaRtCommandStackAlignment[uiCommandStackSizeIndex];

	/// Allocate a suitable device memory region for the command stack.
	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	U32BIT dwAllocationSize; // The size (in words) of the device memory allocation.
	dwAllocationSize = wActualCommandStackSize;
	BOOLEAN bIsAllocationSuccessfullyAccomplished; // A flag that says whether the allocation actually succeeded.
	U32BIT dwAllocationBaseAddress; // The address in device memory where a suitable segment of memory has been allocated for the newly created object.
	S16BIT swResult; // Result of operation or function call.
	swResult = Device_Memory_TopSection_AllocateContinuity (&(dsspDeviceState->hdmmsDeviceMemoryMap), bcAddressMap_FREE_MEMORY, (dsspDeviceState->dcsDeviceCapabilities.dwRamSize - 1U), &dwAllocationSize, uiCommandStackAlignment, &bIsAllocationSuccessfullyAccomplished, &dwAllocationBaseAddress);
	if ( (sitalReturnCode_SUCCESS != swResult) || (FALSE == bIsAllocationSuccessfullyAccomplished) )
	{
		return sitalReturnCode_ALLOCATION_FAIL;
	}

	/// Initialize the stack state.
	dsspDeviceState->rms.rsRtState.rsssStackState.dwCommandStackBaseAddress = dwAllocationBaseAddress;
	dsspDeviceState->rms.rsRtState.rsssStackState.dwCommandStackBorderAddress = (dwAllocationBaseAddress + wActualCommandStackSize);
	dsspDeviceState->rms.rsRtState.rsssStackState.wCommandStackSize = wActualCommandStackSize;
	dsspDeviceState->rms.rsRtState.rsssStackState.dwAddressOfMessageToRead = 0U;
	dsspDeviceState->rms.rsRtState.rsssStackState.dwAddressOfMessageToWrite = 0U;
	dsspDeviceState->rms.rsRtState.rsssStackState.dwLostMessageCount = 0U;
	dsspDeviceState->rms.rsRtState.rsssStackState.wFullnessPercentage = 0U;
	dsspDeviceState->rms.rsRtState.rsssStackState.wMaximumFullnessPercentage = 0U;

	/// Initialize ISQ state.
	dsspDeviceState->hisqssIsqState.wIndexOfNextReadIsqEntry = 0U;
	dsspDeviceState->hisqssIsqState.wLostIsqEntryCount = 0U;
	dsspDeviceState->hisqssIsqState.bIsIsqEnabled = FALSE;

	/// Initialize RT state.
	dsspDeviceState->rms.rsRtState.dwOptions = dwOptions;
	dsspDeviceState->rms.rsRtState.bIsHandlingTheDefaultDataBlock = FALSE;
	dsspDeviceState->rms.rsRtState.bIsCommonCircularDataBlockUsed = FALSE;
	dsspDeviceState->rms.rsRtState.bIsAlternateStatusMode = FALSE;

	/// Initialize the host buffer structure.
	memset (&(dsspDeviceState->rms.rsRtState.hbsHostBuffer), 0, sizeof(HostBufferStructure));

	/// Initialize any relevant object definitions.
	dsspDeviceState->rms.rsRtState.hdbsDefaultDataBlock.bIsFreeForUse = TRUE;
	for (U32BIT iDataBlockIndex=0; iDataBlockIndex<sitalRtCounter_DATA_BLOCKS; iDataBlockIndex++)
	{
		dsspDeviceState->rms.rsRtState.hdbsaDataBlock[iDataBlockIndex].bIsFreeForUse = TRUE;
	}

	/// Initialize all circular data block information structures.
	CircularDataBlockInformationStructure* cdbispSubaddressCommonCircularDataBlock; // A pointer to a circular data block information structure.
	cdbispSubaddressCommonCircularDataBlock = dsspDeviceState->rms.rsRtState.cdbisaSubaddressRxCommonCircularDataBlock;
	for (U32BIT iRxSubaddressIndex=0; iRxSubaddressIndex<sitalIeee1553_SUBADDRESS_COUNT; iRxSubaddressIndex++, cdbispSubaddressCommonCircularDataBlock++)
	{
		cdbispSubaddressCommonCircularDataBlock->bIsEnabled = FALSE;
	}
	cdbispSubaddressCommonCircularDataBlock = dsspDeviceState->rms.rsRtState.cdbisaSubaddressTxCommonCircularDataBlock;
	for (U32BIT iTxSubaddressIndex=0; iTxSubaddressIndex<sitalIeee1553_SUBADDRESS_COUNT; iTxSubaddressIndex++, cdbispSubaddressCommonCircularDataBlock++)
	{
		cdbispSubaddressCommonCircularDataBlock->bIsEnabled = FALSE;
	}

	/// Locate the ISQ at its predetermined address.
	swResult = device_Register_UpdateImage (swDevice, sitalRegisterAddress_RT_MT_INTERRUPT_STATUS_QUEUE_POINTER, registerMask_ALL_BITS_ON, rtAddressMap_ISQ);

	/// Illegalize messages for all address type, direction, subaddress, and word-count-or-mode-code combinations.
	swResult = sitalRt_MessageLegality_Disable (swDevice, sitalRtAddressType_BOTH, sitalMessageDirection_BOTH, sitalRtSubaddress_ALL, 0xFFFFFFFF);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Flag that the default data block is now created.
	/// Create the default data block.
	/// Lower the flag that says that the default data block is now created.
	dsspDeviceState->rms.rsRtState.bIsHandlingTheDefaultDataBlock = TRUE;
	swResult = sitalRt_DataBlock_Create (swDevice, 0 /* Unused here */, sitalRtDataBlockType_SINGLE_32, (U16BIT*)NULL, 0U);
	dsspDeviceState->rms.rsRtState.bIsHandlingTheDefaultDataBlock = FALSE;
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return sitalReturnCode_ALLOCATION_FAIL;
	}

	/// Loop over all subaddresses:
	///		Flag that the default data block is now created.
	///		Update the lookup table so that the default data block will be used by current subaddress.
	///		Lower the flag that says that the default data block is now created.
	for (U16BIT wSubaddress=0; wSubaddress<ieee1553_SUBADDRESS_BORDER; wSubaddress++)
	{
		dsspDeviceState->rms.rsRtState.bIsHandlingTheDefaultDataBlock = TRUE;
		swResult = sitalRt_DataBlock_MapToSubaddress (swDevice, 0 /* Unused */, wSubaddress, sitalRtMessageType_ALL, 0U, FALSE);
		dsspDeviceState->rms.rsRtState.bIsHandlingTheDefaultDataBlock = FALSE;
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
	}

	/// Clear all the status bits.
	swResult = sitalRt_ResponseStatusBits_Unset (swDevice, (sitalRtStatusWordBit_DBCA | sitalRtStatusWordBit_BUSY | sitalRtStatusWordBit_SERVICE_REQUSET | sitalRtStatusWordBit_SUBSYSTEM_FLAG | sitalRtStatusWordBit_RT_FLAG));
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Clear relevant options in the image of the RT registers.
	swResult = device_Register_UpdateImage (swDevice, sitalRegisterAddress_CONFIGURATION_2, (sitalConfigurationRegister2_RT_CLEAR_SERVICE_REQUSET | sitalConfigurationRegister2_RT_LOAD_TIME_TAG_ON_SYNCHRONIZE | sitalConfigurationRegister2_RT_CLEAR_TIME_TAG_ON_SYNCHRONIZE | sitalConfigurationRegister2_RT_OVERWRITE_INVALID_DATA), registerMask_ALL_BITS_OFF);
	swResult = device_Register_UpdateImage (swDevice, sitalRegisterAddress_CONFIGURATION_3, (sitalConfigurationRegister3_RT_MT_1553A_MODE_CODES | sitalConfigurationRegister3_RT_FAIL_FLAG_WRAP | sitalConfigurationRegister3_RT_BUSY_RX_TRANSFER_DISABLE | sitalConfigurationRegister3_RT_ILLEGAL_RX_TRANSFER_DISABLE | sitalConfigurationRegister3_RT_ALTERNATE_STATUS_WORD | sitalConfigurationRegister3_RT_OVERRIDE_MODE_CODE_ERROR), registerMask_ALL_BITS_OFF);
	swResult = device_Register_UpdateImage (swDevice, sitalRegisterAddress_CONFIGURATION_4, sitalConfigurationRegister4_RT_MODE_CODE_OVERRIDE_BUSY, registerMask_ALL_BITS_OFF);
	swResult = device_Register_UpdateImage (swDevice, sitalRegisterAddress_CONFIGURATION_5, sitalConfigurationRegister5_RT_MT_BROADCAST_DISABLE, registerMask_ALL_BITS_OFF);

	/// Configure the RT according to given options.
	if (sitalRtSetupOption_CLEAR_SERVICE_REQUEST == (sitalRtSetupOption_CLEAR_SERVICE_REQUEST & dwOptions))
	{
		swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_2, (U16BIT)sitalConfigurationRegister2_RT_CLEAR_SERVICE_REQUSET, (U16BIT)registerMask_ALL_BITS_ON);
	}
	if (sitalRtSetupOption_LOAD_TIME_TAG == (sitalRtSetupOption_LOAD_TIME_TAG & dwOptions))
	{
		swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_2, (U16BIT)sitalConfigurationRegister2_RT_LOAD_TIME_TAG_ON_SYNCHRONIZE, (U16BIT)registerMask_ALL_BITS_ON);
	}
	if (sitalRtSetupOption_CLEAR_TIME_TAG == (sitalRtSetupOption_CLEAR_TIME_TAG & dwOptions))
	{
		swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_2, (U16BIT)sitalConfigurationRegister2_RT_CLEAR_TIME_TAG_ON_SYNCHRONIZE, (U16BIT)registerMask_ALL_BITS_ON);
	}
	if (sitalRtSetupOption_OVERWRITE_DATA == (sitalRtSetupOption_OVERWRITE_DATA & dwOptions))
	{
		swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_2, (U16BIT)sitalConfigurationRegister2_RT_OVERWRITE_INVALID_DATA, (U16BIT)registerMask_ALL_BITS_ON);
	}
	if (sitalRtSetupOption_1553A_MODE_CODES == (sitalRtSetupOption_1553A_MODE_CODES & dwOptions))
	{
		swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_3, (U16BIT)sitalConfigurationRegister3_RT_MT_1553A_MODE_CODES, (U16BIT)registerMask_ALL_BITS_ON);
		return sitalReturnCode_INVALID_PARAMETER;
	}
	if (sitalRtSetupOption_SET_RT_FLAG == (sitalRtSetupOption_SET_RT_FLAG & dwOptions))
	{
		swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_3, (U16BIT)sitalConfigurationRegister3_RT_FAIL_FLAG_WRAP, (U16BIT)registerMask_ALL_BITS_ON);
		return sitalReturnCode_INVALID_PARAMETER;
	}
	if (sitalRtSetupOption_BUSY_RX_DISABLE == (sitalRtSetupOption_BUSY_RX_DISABLE & dwOptions))
	{
		swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_3, (U16BIT)sitalConfigurationRegister3_RT_BUSY_RX_TRANSFER_DISABLE, (U16BIT)registerMask_ALL_BITS_ON);
	}
	if (sitalRtSetupOption_ILL_RX_DISABLE == (sitalRtSetupOption_ILL_RX_DISABLE & dwOptions))
	{
		swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_3, (U16BIT)sitalConfigurationRegister3_RT_ILLEGAL_RX_TRANSFER_DISABLE, (U16BIT)registerMask_ALL_BITS_ON);
	}
	if (sitalRtSetupOption_ALTERNATE_STATUS == (sitalRtSetupOption_ALTERNATE_STATUS & dwOptions))
	{
		swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_3, (U16BIT)sitalConfigurationRegister3_RT_ALTERNATE_STATUS_WORD, (U16BIT)registerMask_ALL_BITS_ON);
		dsspDeviceState->rms.rsRtState.bIsAlternateStatusMode = TRUE;
	}
	if (sitalRtSetupOption_OVERRIDE_MODE_BIT == (sitalRtSetupOption_OVERRIDE_MODE_BIT & dwOptions))
	{
		swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_3, (U16BIT)sitalConfigurationRegister3_RT_OVERRIDE_MODE_CODE_ERROR, (U16BIT)registerMask_ALL_BITS_ON);
	}
	if (sitalRtSetupOption_MODE_COMMAND_OVERRIDE_BUSY == (sitalRtSetupOption_MODE_COMMAND_OVERRIDE_BUSY & dwOptions))
	{
		swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_4, (U16BIT)sitalConfigurationRegister4_RT_MODE_CODE_OVERRIDE_BUSY, (U16BIT)registerMask_ALL_BITS_ON);
	}
	if (sitalRtSetupOption_BROADCAST_DISABLE == (sitalRtSetupOption_BROADCAST_DISABLE & dwOptions))
	{
		swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_5, (U16BIT)sitalConfigurationRegister5_RT_MT_BROADCAST_DISABLE, (U16BIT)registerMask_ALL_BITS_ON);
	}

	/// Configure given RT device with given size of command stack.
	swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_3, (U16BIT)sitalConfigurationRegister3_BC_RT_COMMAND_STACK_SIZE, wCommandStackSize);

	/// Configure given RT device to have internal address source.
	swResult = sitalRt_AddressSource_Set (swDevice, (U16BIT)sitalRtAddressSource_INTERNAL);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Virtually configure given RT device to be able to start receiving messages.
///
/// Note:
/// - This function assumes that given device ID is legal.
/// - This function assumes that given device has already been initialized as either RT or RT&MT.
/// - This function assumes that given device is now at state READY.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT rt_Start (S16BIT swDevice)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.

	/// Turn both this library and the RT device to point the beginning of the command stack.
	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	dsspDeviceState->rms.rsRtState.rsssStackState.dwAddressOfMessageToRead = dsspDeviceState->rms.rsRtState.rsssStackState.dwCommandStackBaseAddress;
	U16BIT wIoContents; // The variable into which the contents of a device word is read, or the variable whose contents are written to device.
	wIoContents = ((U16BIT)(dsspDeviceState->rms.rsRtState.rsssStackState.dwCommandStackBaseAddress));
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, rtAddressMap_COMMAND_STACK_POINTER, sitalDeviceMemorySection_Ram, 1U, &wIoContents);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Reset the block status words of all the entries in the RT command stack.
	// Or simply zero the whole of the RT stack.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Zero, dsspDeviceState->rms.rsRtState.rsssStackState.dwCommandStackBaseAddress, sitalDeviceMemorySection_Ram, dsspDeviceState->rms.rsRtState.rsssStackState.wCommandStackSize, ((U16BIT*)NULL));
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Reset the host buffer information.
	dsspDeviceState->rms.rsRtState.hbsHostBuffer.dwOffsetOfNextMessageToRead = 0U;
	dsspDeviceState->rms.rsRtState.hbsHostBuffer.dwOffsetOfNextMessageToWrite = 0U;
	dsspDeviceState->rms.rsRtState.hbsHostBuffer.wFullnessPercentage = 0U;
	dsspDeviceState->rms.rsRtState.hbsHostBuffer.wMaximumFullnessPercentage = 0U;

	/// If a common circular data block is used:
	///		Set the global circular data pointer to point the common circular data block.
	///		Configure the device to enable global circular data block.
	if (TRUE == dsspDeviceState->rms.rsRtState.bIsCommonCircularDataBlockUsed)
	{
		HostDataBlockStructure* hdbspDataBlock; // A pointer to a host data block structure.
		hdbspDataBlock = &(dsspDeviceState->rms.rsRtState.hdbsaDataBlock[dsspDeviceState->rms.rsRtState.wCommonCircularDataBlockId]);

		// Function sitalRt_DataBlock_Create sets the common data block ID to specify an already defined data block.
		// Therefore, the following error condition must never be triggered.
		Assert_NonOsDependent(FALSE == hdbspDataBlock->bIsFreeForUse);

		//U16BIT wIoContents; // The variable into which the contents of a device word is read, or the variable whose contents are written to device.
		wIoContents = ((U16BIT)(hdbspDataBlock->dwAddress));
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, rtAddressMap_GLOBAL_CIRCULAR_DATA_POINTER, sitalDeviceMemorySection_Ram, 1U, &wIoContents);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}

		swResult = device_Register_UpdateImage (swDevice, sitalRegisterAddress_CONFIGURATION_6, sitalConfigurationRegister6_RT_GLOBAL_CIRCULAR_BUFFER_MASK, sitalConfigurationRegister6_RT_GLOBAL_CIRCULAR_BUFFER_ENABLE);
	}

	/// If should explicitly reset the time tag:
	///		Reset the time tag.
	U16BIT wRegisterValue; // The current value of a target register, or the value to set for a target register.
	if (sitalModeVariant_NO_TIME_TAG_RESET != (sitalModeVariant_NO_TIME_TAG_RESET & dsspDeviceState->wModeVariants))
	{
		wRegisterValue = sitalStartResetRegister_RESET;
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_START_OR_RESET, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
	}

	/// Turn given device into enhanced mode.
	wRegisterValue = sitalConfigurationRegister3_ENHANCED_MODE;
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, sitalRegisterAddress_CONFIGURATION_3, sitalDeviceMemorySection_Registers, registerMask_ALL_BITS_ON, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Set the function field of configuration register #1 to an invalid function in order to force the initialization of all the registers before the RT goes online.
	swResult = device_Register_UpdateImage (swDevice, sitalRegisterAddress_CONFIGURATION_1, sitalConfigurationRegister1_FUNCTION_MASK, registerMask_ALL_BITS_OFF);

	/// Select the configured RT Address Source.
	swResult =	device_Register_GetImage (swDevice, sitalRegisterAddress_CONFIGURATION_6, sitalConfigurationRegister6_RT_ADDRESS_SOURCE, &wRegisterValue);
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, sitalRegisterAddress_CONFIGURATION_6, sitalDeviceMemorySection_Registers, sitalConfigurationRegister6_RT_ADDRESS_SOURCE, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Get lookup information about given data block of given RT device.
///
/// Note:
/// - This function assumes that given hdbspDataBlock isn't NULL.
///
/// @param hdbspDataBlock (in)	A pointer to the examined data block
/// @param wpMappedSubaddress (out)	A pointer to a variable in which the mapped subaddress is returned, or NULL if no need to return it
/// @param wpLookupAddress (out)	A pointer to a variable in which the address in device memory of the mapped subaddress' lookup entry is returned, or NULL if no need to return it
/// @param wpControlWordAddress (out)	A pointer to a variable in which the address in device memory of the mapped subaddress' control word lookup entry is returned, or NULL if no need to return it
/// @return TRUE	Given data block is mapped to some subaddress
/// @return FALSE	Given data block is not mapped to any subaddress
/// </summary>
BOOLEAN rt_DataBlock_GetSubaddressLookupInformation (	HostDataBlockStructure* hdbspDataBlock,
														U16BIT* wpMappedSubaddress,
														U32BIT* dwpLookupAddress,
														U32BIT* dwpControlWordAddress)
{
	/// @pseudocode

	/// If given data block is mapped to some subaddress:
	///		Get this subaddress.
	///		Calculate the address of the lookup table entry that's dedicated to this subaddress.
	///		Calculate the address of the lookup table entry that's dedicated to this subaddress' control word.
	///		Return TRUE.
	/// Else:
	///		Return FALSE.
	U32BIT dwSubaddressMapping; // The subaddress mapping mask where the subaddress that's mapped with given data block is signed.
	U32BIT dwLookupAddress; // The address in device memory of the mapped subaddress' lookup entry.
	if (0U != hdbspDataBlock->dwRxSubaddressMapping)
	{
		dwSubaddressMapping = hdbspDataBlock->dwRxSubaddressMapping;
		dwLookupAddress = rtAddressMap_SUBADDRESS_LOOKUP_TABLE_RX;
	}
	else
	if (0U != hdbspDataBlock->dwTxSubaddressMapping)
	{
		dwSubaddressMapping = hdbspDataBlock->dwTxSubaddressMapping;
		dwLookupAddress = rtAddressMap_SUBADDRESS_LOOKUP_TABLE_TX;
	}
	else
	if (0U != hdbspDataBlock->dwBroadcastSubaddressMapping)
	{
		dwSubaddressMapping = hdbspDataBlock->dwBroadcastSubaddressMapping;
		dwLookupAddress = rtAddressMap_SUBADDRESS_LOOKUP_TABLE_BROADCAST;
	}
	else
	{
		return FALSE;
	}

	U16BIT wMappedSubaddress; // The mapped subaddress.
	wMappedSubaddress = 0U;
	while (0x0001U != dwSubaddressMapping)
	{
		dwSubaddressMapping = (dwSubaddressMapping >> 1U);
		wMappedSubaddress++;
	}

	if (((U16BIT*)NULL) != wpMappedSubaddress)
	{
		(*wpMappedSubaddress) = wMappedSubaddress;
	}

	if (((U32BIT*)NULL) != dwpLookupAddress)
	{
		(*dwpLookupAddress) = (dwLookupAddress + wMappedSubaddress);
	}

	if (((U32BIT*)NULL) != dwpControlWordAddress)
	{
		(*dwpControlWordAddress) = (rtAddressMap_SUBADDRESS_LOOKUP_TABLE_SUBADDRESS_CONTROL_WORDS + wMappedSubaddress);
	}

	return TRUE;
}


/// <summary>
/// Read from given place in the RT stack of given RT device into given buffer the currently available raw message.
/// If so desired, then remove from the stack the message that was read.
///
/// Note:
/// - This function assumes that given device ID is legal.
/// - This function assumes that given device has already been initialized as RT or RT&MT.
/// - This function assumes that given message address is legal.
/// - This function assumes that given pointer to buffer is a non-null legal pointer.
/// - This function assumes that given buffer is at least sitalRtMaximum_MESSAGE_SIZE words long.
/// - The RT device does not promote the stack pointer to point the head of the next message until done with the previous message;
///   Therefore, as long as the library's internal stack pointer is behind the RT stack pointer, there's another sealed stack entry to diagnose.
///   Saying this, if the EOM bit is zero in the block status word in the currently reviewed entry, it indicates that the message did not finish
///   correctly, possibly because of a transceiver problem.
/// - Given buffer is first zeroed, and then filled as follows:
///   - The target RT stack entry is copied into given buffer.
///   - The data stack pointer is replaced with a word whose:
///     - MSByte contains the count of data words for the message that was read.
///     - LSByte contains the type of the message that was read (sitalMessageType_*).
///   - The data words are stored right after the stack entry, that is, starting at offset sitalRtMemoryObjectSize_COMMAND_STACK_ENTRY.
///     In case of a mode code message with data, this data word is returned as the first (actually the single) data word.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wapBuffer (out)	A pointer to a buffer in which the requested raw message is returned
/// @param wpMessageTimeTagRolloverCounter (out)	A pointer to a variable in which the time tag rollover counter related with the returned message is returned, or NULL if no need to return it
/// @param bIsNextMessageRequired (in)	A flag that says whether the next available stack message should be read (or, otherwise, of the last message that was written by the device)
/// @param bIsMessagePurgeRequired (in)	A flag that says whether to delete the returned message after reading it from the stack
/// @return One (1)	The [single] requested message was read and decoded
/// @return Zero (0)	No message available, though no error occurred
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT rt_Message_GetFromStackRaw (	S16BIT swDevice,
									U16BIT* wapBuffer,
									U16BIT* wpMessageTimeTagRolloverCounter,
									BOOLEAN bIsNextMessageRequired,
									BOOLEAN bIsMessagePurgeRequired)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.

	/// Zero given buffer.
	memset (wapBuffer, 0, (sitalRtMaximum_MESSAGE_SIZE << 1U));
	//printf("\n\rstart of sub_function");
	/// If it is the next available message in the stack that's required:
	///		Get the address of the next stack message to read.
	/// Else:
	///		Get the address of the previously recorded stack message.
	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	RtStackStateStructure* rssspTargetStackState; // A pointer to the state structure of the target stack.
	rssspTargetStackState = (RtStackStateStructure*)&(dsspDeviceState->rms.rsRtState.rsssStackState);
	U32BIT dwAddressOfMessageToRead; // The device memory address where the stack message that should be read is recorded.
	if (TRUE == bIsNextMessageRequired)
	{
		if (rssspTargetStackState->dwAddressOfMessageToRead == rssspTargetStackState->dwAddressOfMessageToWrite)
		{

//			printf("\n\r %0x ",rssspTargetStackState->dwAddressOfMessageToRead);
//			printf("\n\r %0x ",rssspTargetStackState->dwAddressOfMessageToWrite);
//			printf("\n\r1.1 error ");
			return 0;
		}

		dwAddressOfMessageToRead = rssspTargetStackState->dwAddressOfMessageToRead;
	}
	else // The required message is the last recorded one, which is the one before the currently/next written one.
	{
		if (rssspTargetStackState->dwCommandStackBaseAddress == rssspTargetStackState->dwAddressOfMessageToWrite)
		{
			dwAddressOfMessageToRead = rssspTargetStackState->dwCommandStackBorderAddress;
		}
		else
		{
			dwAddressOfMessageToRead = rssspTargetStackState->dwAddressOfMessageToWrite;
		}
		dwAddressOfMessageToRead -= sitalRtMemoryObjectSize_COMMAND_STACK_ENTRY;
	}

	/// Read the desired message entry from the target stack.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, dwAddressOfMessageToRead, sitalDeviceMemorySection_Ram, sitalRtMemoryObjectSize_COMMAND_STACK_ENTRY, wapBuffer);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		//printf("\n\r1.2 error ");
		return swResult;
	}

	/// Extricate message qualifiers from the stack entry that was just read.
	U16BIT wBlockStatusWord; // Message block status.
	wBlockStatusWord = wapBuffer[rtCommandStackEntry_OFFSET_OF_BLOCK_STATUS_WORD];
	U16BIT wTimeTag; // Message time tag.
	wTimeTag = wapBuffer[rtCommandStackEntry_OFFSET_OF_TIME_TAG];
	U16BIT wCommand; // Message command.
	wCommand = wapBuffer[rtCommandStackEntry_OFFSET_OF_COMMAND];
	U16BIT wSubaddress; // SubAddress.
	wSubaddress = (((U16BIT)commandWord_SUBADDRESS_OR_MODE & wCommand) >> commandWord_OFFSET_OF_SUBADDRESS_OR_MODE);
	U16BIT wRtAddress; // RT address.
	wRtAddress = (((U16BIT)commandWord_RT_ADDRESS & wCommand) >> commandWord_OFFSET_OF_RT_ADDRESS);
	U16BIT wMessageDirection; // Tx/Rx bit.
	wMessageDirection = (((U16BIT)commandWord_RX_OR_TX & wCommand) >> commandWord_OFFSET_OF_RX_OR_TX);
	U16BIT wWordCount; // Data word count.
	wWordCount = (((U16BIT)commandWord_WORD_COUNT_OR_MODE_CODE & wCommand) >> commandWord_OFFSET_OF_WORD_COUNT_OR_MODE_CODE);
	U16BIT wDataBlockPointerOrModeCodeData; // The device memory address of the message data block, OR, in case of mode code messages with data, the single mode code data word.
	wDataBlockPointerOrModeCodeData = wapBuffer[rtCommandStackEntry_OFFSET_OF_DATA_BLOCK_ADDRESS];

	///	If the transmission of the current message isn't yet completed:
	///		Return no message.
	if (0U == (sitalRtBlockStatusWord_END_OF_MESSAGE & wBlockStatusWord))
	{
		//printf("\n\r1.3 error ");
		return 0;
	}

	/// If given device is a RT&MT device for which a host buffer has been installed:
	///		If a time tag rollover took place since the last message has been recorded:
	///			Increment the time tag rollover counter in the host buffer structure of given device.
	///		Record the current time tag in the host buffer structure of given device.
	///		If the caller requires the time tag rollover counter that is related with the currently recorded message:
	///			Record the current time tag rollover counter as the time tag rollover counter related with the message that is currently recorded in the host buffer of given device.
	if (sitalMode_RT_AND_MT == dsspDeviceState->wMode)
	{
		HostBufferStructure* hbspHostBuffer; // A host buffer structure.
		hbspHostBuffer = (HostBufferStructure*)&(dsspDeviceState->rms.rsRtState.hbsHostBuffer);
		if (0U < hbspHostBuffer->dwHostBufferSize)
		{
			if ((0x0000FFFFU & hbspHostBuffer->dwLastMessageTimeTag) > wTimeTag)
			{
				hbspHostBuffer->dwLastMessageTimeTag = ( hbspHostBuffer->dwLastMessageTimeTag + 0x00010000U );
			}
			hbspHostBuffer->dwLastMessageTimeTag = ( (0xFFFF0000U & hbspHostBuffer->dwLastMessageTimeTag) | wTimeTag );
			if (((U16BIT*)NULL) != wpMessageTimeTagRolloverCounter)
			{
				(*wpMessageTimeTagRolloverCounter) = (U16BIT)( (0xFFFF0000U & hbspHostBuffer->dwLastMessageTimeTag) >> 16U );
			}
		}
	}

	/// Find out the message type and its number of data words.
	U16BIT wMessageType; // Type of message.
	wMessageType = wMessageDirection;
	U16BIT wDataWordCount; // Number of message data words.
	wDataWordCount = 0U;
	if (sital1553_BROADCAST == wRtAddress)
	{
		wMessageType |= messageTypeComponent_BROADCAST;
	}
	if ((sital1553_MODE_CODE1 == wSubaddress) || (sital1553_MODE_CODE2 == wSubaddress))
	{
		wMessageType |= messageTypeComponent_MODE;
		if (commandWord_MODE_WITH_DATA == (commandWord_MODE_WITH_DATA & wWordCount))
		{
			wMessageType |= messageTypeComponent_DATA;
			wDataWordCount++;
		}
	}
	else
	{
		if	(
				(sitalRtBlockStatusWord_RT_TO_RT == (sitalRtBlockStatusWord_RT_TO_RT & wBlockStatusWord))
				||
				(sitalRtBlockStatusWord_RT_TO_RT_COMMAND_ERROR == (sitalRtBlockStatusWord_RT_TO_RT_COMMAND_ERROR & wBlockStatusWord))
				||
				(sitalRtBlockStatusWord_RT_TO_RT_RESPONSE_ERROR == (sitalRtBlockStatusWord_RT_TO_RT_RESPONSE_ERROR & wBlockStatusWord))
			)
		{
			wMessageType |= messageTypeComponent_DATA;
		}

		wDataWordCount += ( (0U == wWordCount) ? 32U : wWordCount );
	}

	///	Analyze the message in order to find its overall word count and its gaps count.
	switch (wMessageType)
	{
	case sitalMessageType_BC_TO_RT:
	case sitalMessageType_RT_TO_BC:
	case sitalMessageType_RT_TO_RT:
	case sitalMessageType_MODE_NO_DATA:
	case sitalMessageType_MODE_DATA_RX:
	case sitalMessageType_MODE_DATA_TX:
	case sitalMessageType_BROADCAST:
	case sitalMessageType_BROADCAST_RT_TO_RT:
	case sitalMessageType_BROADCAST_MODE_NO_DATA:
	case sitalMessageType_BROADCAST_MODE_DATA:
		break;
	default:
		wMessageType = sitalMessageType_INVALID;
	}

	/// If the caller requests to remove the currently read message from the stack:
	///		Clear all stack entries from the one pointed by this library's internal stack pointer to that pointed by given message address (both included).
	///		Set this library's internal stack pointer to point the entry next to given one.
	// With all above operations the possibility of an interim rollover is, of course, taken in account below.
	if (TRUE == bIsMessagePurgeRequired)
	{
		if (dwAddressOfMessageToRead < rssspTargetStackState->dwAddressOfMessageToRead)
		{
			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Zero, rssspTargetStackState->dwAddressOfMessageToRead, sitalDeviceMemorySection_Ram, (dsspDeviceState->rms.rsRtState.rsssStackState.dwCommandStackBorderAddress - dsspDeviceState->rms.rsRtState.rsssStackState.dwAddressOfMessageToRead), ((U16BIT*)NULL));
			if (sitalReturnCode_SUCCESS != swResult)
			{
				//printf("\n\r1.4 error ");
				return swResult;
			}

			rssspTargetStackState->dwAddressOfMessageToRead = rssspTargetStackState->dwCommandStackBaseAddress;
		}

		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Zero, rssspTargetStackState->dwAddressOfMessageToRead, sitalDeviceMemorySection_Ram, ((dwAddressOfMessageToRead + sitalRtMemoryObjectSize_COMMAND_STACK_ENTRY) - dsspDeviceState->rms.rsRtState.rsssStackState.dwAddressOfMessageToRead), ((U16BIT*)NULL));
		if (sitalReturnCode_SUCCESS != swResult)
		{
			//printf("\n\r1.5 error ");
			return swResult;
		}

		rssspTargetStackState->dwAddressOfMessageToRead = (dwAddressOfMessageToRead + sitalRtMemoryObjectSize_COMMAND_STACK_ENTRY);
		if (rssspTargetStackState->dwCommandStackBorderAddress == rssspTargetStackState->dwAddressOfMessageToRead)
		{
			rssspTargetStackState->dwAddressOfMessageToRead = rssspTargetStackState->dwCommandStackBaseAddress;
		}
	}

	/// If the command of the currently read message is a mode command:
	///		If the currently read message contains a data word:
	///			Copy the data word to the data section of given buffer.
	/// Else:
	///		If a global circular buffer is used:
	///			Store the base and border address of the global circular buffer in prepare for the copy operation.
	///			Flag that a circular buffer is now used.
	///		Else:
	///			If Tx command and usage of circular data block is enabled to relevant subaddress for Tx:
	///				Store the base and border address of the pointed private circular buffer in prepare for the copy operation.
	///				Flag that a circular buffer is now used.
	///			Else:
	///				If Rx command and usage of circular data block is enabled to relevant subaddress for Rx:
	///					Store the base and border address of the pointed private circular buffer in prepare for the copy operation.
	///					Flag that a circular buffer is now used.
	///		If a circular data block of any kind is used AND a cyclic wrap occurred:
	///			Copy the rolled over data words from the relevant circular buffer to the data section of given buffer.
	///		Else (either a circular data block when no cyclic wrap occurred OR a regular data block):
	///			Read the pointed data block to the data section of given buffer.
	// Notes:
	// - See the dual-meaning of variable wDataBlockPointerOrModeCodeData explained in the documentation at its definition above.
	// - See the description of the returned buffer in the documentation of this function.
	// - In case of a mode command, the data block pointer actually contains the data word, if any.
	// - With all above operations the possibility of an interim rollover is, of course, taken in account below.
	U16BIT* wpDataWordsSection; // A pointer to the section of given buffer where the data words will be stored.
	wpDataWordsSection = &(wapBuffer[sitalRtMemoryObjectSize_COMMAND_STACK_ENTRY]);
	if (messageTypeComponent_MODE == (messageTypeComponent_MODE & wMessageType))
	{
		(*wpDataWordsSection) = (U16BIT)( (1U == wDataWordCount) ? wDataBlockPointerOrModeCodeData : 0U );
	}
	else
	{
		BOOLEAN bIsCircularBufferUsed; // A flag that says whether some kind of a circular buffer (global or regular) is used with currently read message.
		bIsCircularBufferUsed = FALSE;
		U32BIT dwDataBlockBaseAddress; // The base device memory address of the data block from which data words that should be copied.
		dwDataBlockBaseAddress = 0U; // An assignment that prevents a casual compilation warning.
		U32BIT dwDataBlockBorderAddress; // The border device memory address of the data block from which data words that should be copied.
		dwDataBlockBorderAddress = 0U; // An assignment that prevents a casual compilation warning.
		if (TRUE == dsspDeviceState->rms.rsRtState.bIsCommonCircularDataBlockUsed)
		{
			HostDataBlockStructure* hdbspDataBlock; // A pointer to a host data block structure.
			hdbspDataBlock = (HostDataBlockStructure*)&(dsspDeviceState->rms.rsRtState.hdbsaDataBlock[dsspDeviceState->rms.rsRtState.wCommonCircularDataBlockId]);

			// Function sitalRt_DataBlock_Create sets the common data block ID to specify an already defined data block.
			// Therefore, the following error condition must never be triggered.
			Assert_NonOsDependent(FALSE == hdbspDataBlock->bIsFreeForUse);

			dwDataBlockBaseAddress = hdbspDataBlock->dwAddress;
			dwDataBlockBorderAddress = (hdbspDataBlock->dwAddress + hdbspDataBlock->wActualSize);
			bIsCircularBufferUsed = TRUE;
		}
		else
		if ((commandWord_TX == (commandWord_TX & wCommand)) && (TRUE == dsspDeviceState->rms.rsRtState.cdbisaSubaddressTxCommonCircularDataBlock[wSubaddress].bIsEnabled))
		{
			dwDataBlockBaseAddress = dsspDeviceState->rms.rsRtState.cdbisaSubaddressTxCommonCircularDataBlock[wSubaddress].dwAddress;
			dwDataBlockBorderAddress = (dwDataBlockBaseAddress + dsspDeviceState->rms.rsRtState.cdbisaSubaddressTxCommonCircularDataBlock[wSubaddress].wActualSize);
			bIsCircularBufferUsed = TRUE;
		}
		else
		if ((commandWord_TX != (commandWord_TX & wCommand)) && (TRUE == dsspDeviceState->rms.rsRtState.cdbisaSubaddressRxCommonCircularDataBlock[wSubaddress].bIsEnabled))
		{
			dwDataBlockBaseAddress = dsspDeviceState->rms.rsRtState.cdbisaSubaddressRxCommonCircularDataBlock[wSubaddress].dwAddress;
			dwDataBlockBorderAddress = (dwDataBlockBaseAddress + dsspDeviceState->rms.rsRtState.cdbisaSubaddressRxCommonCircularDataBlock[wSubaddress].wActualSize);
			bIsCircularBufferUsed = TRUE;
		}
		//S16BIT swResult; // Result of operation or function call.
		//swResult = sitalProcess_Log_PrintLine ("#StldDll.Rt.Stack.Message.Get.Circular: unit - %i, used - %c, common_circular - %c, command - %04X, tx - %c, subaddress - %i, subaddress_circular_tx - %c, subaddress_circular_rx - %c\n", swDevice, YES_NO(bIsCircularBufferUsed), YES_NO(dsspDeviceState->rms.rsRtState.bIsCommonCircularDataBlockUsed), wCommand, YES_NO((commandWord_TX & wCommand)), wSubaddress, YES_NO(dsspDeviceState->rms.rsRtState.cdbisaSubaddressTxCommonCircularDataBlock[wSubaddress].bIsEnabled), YES_NO(dsspDeviceState->rms.rsRtState.cdbisaSubaddressRxCommonCircularDataBlock[wSubaddress].bIsEnabled));

		if ( (TRUE == bIsCircularBufferUsed) && (((U32BIT)wDataBlockPointerOrModeCodeData + wDataWordCount) > dwDataBlockBorderAddress) )
		{
			U16BIT wSizeOfPreRolloverChunk; // The size (in words) of the chunk of data words of the currently read message that are stored at the end of the global circular data block.
			wSizeOfPreRolloverChunk = (U16BIT)(dwDataBlockBorderAddress - (U32BIT)wDataBlockPointerOrModeCodeData);
			U16BIT wSizeOfPostRolloverChunk; // The size (in words) of the chunk of data words of the currently read message that are stored at the beginning of the global circular data block.
			wSizeOfPostRolloverChunk = (wDataWordCount - wSizeOfPreRolloverChunk);

			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, wDataBlockPointerOrModeCodeData, sitalDeviceMemorySection_Ram, wSizeOfPreRolloverChunk, wpDataWordsSection);
			if (sitalReturnCode_SUCCESS != swResult)
			{
				//printf("\n\r1.6 error ");
				return swResult;
			}

			wpDataWordsSection += wSizeOfPreRolloverChunk;
			wDataBlockPointerOrModeCodeData = (U16BIT)dwDataBlockBaseAddress;

			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, wDataBlockPointerOrModeCodeData, sitalDeviceMemorySection_Ram, wSizeOfPostRolloverChunk, wpDataWordsSection);
			if (sitalReturnCode_SUCCESS != swResult)
			{

				return swResult;
			}
		}
		else
		{
			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, wDataBlockPointerOrModeCodeData, sitalDeviceMemorySection_Ram, wDataWordCount, wpDataWordsSection);
			if (sitalReturnCode_SUCCESS != swResult)
			{

				return swResult;
			}
		}
	}

	/// Replace the data stack pointer with a word whose MSByte contains the count of data words and whose LSByte contains the message type.
	// See the description of the returned buffer in the documentation of this function.
	wapBuffer[rtCommandStackEntry_OFFSET_OF_DATA_BLOCK_ADDRESS] = ( (wDataWordCount << 8U) | wMessageType );

	return 1;
}


/// <summary>
/// Initialize given MT device as a MT in accordance with given initialization options.
///
/// Note:
/// - This function assumes that given device ID is legal.
/// - This function assumes that given device is now being initialized as either a MT or a RT&MT.
/// - This function assumes that given device has already been opened, its memory zeroed, its memory map initialized and cleared, and is now at state READY.
/// - This function assumes that given initialization parameters are legal.
/// - Both MT stacks, command and data, must be aligned in the device memory to their size (e.g., a 4096 word stack may be placed only at an address of  the form 4096xN where N=0,1,2,...).
/// - In case the caller specifies stack sizes that the memory of given device is too small to contain, the function call will be rejected.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wStackMode (in)	Stack mode (sitalMtStackOption_*)
/// @param wCommandStackSize (in)	Size of command stack (sitalMtCommandStackSize_*)
/// @param wDataStackSize (in)	Size of data stack (sitalMtDataStackSize_*)
/// @param dwOptions (in)	Initialization options (An or-ed combination of sitalMtSetupOption_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT mt_Initialize (	S16BIT swDevice,
						U16BIT wStackMode,
						U16BIT wCommandStackSize,
						U16BIT wDataStackSize,
						U32BIT dwOptions)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.

	/// Initialize MT state.
	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	dsspDeviceState->rms.msMtState.dwOptions = dwOptions;
	dsspDeviceState->rms.msMtState.wStackMode = wStackMode;
	dsspDeviceState->rms.msMtState.bIsMessageCaptureTriggerUsed = FALSE;
	dsspDeviceState->rms.msMtState.bIsMessageCaptureTriggerOn = FALSE;
	dsspDeviceState->rms.msMtState.dwPreTriggerMessageStoreSize = 0U;

	/// Initialize the host buffer structure.
	memset (&(dsspDeviceState->rms.msMtState.hbsHostBuffer), 0, sizeof(HostBufferStructure));

	/// Initialize the stack states.
	memset (&(dsspDeviceState->rms.msMtState.msssStackStateA), 0, sizeof(MtStackStateStructure));
	memset (&(dsspDeviceState->rms.msMtState.msssStackStateB), 0, sizeof(MtStackStateStructure));

	static const U16BIT s_waMtCommandStackSize[] // Array of MT command stack sizes (in words).
						= { 256U, 1024U, 4096U, 16384U };
	static const U16BIT s_uiaMtCommandStackAlignment[] // Array of MT command stack alignment in device memory (in words) per command stack size (in words).
						= { 8U /* = log2(256) */, 10U /* = log2(1024) */, 12U /* = log2(4096) */, 14U /* = log2(16384) */ };
	U16BIT uiCommandStackSizeIndex; // An index to the arrays of MT command stack constants.
	uiCommandStackSizeIndex = (wCommandStackSize >> mtCommandStackSize_OFFSET_OF_SIZE);
	dsspDeviceState->rms.msMtState.msssStackStateA.wCommandStackSize =
		dsspDeviceState->rms.msMtState.msssStackStateB.wCommandStackSize =
			s_waMtCommandStackSize[uiCommandStackSizeIndex];
	U16BIT uiMtCommandStackAlignment; // The MT command stack alignment in device memory (in words) that suits given command stack size (in words).
	uiMtCommandStackAlignment = s_uiaMtCommandStackAlignment[uiCommandStackSizeIndex];

	static const U16BIT s_waMtDataStackSize[] // Array of MT data stack sizes (in words).
						= { 32768U, 16384U, 8192U, 4096U, 2048U, 1024U, 512U };
	static const U16BIT s_uiaMtDataStackAlignment[] // Array of MT data stack alignment in device memory (in words) per data stack size (in words).
						= { 15U /* = log2(32768) */, 14U /* = log2(16384) */, 13U /* = log2(8192) */, 12U /* = log2(4096) */, 11U /* = log2(2048) */, 10U /* = log2(1024) */, 9U /* = log2(512) */ };
	U16BIT uiDataStackSizeIndex; // An index to the arrays of MT data stack constants.
	uiDataStackSizeIndex = (U16BIT)((wDataStackSize >> mtDataStackSize_OFFSET_OF_SIZE) - (U16BIT)1U);
	dsspDeviceState->rms.msMtState.msssStackStateA.wDataStackSize =
		dsspDeviceState->rms.msMtState.msssStackStateB.wDataStackSize =
			s_waMtDataStackSize[uiDataStackSizeIndex];
	U16BIT uiMtDataStackAlignment; // The MT data stack alignment in device memory (in words) that suits given data stack size (in words).
	uiMtDataStackAlignment = s_uiaMtDataStackAlignment[uiDataStackSizeIndex];

	/// Allocate a suitable device memory region in suitable alignment for command stack A.
	U32BIT dwAllocationSize; // The size (in words) of the device memory allocation.
	dwAllocationSize = dsspDeviceState->rms.msMtState.msssStackStateA.wCommandStackSize;
	BOOLEAN bIsAllocationSuccessfullyAccomplished; // A flag that says whether the allocation actually succeeded.
	U32BIT dwAllocationBaseAddress; // The address in device memory where a suitable segment of memory has been allocated for the newly created object.
	S16BIT swResult; // Result of operation or function call.
	swResult = Device_Memory_TopSection_AllocateContinuity (&(dsspDeviceState->hdmmsDeviceMemoryMap), bcAddressMap_FREE_MEMORY, (dsspDeviceState->dcsDeviceCapabilities.dwRamSize - 1U), &dwAllocationSize, uiMtCommandStackAlignment, &bIsAllocationSuccessfullyAccomplished, &dwAllocationBaseAddress);
	if ( (sitalReturnCode_SUCCESS != swResult) || (FALSE == bIsAllocationSuccessfullyAccomplished) )
	{
		return sitalReturnCode_ALLOCATION_FAIL;
	}
	dsspDeviceState->rms.msMtState.msssStackStateA.dwCommandStackBaseAddress = dwAllocationBaseAddress;
	dsspDeviceState->rms.msMtState.msssStackStateA.dwCommandStackBorderAddress = (dwAllocationBaseAddress + dwAllocationSize);

	/// Allocate a suitable device memory region in suitable alignment for data stack A.
	dwAllocationSize = dsspDeviceState->rms.msMtState.msssStackStateA.wDataStackSize;
	swResult = Device_Memory_TopSection_AllocateContinuity (&(dsspDeviceState->hdmmsDeviceMemoryMap), bcAddressMap_FREE_MEMORY, (dsspDeviceState->dcsDeviceCapabilities.dwRamSize - 1U), &dwAllocationSize, uiMtDataStackAlignment, &bIsAllocationSuccessfullyAccomplished, &dwAllocationBaseAddress);
	if ( (sitalReturnCode_SUCCESS != swResult) || (FALSE == bIsAllocationSuccessfullyAccomplished) )
	{
		return sitalReturnCode_ALLOCATION_FAIL;
	}
	dsspDeviceState->rms.msMtState.msssStackStateA.dwDataStackBaseAddress = dwAllocationBaseAddress;
	dsspDeviceState->rms.msMtState.msssStackStateA.dwDataStackBorderAddress = (dwAllocationBaseAddress + dwAllocationSize);

	/// Record the command and data stack pointers for stack A.
	dsspDeviceState->rms.msMtState.msssStackStateA.dwCommandStackPointerAddress = mtAddressMap_MT_COMMAND_STACK_A_POINTER;
	dsspDeviceState->rms.msMtState.msssStackStateA.dwDataStackPointerAddress = mtAddressMap_MT_DATA_STACK_A_POINTER;

	/// If given MT device has been configured as having double stack:
	///		Allocate a suitable device memory region in suitable alignment for command stack B.
	///		Allocate a suitable device memory region in suitable alignment for data stack B.
	///		Record the command and data stack pointers for stack B.
	if (sitalMtStackOption_DOUBLE == dsspDeviceState->rms.msMtState.wStackMode)
	{
		dwAllocationSize = dsspDeviceState->rms.msMtState.msssStackStateB.wCommandStackSize;
		swResult = Device_Memory_TopSection_AllocateContinuity (&(dsspDeviceState->hdmmsDeviceMemoryMap), bcAddressMap_FREE_MEMORY, (dsspDeviceState->dcsDeviceCapabilities.dwRamSize - 1U), &dwAllocationSize, uiMtCommandStackAlignment, &bIsAllocationSuccessfullyAccomplished, &dwAllocationBaseAddress);
		if ( (sitalReturnCode_SUCCESS != swResult) || (FALSE == bIsAllocationSuccessfullyAccomplished) )
		{
			return sitalReturnCode_ALLOCATION_FAIL;
		}
		dsspDeviceState->rms.msMtState.msssStackStateB.dwCommandStackBaseAddress = dwAllocationBaseAddress;
		dsspDeviceState->rms.msMtState.msssStackStateB.dwCommandStackBorderAddress = (dwAllocationBaseAddress + dwAllocationSize);

		dwAllocationSize = dsspDeviceState->rms.msMtState.msssStackStateB.wDataStackSize;
		swResult = Device_Memory_TopSection_AllocateContinuity (&(dsspDeviceState->hdmmsDeviceMemoryMap), bcAddressMap_FREE_MEMORY, (dsspDeviceState->dcsDeviceCapabilities.dwRamSize - 1U), &dwAllocationSize, uiMtDataStackAlignment, &bIsAllocationSuccessfullyAccomplished, &dwAllocationBaseAddress);
		if ( (sitalReturnCode_SUCCESS != swResult) || (FALSE == bIsAllocationSuccessfullyAccomplished) )
		{
			return sitalReturnCode_ALLOCATION_FAIL;
		}
		dsspDeviceState->rms.msMtState.msssStackStateB.dwDataStackBaseAddress = dwAllocationBaseAddress;
		dsspDeviceState->rms.msMtState.msssStackStateB.dwDataStackBorderAddress = (dwAllocationBaseAddress + dwAllocationSize);

		dsspDeviceState->rms.msMtState.msssStackStateB.dwCommandStackPointerAddress = mtAddressMap_MT_COMMAND_STACK_B_POINTER;
		dsspDeviceState->rms.msMtState.msssStackStateB.dwDataStackPointerAddress = mtAddressMap_MT_DATA_STACK_B_POINTER;
	}

	/// Reset the initial and the current stack address for the command and data stacks of given MT device.
	swResult = mt_ResetStacks (swDevice);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Configure stack sizes in the image of the RT registers.
	swResult = device_Register_UpdateImage (swDevice, sitalRegisterAddress_CONFIGURATION_3, sitalConfigurationRegister3_MT_COMMAND_STACK_SIZE, wCommandStackSize);
	swResult = device_Register_UpdateImage (swDevice, sitalRegisterAddress_CONFIGURATION_3, sitalConfigurationRegister3_MT_DATA_STACK_SIZE, wDataStackSize);

	/// Decode and record given device options.
	/// Configure given device to support given device options.
#ifdef PROTOCOL_1553_A_SUPPORTED
	dsspDeviceState->bIsProtocol1553aSupported = ( (sitalMtSetupOption_1553A_MODE_CODES_ENABLED == (sitalMtSetupOption_1553A_MODE_CODES_ENABLED & dwOptions)) ? TRUE : FALSE );
#else // PROTOCOL_1553_A_NOT_SUPPORTED
	dsspDeviceState->bIsProtocol1553aSupported = FALSE;
#endif // PROTOCOL_1553_A_SUPPORTED
	if (TRUE == dsspDeviceState->bIsProtocol1553aSupported)
	{
		swResult = device_Register_UpdateImage (swDevice, sitalRegisterAddress_CONFIGURATION_3, sitalConfigurationRegister3_RT_MT_1553A_MODE_CODES, sitalConfigurationRegister3_RT_MT_1553A_MODE_CODES);
	}

	/// Configure the MT lookup table to initially instruct the monitoring of all messages.
	swResult = sitalMt_MessageMonitoring_Enable (swDevice, sitalRtAddress_ALL, sitalMessageDirection_BOTH, sitalRtSubaddressMask_ALL);

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Virtually configure given MT device to be able to start capturing messages.
///
/// Note:
/// - This function assumes that given device ID is legal.
/// - This function assumes that given device has already been initialized as either MT or RT&MT.
/// - This function assumes that given device is now at state READY.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT mt_Start (S16BIT swDevice)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.

	/// Reset the count of lost messages for both stacks of given MT device.
	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	dsspDeviceState->rms.msMtState.msssStackStateA.dwLostMessageCount = 0U;
	dsspDeviceState->rms.msMtState.msssStackStateB.dwLostMessageCount = 0U;

	/// Reset the initial and the current stack address for the command and data stacks of given MT device.
	S16BIT swResult; // Result of operation or function call.
	swResult = mt_ResetStacks (swDevice);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Reset the host buffer information.
	dsspDeviceState->rms.msMtState.hbsHostBuffer.dwOffsetOfNextMessageToRead = 0U;
	dsspDeviceState->rms.msMtState.hbsHostBuffer.dwOffsetOfNextMessageToWrite = 0U;
	dsspDeviceState->rms.msMtState.hbsHostBuffer.wFullnessPercentage = 0U;

	/// Initialize the message capturing trigger usage state for given MT device.
	dsspDeviceState->rms.msMtState.bIsMessageCaptureTriggerOn =  dsspDeviceState->rms.msMtState.bIsMessageCaptureTriggerUsed;

	/// If should explicitly reset the time tag:
	///		Reset the time tag.
	U16BIT wRegisterValue; // The current value of a target register, or the value to set for a target register.
	if (sitalModeVariant_NO_TIME_TAG_RESET != (sitalModeVariant_NO_TIME_TAG_RESET & dsspDeviceState->wModeVariants))
	{
		wRegisterValue = sitalStartResetRegister_RESET;
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_START_OR_RESET, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
	}

	/// Turn given device into enhanced mode.
	wRegisterValue = sitalConfigurationRegister3_ENHANCED_MODE;
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, sitalRegisterAddress_CONFIGURATION_3, sitalDeviceMemorySection_Registers, registerMask_ALL_BITS_ON, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Reset given stack state structure and the command and data stacks of given MT device that given stack state structure refers.
///
/// Note:
/// - This function assumes that given device ID is legal.
/// - This function assumes that given device has already been initialized as MT.
/// - This function assumes that given pointer is a non-null legal pointer.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param mssspTargetStackState (in/out)	A pointer to the state structure of the target MT stack (A/B), which is the structure from/into which stack information is read/written
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT mt_ResetStack (S16BIT swDevice, MtStackStateStructure* mssspTargetStackState)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.

	/// Calculate and record (both in host and device memory) the initial stack location for command stack A, and zero the contents of this stack.
	/// Calculate and record (in device memory) the initial stack location for data stack A.
	/// If given MT device has been configured as having double stack:
	///		Calculate and record (both in host and device memory) the initial stack location for command stack B, and zero the contents of this stack.
	///		Calculate and record (in device memory) the initial stack location for data stack B.
	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	U16BIT wStackInitialAddress; // The initial/starter device memory address of some target MT stack.
	wStackInitialAddress = MT_STACK_STARTER_ADDRESS(dsspDeviceState->rms.msMtState.wStackMode, mssspTargetStackState->dwCommandStackBaseAddress, mssspTargetStackState->wCommandStackSize);
	mssspTargetStackState->dwCommandStackInitialAddress = wStackInitialAddress;
	mssspTargetStackState->dwAddressOfMessageToRead = wStackInitialAddress;
	mssspTargetStackState->dwAddressOfMessageToWrite = wStackInitialAddress;
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, mssspTargetStackState->dwCommandStackPointerAddress, sitalDeviceMemorySection_Ram, 1U, &wStackInitialAddress);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Zero, mssspTargetStackState->dwCommandStackBaseAddress, sitalDeviceMemorySection_Ram, mssspTargetStackState->wCommandStackSize, ((U16BIT*)NULL));
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	wStackInitialAddress = MT_STACK_STARTER_ADDRESS(dsspDeviceState->rms.msMtState.wStackMode, mssspTargetStackState->dwDataStackBaseAddress, mssspTargetStackState->wDataStackSize);
	mssspTargetStackState->dwDataStackInitialAddress = wStackInitialAddress;
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, mssspTargetStackState->dwDataStackPointerAddress, sitalDeviceMemorySection_Ram, 1U, &wStackInitialAddress);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Reset all the command and data stacks configured with given MT device and their state structures.
///
/// Note:
/// - This function assumes that given device ID is legal.
/// - This function assumes that given device has already been initialized as MT.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT mt_ResetStacks (S16BIT swDevice)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.

	/// Calculate and record (both in host and device memory) the initial stack location for command stack A, and zero the contents of this stack.
	/// Calculate and record (in device memory) the initial stack location for data stack A.
	/// If given MT device has been configured as having double stack:
	///		Calculate and record (both in host and device memory) the initial stack location for command stack B, and zero the contents of this stack.
	///		Calculate and record (in device memory) the initial stack location for data stack B.
	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	MtStackStateStructure* mssspTargetStackState; // A pointer to the state structure of the target stack.
	mssspTargetStackState = (MtStackStateStructure*)&(dsspDeviceState->rms.msMtState.msssStackStateA);
	S16BIT swResult; // Result of operation or function call.
	swResult = mt_ResetStack (swDevice, mssspTargetStackState);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	if (sitalMtStackOption_DOUBLE == dsspDeviceState->rms.msMtState.wStackMode)
	{
		mssspTargetStackState = (MtStackStateStructure*)&(dsspDeviceState->rms.msMtState.msssStackStateB);
		swResult = mt_ResetStack (swDevice, mssspTargetStackState);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Use the message capture trigger of given MT device to examine given raw message.
/// If given message triggers this trigger, suitably sign the trigger. Otherwise, leave it un-triggered.
///
/// Note:
/// - This function assumes that given device ID is legal.
/// - This function assumes that given device has already been initialized as MT.
/// - This function assumes that a message capture trigger has already been defined for given MT device.
/// - This function assumes that the message capture trigger of given MT device was triggered yet.
/// - This function assumes that given buffer is at least sitalMtMaximum_MESSAGE_SIZE words long.
/// - This function assumes that given buffer has been previously filled by function mt_Message_GetFromStackRaw.
///   See the documentation for this function for information on the contents of its returned buffer.
///
/// @param swDevice (in)	Logical number of device (0-31, unused)
/// @param wapBuffer (in)	A pointer to a buffer in which a raw message is stored
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT mt_MessageCaptureTrigger_ExamineMessage (S16BIT swDevice, U16BIT* wapBuffer)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);

	// *** HERE SHOULD EXAMINE GIVEN MESSAGE (see DDC func _mtCheckForTrigger ***
	U16BIT wTriggerActivatorCount; // The count of trigger activators detected while examining a message using a message capture trigger.
	wTriggerActivatorCount = 0U;

	// *** IFF THE MESSAGE TRIGGERS: ***
	dsspDeviceState->rms.msMtState.bIsMessageCaptureTriggerOn = FALSE;

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Read from given MT device stack into given buffer the currently available raw message that's recorded in this MT stack at given address.
/// If so desired, then remove from the stack the message that was read.
///
/// Note:
/// - This function assumes that given device ID is legal.
/// - This function assumes that given device has already been initialized as MT or RT&MT.
/// - This function assumes that given message address is legal.
/// - This function assumes that given pointer to buffer is a non-null legal pointer.
/// - The MT device does not promote the stack pointer to point the head of the next message until done with the previous message;
///   Therefore, as long as the library's internal stack pointer is behind the MT stack pointer, there's another sealed stack entry to diagnose.
///   Saying this, if the EOM bit is zero in the block status word in the currently reviewed entry, it indicates that the message did not finish
///   correctly, possibly because of a transceiver problem.
/// - Given buffer is first zeroed, and then filled as follows:
///   - The target MT stack entry is copied into it.
///   - The data stack pointer is replaced with a word whose:
///     - LSByte contains the type of the message that was read (sitalMessageType_*).
///     - The MSbit (bit #7) of the MSByte is set in case an error has been discovered with the data words.
///     - The rest of the bits (bits #0-6) of the MSByte contain the count of data words of given message.
///   - The data words are stored right after the stack entry, that is, starting at offset sitalMtMemoryObjectSize_COMMAND_STACK_ENTRY.
///     In case of a mode code message with data, this data word is returned as the first (actually the single) data word.
/// - The data word that's read from identified mode code messages with data is stored in the data stack,
///   and is pointed by the data pointer at the dedicated entry in the command stack (just like in case of regular messages).
///
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param mssspTargetStackState (in/out)	A pointer to the state structure of the target MT stack (A/B), which is the structure from/into which stack information is read/written
/// @param wapBuffer (out)	A pointer to a buffer in which the raw messages are stored
/// @param wpMessageTimeTagRolloverCounter (out)	A pointer to a variable in which the time tag rollover counter related with the returned message is returned, or NULL if no need to return it
/// @param bIsNextMessageRequired (in)	A flag that says whether the next available stack message should be read (or, otherwise, of the last message that was written by the device)
/// @param bIsMessagePurgeRequired (in)	A flag that says whether to delete the returned message after reading it from the stack
/// @return One (1)	A single raw message was read
/// @return Zero (0)	No message available, though no error occurred
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT mt_Message_GetFromStackRaw (	S16BIT swDevice,
									MtStackStateStructure* mssspTargetStackState,
									U16BIT* wapBuffer,
									U16BIT* wpMessageTimeTagRolloverCounter,
									BOOLEAN bIsNextMessageRequired,
									BOOLEAN bIsMessagePurgeRequired)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.

	/// Zero given buffer.
	memset (wapBuffer, 0, (sitalMtMaximum_MESSAGE_SIZE << 1U));

	/// If it is the next available message in the stack that's required:
	///		Get the address of the next stack message to read.
	/// Else:
	///		Get the address of the previously recorded stack message.
	U32BIT dwAddressOfMessageToRead; // The device memory address where the stack message that should be read is recorded.
	if (TRUE == bIsNextMessageRequired)
	{
		if (mssspTargetStackState->dwAddressOfMessageToRead == mssspTargetStackState->dwAddressOfMessageToWrite)
		{
			return 0;
		}

		dwAddressOfMessageToRead = mssspTargetStackState->dwAddressOfMessageToRead;
	}
	else // The required message is the last recorded one, which is the one before the currently/next written one.
	{
		dwAddressOfMessageToRead = mssspTargetStackState->dwAddressOfMessageToWrite;
		if (mssspTargetStackState->dwCommandStackBaseAddress == dwAddressOfMessageToRead)
		{
			dwAddressOfMessageToRead = (mssspTargetStackState->dwCommandStackBorderAddress - sitalMtMemoryObjectSize_COMMAND_STACK_ENTRY);
		}
		else
		{
			dwAddressOfMessageToRead -= sitalRtMemoryObjectSize_COMMAND_STACK_ENTRY;
		}
	}

	/// Read the desired message entry from the target stack.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, dwAddressOfMessageToRead, sitalDeviceMemorySection_Ram, sitalMtMemoryObjectSize_COMMAND_STACK_ENTRY, wapBuffer);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Extricate message qualifiers from the stack entry that was just read.
	U16BIT wBlockStatusWord; // Message block status.
	wBlockStatusWord = wapBuffer[mtCommandStackEntry_OFFSET_OF_BLOCK_STATUS_WORD];
	U16BIT wTimeTag; // Message time tag.
	wTimeTag = wapBuffer[rtCommandStackEntry_OFFSET_OF_TIME_TAG];
	U16BIT wCommand; // Message command.
	wCommand = wapBuffer[mtCommandStackEntry_OFFSET_OF_COMMAND];
	U16BIT wSubaddress; // SubAddress.
	wSubaddress = (U16BIT)(((U16BIT)commandWord_SUBADDRESS_OR_MODE & wCommand) >> commandWord_OFFSET_OF_SUBADDRESS_OR_MODE);
	U16BIT wRtAddress; // RT address.
	wRtAddress = (U16BIT)(((U16BIT)commandWord_RT_ADDRESS & wCommand) >> commandWord_OFFSET_OF_RT_ADDRESS);
	U16BIT wMessageDirection; // Tx/Rx bit.
	wMessageDirection = (U16BIT)(((U16BIT)commandWord_RX_OR_TX & wCommand) >> commandWord_OFFSET_OF_RX_OR_TX);
	U16BIT wCommandCodedWordCount; // The word count coded in the command word.
	wCommandCodedWordCount = (U16BIT)(((U16BIT)commandWord_WORD_COUNT_OR_MODE_CODE & wCommand) >> commandWord_OFFSET_OF_WORD_COUNT_OR_MODE_CODE);
	U16BIT wDataBlockPointer; // The device memory address of the message data block.
	wDataBlockPointer = wapBuffer[mtCommandStackEntry_OFFSET_OF_DATA_BLOCK_ADDRESS];

	///	If the transmission of the current message isn't yet completed:
	///		Return no message.
	if ((U16BIT)0U == ((U16BIT)sitalMtBlockStatusWord_END_OF_MESSAGE & wBlockStatusWord))
	{
		return 0;
	}

	/// If given device is a RT&MT device for which a host buffer has been installed:
	///		If a time tag rollover took place since the last message has been recorded:
	///			Increment the time tag rollover counter in the host buffer structure of given device.
	///		Record the current time tag in the host buffer structure of given device.
	///		If the caller requires the time tag rollover counter that is related with the currently recorded message:
	///			Record the current time tag rollover counter as the time tag rollover counter related with the message that is currently recorded in the host buffer of given device.
	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalMode_RT_AND_MT == dsspDeviceState->wMode)
	{
		HostBufferStructure* hbspHostBuffer; // A host buffer structure.
		hbspHostBuffer = (HostBufferStructure*)&(dsspDeviceState->rms.rsRtState.hbsHostBuffer);
		if (0U < hbspHostBuffer->dwHostBufferSize)
		{
			if ((0x0000FFFFU & hbspHostBuffer->dwLastMessageTimeTag) > wTimeTag)
			{
				hbspHostBuffer->dwLastMessageTimeTag = ( hbspHostBuffer->dwLastMessageTimeTag + 0x00010000U );
			}
			hbspHostBuffer->dwLastMessageTimeTag = ( (0xFFFF0000U & hbspHostBuffer->dwLastMessageTimeTag) | wTimeTag );
			if (((U16BIT*)NULL) != wpMessageTimeTagRolloverCounter)
			{
				(*wpMessageTimeTagRolloverCounter) = (U16BIT)( (0xFFFF0000U & hbspHostBuffer->dwLastMessageTimeTag) >> 16U );
			}
		}
	}

	/// Find out the message type and its number of data words.
	U16BIT wMessageType; // Type of message.
	wMessageType = wMessageDirection;
	U16BIT wExpectedDataWordCount; // Number of actually expected message data words (to include all command-coded data words and statuses).
	wExpectedDataWordCount = 0U;
	if (sital1553_BROADCAST == wRtAddress)
	{
		wMessageType |= messageTypeComponent_BROADCAST;
	}
	if ((sital1553_MODE_CODE1 == wSubaddress) || (sital1553_MODE_CODE2 == wSubaddress))
	{
		wMessageType |= messageTypeComponent_MODE;
		if (commandWord_MODE_WITH_DATA == (commandWord_MODE_WITH_DATA & wCommandCodedWordCount))
		{
			wMessageType |= messageTypeComponent_DATA;
			wExpectedDataWordCount += ( (sital1553_BROADCAST == wRtAddress) ? 1U : 2U );
		}
		else
		{
			wExpectedDataWordCount += ( (sital1553_BROADCAST == wRtAddress) ? 0U : 1U );
		}
	}
	else
	{
		if	(
				(sitalMtBlockStatusWord_RT_TO_RT_MESSAGE == (sitalMtBlockStatusWord_RT_TO_RT_MESSAGE & wBlockStatusWord))
				||
				(sitalMtBlockStatusWord_RT_TO_RT_COMMAND_ERROR == (sitalMtBlockStatusWord_RT_TO_RT_COMMAND_ERROR & wBlockStatusWord))
			)
		{
			wMessageType |= messageTypeComponent_DATA;
		}

		if	(
				(sitalMtBlockStatusWord_RT_TO_RT_MESSAGE == (sitalMtBlockStatusWord_RT_TO_RT_MESSAGE & wBlockStatusWord))
				&&
				(sital1553_BROADCAST == wRtAddress)
			)
		{
			wExpectedDataWordCount += 2U;
		}
		else
		if (sitalMtBlockStatusWord_RT_TO_RT_MESSAGE == (sitalMtBlockStatusWord_RT_TO_RT_MESSAGE & wBlockStatusWord))
		{
			wExpectedDataWordCount += 3U;
		}
		else
		if (sital1553_BROADCAST != wRtAddress)
		{
			wExpectedDataWordCount += 1U;
		}

		wExpectedDataWordCount += ( (0U == wCommandCodedWordCount) ? 32U : wCommandCodedWordCount );
	}

	///	Analyze the message in order to find its overall word count and its gaps count.
	switch (wMessageType)
	{
	case sitalMessageType_BC_TO_RT:
	case sitalMessageType_RT_TO_BC:
	case sitalMessageType_RT_TO_RT:
	case sitalMessageType_MODE_NO_DATA:
	case sitalMessageType_MODE_DATA_RX:
	case sitalMessageType_MODE_DATA_TX:
	case sitalMessageType_BROADCAST:
	case sitalMessageType_BROADCAST_RT_TO_RT:
	case sitalMessageType_BROADCAST_MODE_NO_DATA:
	case sitalMessageType_BROADCAST_MODE_DATA:
		break;
	default:
		wMessageType = sitalMessageType_INVALID;
	}

	/// If the caller requests to remove the currently read message from the stack:
	///		Clear all stack entries from the one pointed by this library's internal stack pointer to that pointed by given message address (both included).
	///		Set this library's internal stack pointer to point the entry next to given one.
	// With all above operations the possibility of an interim rollover is, of course, taken in account below.
	if (TRUE == bIsMessagePurgeRequired)
	{
		if (dwAddressOfMessageToRead < mssspTargetStackState->dwAddressOfMessageToRead)
		{
			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Zero, mssspTargetStackState->dwAddressOfMessageToRead, sitalDeviceMemorySection_Ram, (mssspTargetStackState->dwCommandStackBorderAddress - mssspTargetStackState->dwAddressOfMessageToRead), ((U16BIT*)NULL));
			if (sitalReturnCode_SUCCESS != swResult)
			{
				return swResult;
			}

			mssspTargetStackState->dwAddressOfMessageToRead = mssspTargetStackState->dwCommandStackBaseAddress;
		}

		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Zero, mssspTargetStackState->dwAddressOfMessageToRead, sitalDeviceMemorySection_Ram, ((dwAddressOfMessageToRead + sitalRtMemoryObjectSize_COMMAND_STACK_ENTRY) - mssspTargetStackState->dwAddressOfMessageToRead), ((U16BIT*)NULL));
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}

		mssspTargetStackState->dwAddressOfMessageToRead = (dwAddressOfMessageToRead + sitalRtMemoryObjectSize_COMMAND_STACK_ENTRY);
		mssspTargetStackState->dwAddressOfMessageToRead = ( (mssspTargetStackState->dwCommandStackBorderAddress == mssspTargetStackState->dwAddressOfMessageToRead) ? mssspTargetStackState->dwCommandStackBaseAddress : mssspTargetStackState->dwAddressOfMessageToRead );
	}

	/// Initially assume that the expected number of message data words is also the actual number of message data words.
	U16BIT wActualDataWordCount; // The actual number of message data words, i.e., a count that takes in account the case an error was encountered.
	wActualDataWordCount = wExpectedDataWordCount;

	/// If any error reported by the BSW of the currently read message:
	///		Calculate the device address of the data block pointer in the message block of the cyclically following message.
	///		Read this data block pointer.
	///		If this data block pointer is valid:
	///			Calculate the cyclic difference between the beginning of the current and the next message's data block.
	///			If this difference isn't equal to the normal/expected number of data words for the currently read message:
	///				Overwrite the count of data words with the actual count of data words.
	///				Flag the MSbit (bit #7) of the actual count of data words to indicate an error in the count of message data words.
	// Note:
	// - An invalid (zero) data block pointer indicates that there is no next message to read.
	//   Message blocks are zeroed upon purge by this function (see right above).
	// - See above in the documentation for this function about the flagging of data word count error.
	//   The actual count of data words, possibly flagged to indicate an error, will later replace the messages data block pointer in given buffer (see below).
	// - In normal messages, the word count is extracted from the message command word.
	// - When an RT responses BUSY to its BC, the monitoring MT detects a message whose BSW shows an error.
	// - In this case, the difference between the message data pointers (that are pointing to the MT data stack) of the current message and the next one
	//   is used to calculate the actual number of data words (what includes the status words) in the current message, instead of using the normal word count.
	// - Moreover, in this case the MT cannot say which of the detected data words is actually data, and which is a status word (recall that in erroneous cases
	//   some data may be lost, or, alternatively, some redundant data may appear). Therefore, the MT only reports the overall number of detected data words.
	// - Yet, when the last message in the MT command stack is analyzed, there's no next message, and therefore no next data pointer. The number of actual data
	//   words isn't therefore reported in case of message error in the last available message.
	if ((U16BIT)0U != ((U16BIT)sitalRtMtMessageBlockStatusWord_ERROR_MASK & wBlockStatusWord))
	{
		U32BIT dwAddressOfDataBlockPointerOfNextMessage; // The device memory address of the message data block address of the next message in the target stack.
		if ( (mssspTargetStackState->dwCommandStackBorderAddress - dwAddressOfMessageToRead) == sitalMtMemoryObjectSize_COMMAND_STACK_ENTRY  )
		{
			dwAddressOfDataBlockPointerOfNextMessage = (mssspTargetStackState->dwCommandStackBaseAddress + mtCommandStackEntry_OFFSET_OF_DATA_BLOCK_ADDRESS);
		}
		else
		{
			dwAddressOfDataBlockPointerOfNextMessage = (dwAddressOfMessageToRead + sitalMtMemoryObjectSize_COMMAND_STACK_ENTRY + mtCommandStackEntry_OFFSET_OF_DATA_BLOCK_ADDRESS);
		}

		U16BIT wDataBlockPointerOfNextMessage; // The device memory address of the message data block of the next message in the target stack.
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, dwAddressOfDataBlockPointerOfNextMessage, sitalDeviceMemorySection_Ram, 1U, &wDataBlockPointerOfNextMessage);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
		if (0U != wDataBlockPointerOfNextMessage)
		{
			wActualDataWordCount = (U16BIT)( (U32BIT)wDataBlockPointerOfNextMessage + ( (wDataBlockPointerOfNextMessage < wDataBlockPointer) ? mssspTargetStackState->wDataStackSize : 0U ) - wDataBlockPointer );
			if (wActualDataWordCount < wExpectedDataWordCount)
			{
				wExpectedDataWordCount = wActualDataWordCount;
				wActualDataWordCount |= 0x80U;
			}
		}
	}

	/// Copy the data words actually recorded with the currently read message.
	// With above operation the possibility of an interim rollover is, of course, taken in account below.
	U16BIT* wpDataWordsSection; // A pointer to the section of given buffer where the data words will be stored.
	wpDataWordsSection = &(wapBuffer[sitalMtMemoryObjectSize_COMMAND_STACK_ENTRY]);
	if (((U32BIT)wDataBlockPointer + wExpectedDataWordCount) > mssspTargetStackState->dwDataStackBorderAddress)
	{
		U16BIT wSizeOfPreRolloverChunk; // The size (in words) of the chunk of data words of the currently read message that are stored at the end of the global circular data block.
		wSizeOfPreRolloverChunk = (U16BIT)(mssspTargetStackState->dwDataStackBorderAddress - (U32BIT)wDataBlockPointer);
		U16BIT wSizeOfPostRolloverChunk; // The size (in words) of the chunk of data words of the currently read message that are stored at the beginning of the global circular data block.
		wSizeOfPostRolloverChunk = (wExpectedDataWordCount - wSizeOfPreRolloverChunk);

		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, wDataBlockPointer, sitalDeviceMemorySection_Ram, wSizeOfPreRolloverChunk, wpDataWordsSection);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}

		wpDataWordsSection += wSizeOfPreRolloverChunk;
		wDataBlockPointer = (U16BIT)(mssspTargetStackState->dwDataStackBaseAddress);
		wExpectedDataWordCount = wSizeOfPostRolloverChunk;
	}

	if (0U < wExpectedDataWordCount)
	{
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, wDataBlockPointer, sitalDeviceMemorySection_Ram, wExpectedDataWordCount, wpDataWordsSection);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
	}

	/// Replace the data stack pointer with a word whose MSByte contains the data words count and error indication and whose LSByte contains the message type.
	// See the description of the returned buffer in the documentation of this function.
	wapBuffer[rtCommandStackEntry_OFFSET_OF_DATA_BLOCK_ADDRESS] = ( (wActualDataWordCount << 8U) | wMessageType );

	return 1;
}


/// <summary>
/// Configure given HOO9 MT device to monitor or avoid monitoring, depending on given flag, commands that suits given combinations of RT address, RT-related message direction, and subaddress.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wRtAddress (in)	A RT address (sitalRtAddress_0-sitalRtAddress_15 or sitalRtAddress_ALL)
/// @param wMessageDirection (in)	RT-related message direction/bus (sitalMessageDirection_*)
/// @param qwRtSubaddressMask (in)	Mask of affected subaddresses, 0-63, where bit #i corresponds subaddress #i (An or-ed combination of sitalHoo9RtSubaddressMask_0-sitalHoo9RtSubaddressMask_63)
/// @param bEnable (in)	A flag that says whether to enable the monitoring of the described messages
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT hoo9_Mt_MessageMonitoring_Configure (	S16BIT swDevice,
												U16BIT wRtAddress,
												U16BIT wMessageDirection,
												U64BIT qwRtSubaddressMask,
												BOOLEAN bEnable)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if ( (sitalRtAddress_ALL != wRtAddress) && ((0U > wRtAddress) || (sitalRtAddress_16 <= wRtAddress)) )
	{
		return sitalReturnCode_INVALID_RT_ADDRESS;
	}

	if ( (sitalMessageDirection_BOTH != wMessageDirection) && ((0U > wMessageDirection) || (messageDirection_BORDER <= wMessageDirection)) )
	{
		return sitalReturnCode_INVALID_DIRECTION_BIT;
	}

	MT_MESSAGE_MONITORING_CONFIGURATION_FUNCTION funcMtMessageMonitoringConfiguration; // A pointer to either function sitalMt_MessageMonitoring_Enable or function sitalMt_MessageMonitoring_Disable, as appropriate with given flag.
	funcMtMessageMonitoringConfiguration = ( bEnable ? sitalMt_MessageMonitoring_Enable : sitalMt_MessageMonitoring_Disable );

	/// Set loop delimiters for the address and direction loops.
	U16BIT wAddressLoopBase; // Base value of address loop.
	U16BIT wAddressLoopBorder; // Border value of address loop.
	if (sitalRtAddress_ALL == wRtAddress)
	{
		wAddressLoopBase = 0U;
		wAddressLoopBorder = sitalRtAddress_16;
	}
	else
	{
		wAddressLoopBase = wRtAddress;
		wAddressLoopBorder = (wRtAddress + (U16BIT)1U);
	}
	U16BIT wDirectionLoopBase; // Base value of direction loop.
	U16BIT wDirectionLoopBorder; // Border value of direction loop.
	if (sitalMessageDirection_BOTH == wMessageDirection)
	{
		wDirectionLoopBase = 0U;
		wDirectionLoopBorder = messageDirection_BORDER;
	}
	else
	{
		wDirectionLoopBase = wMessageDirection;
		wDirectionLoopBorder = (wMessageDirection + (U16BIT)1U);
	}


	/// Loop over all given combinations of address and direction:
	///		Update each combination's monitoring specifications.
	U16BIT wFakeRtAddress; // A fake 5-bits RT address whose 4 MSbits are set to given RT address and 1 LSbit is set to given direction; used in order to adapt to the structure of the monitoring lookup table of a HOO9-MT.
	U16BIT wFakeMessageDirection; // A fake message direction that really flags whether the lower or higher 32 RT addresses are to be handled in this turn; used in order to adapt to the structure of the monitoring lookup table of a HOO9-MT.
	S16BIT swResult; // Result of operation or function call.
	for (U16BIT uiAddress=wAddressLoopBase; uiAddress<wAddressLoopBorder; uiAddress++)
	{
		for (U16BIT uiDirection=wDirectionLoopBase; uiDirection<wDirectionLoopBorder; uiDirection++)
		{
			wFakeRtAddress = ( (uiAddress << 1U) | uiDirection );

			/// First use the 1553 MT message monitoring enabler function twice, one in order to update the monitoring state of the lower 32 RT subaddresses.
			wFakeMessageDirection = sitalMessageDirection_RX;
			swResult = funcMtMessageMonitoringConfiguration (swDevice, wRtAddress, wMessageDirection, ((U32BIT)(sitalRtSubaddressMask_ALL & qwRtSubaddressMask)));
			if (sitalReturnCode_SUCCESS != swResult)
			{
				return swResult;
			}

			/// Then use the 1553 MT message monitoring enabler function twice, one in order to update the monitoring state of the higher 32 RT subaddresses.
			wFakeMessageDirection = sitalMessageDirection_TX;
			swResult = funcMtMessageMonitoringConfiguration (swDevice, wRtAddress, wMessageDirection, ((U32BIT)(qwRtSubaddressMask >> 32U)));
			if (sitalReturnCode_SUCCESS != swResult)
			{
				return swResult;
			}
		}
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// For given RT&MT device, which has two host buffers that together make up an RT&MT combined host buffer, find who's the host buffer that contains the requested message.
///
/// Note:
/// - This function assumes that given device ID is legal.
/// - This function assumes that given device has already been initialized as RT&MT.
/// - This function assumes that given both RT and MT host buffers have been installed for given device.
/// - This function assumes that given pointer to host buffer identifier variable is a non-null legal pointer.
/// - This function assumes that given message location and removal parameter is a legal one.
/// - The caller wants to get the next/last message in the RT&MT combined host buffer.
///   But each of the host buffers that together make up this combined host buffer, i.e., the RT and the MT host buffers, principally has a next/last message of its own, and it should be here decided from which of them to read.
///   The way to decide from which host buffer to read the requested message is to select the one that stores the earlier/later of these two messages, in case the next/last message is requested, respectively.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wMessageLocationAndRemoval (in)	The location in the stack or host buffer of the message to read, and removal instructions (sitalMessageLocationAndRemoval_*)
/// @param wpRequestedMessageContainerHostBuffer (out)	A pointer to the variable in which an host buffer identifier (rtMtMessageContainerHostBuffer_RT/MT) of the host buffer that contains the requested message is returned, or rtMtMessageContainerHostBuffer_NONE if none contains any message
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT rtmt_HostBuffer_Message_FindContainer (S16BIT swDevice, U16BIT wMessageLocationAndRemoval, U16BIT* wpRequestedMessageContainerHostBuffer)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.

	/// If there are no additional messages in any of the host buffers that make up the RT&MT combined host buffer:
	///		Return proper indication.
	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	/// If just one of the host buffers that make up the RT&MT combined host buffer contains additional messages:
	///		Return proper indication.
	HostBufferStructure* hbspRtHostBuffer; // A host buffer structure.
	hbspRtHostBuffer = (HostBufferStructure*)&(dsspDeviceState->rms.rsRtState.hbsHostBuffer);
	HostBufferStructure* hbspMtHostBuffer; // A host buffer structure.
	hbspMtHostBuffer = (HostBufferStructure*)&(dsspDeviceState->rms.msMtState.hbsHostBuffer);
	if (0U == hbspRtHostBuffer->dwMessageCount)
	{
		(*wpRequestedMessageContainerHostBuffer) = (U16BIT)( (0U == hbspMtHostBuffer->dwMessageCount) ? rtMtMessageContainerHostBuffer_NONE : rtMtMessageContainerHostBuffer_MT );
		return sitalReturnCode_SUCCESS;
	}
	else
	if (0U == hbspMtHostBuffer->dwMessageCount)
	{
		(*wpRequestedMessageContainerHostBuffer) = rtMtMessageContainerHostBuffer_RT;
		return sitalReturnCode_SUCCESS;
	}

	// At this point its clear that both of the host buffers that make up the RT&MT combined host buffer contain additional messages.
	/// Calculate the offsets of the two messages, the one in the RT host buffer and the one in the MT host buffer, that are candidates for being the requested message.
	U32BIT dwRtOffsetOfCandidateMessage; // The offset (in words) from the beginning of the RT host buffer of the location where the message that is candidate for reading is recorded.
	U32BIT dwMtOffsetOfCandidateMessage; // The offset (in words) from the beginning of the MT host buffer of the location where the message that is candidate for reading is recorded.
	switch (wMessageLocationAndRemoval)
	{
	case sitalMessageLocationAndRemoval_NEXT_PURGE:
	case sitalMessageLocationAndRemoval_NEXT_NO_PURGE:
		dwRtOffsetOfCandidateMessage = hbspRtHostBuffer->dwOffsetOfNextMessageToRead;
		dwMtOffsetOfCandidateMessage = hbspMtHostBuffer->dwOffsetOfNextMessageToRead;
		break;
	case sitalMessageLocationAndRemoval_LATEST_PURGE:
	case sitalMessageLocationAndRemoval_LATEST_NO_PURGE:
		dwRtOffsetOfCandidateMessage = ( ((0U == hbspRtHostBuffer->dwOffsetOfNextMessageToWrite) ? hbspRtHostBuffer->dwHostBufferSize : hbspRtHostBuffer->dwOffsetOfNextMessageToWrite) - sitalRtMaximum_MESSAGE_SIZE );
		dwMtOffsetOfCandidateMessage = ( ((0U == hbspMtHostBuffer->dwOffsetOfNextMessageToWrite) ? hbspMtHostBuffer->dwHostBufferSize : hbspMtHostBuffer->dwOffsetOfNextMessageToWrite) - sitalMtMaximum_MESSAGE_SIZE );
		break;
	default:
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Set pointers to the time tags of these two messages.
	U16BIT* wpRtMessageTimeTag; // A pointer to the place in the RT host buffer where the time tag of the message that is candidate for reading is recorded.
	wpRtMessageTimeTag = (hbspRtHostBuffer->waBuffer + dwRtOffsetOfCandidateMessage + rtCommandStackEntry_OFFSET_OF_TIME_TAG);
	U16BIT* wpMtMessageTimeTag; // A pointer to the place in the MT host buffer where the time tag of the message that is candidate for reading is recorded.
	wpMtMessageTimeTag = (hbspMtHostBuffer->waBuffer + dwMtOffsetOfCandidateMessage + mtCommandStackEntry_OFFSET_OF_TIME_TAG);

	/// Set pointers to the time tag rollover counts of these two messages.
	U16BIT* wpRtMessageTimeTagRolloverCount; // A pointer to the place in the time tag rollover count array of the RT host buffer where the time tag rollover count of the message that is candidate for reading is recorded.
	wpRtMessageTimeTagRolloverCount = (hbspRtHostBuffer->waTimeTagRolloverCount + (dwRtOffsetOfCandidateMessage / sitalRtMaximum_MESSAGE_SIZE));
	U16BIT* wpMtMessageTimeTagRolloverCount; // A pointer to the place in the time tag rollover count array of the MT host buffer where the time tag rollover count of the message that is candidate for reading is recorded.
	wpMtMessageTimeTagRolloverCount = (hbspMtHostBuffer->waTimeTagRolloverCount + (dwMtOffsetOfCandidateMessage / sitalMtMaximum_MESSAGE_SIZE));

	/// Calculate a 32Bit time tag for these two messages.
	U32BIT dwRtFullMessageTimeTag; // Full time tag of the RT message that is candidate for reading.
	dwRtFullMessageTimeTag = ( (((U32BIT)(*wpRtMessageTimeTagRolloverCount)) << 16U) | (*wpRtMessageTimeTag) );
	U32BIT dwMtFullMessageTimeTag; // Full time tag of the MT message that is candidate for reading.
	dwMtFullMessageTimeTag = ( (((U32BIT)(*wpMtMessageTimeTagRolloverCount)) << 16U) | (*wpMtMessageTimeTag) );

	/// If the next message in time is requested by the caller:
	///		Choose the host buffer the contains the message whose 32Bit time tag is the smaller one (i.e., the message that has been transmitted earlier).
	/// Else:
	///		Choose the host buffer the contains the message whose 32Bit time tag is the bigger one (i.e., the message that has been transmitted later).
	switch (wMessageLocationAndRemoval)
	{
	case sitalMessageLocationAndRemoval_NEXT_PURGE:
	case sitalMessageLocationAndRemoval_NEXT_NO_PURGE:
		(*wpRequestedMessageContainerHostBuffer) = (U16BIT)( (dwRtFullMessageTimeTag < dwMtFullMessageTimeTag) ? rtMtMessageContainerHostBuffer_RT : rtMtMessageContainerHostBuffer_MT );
		break;
	case sitalMessageLocationAndRemoval_LATEST_PURGE:
	case sitalMessageLocationAndRemoval_LATEST_NO_PURGE:
		(*wpRequestedMessageContainerHostBuffer) = (U16BIT)( (dwRtFullMessageTimeTag < dwMtFullMessageTimeTag) ? rtMtMessageContainerHostBuffer_MT : rtMtMessageContainerHostBuffer_RT );
		break;
	default:
		return sitalReturnCode_INVALID_PARAMETER;
	}

	return sitalReturnCode_SUCCESS;
}



// Exported functions.


/// <summary>
/// Get this library version numbers.
///
/// @param wpMajorVersion (out)	A pointer to the variable in which the first version number is returned
/// @param wpMinorVersion (out)	A pointer to the variable in which the second version number is returned
/// @param wpBuildNumber (out)	A pointer to the variable in which the third version number is returned
/// @param wpRevisionNumber (out)	A pointer to the variable in which the fourth version number is returned
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalStld1553_GetLibraryVersion (	U16BIT* wpMajorVersion,
												U16BIT* wpMinorVersion,
												U16BIT* wpBuildNumber,
												U16BIT* wpRevisionNumber)
{
	/// @pseudocode

	/// Get version numbers.
	return library_GetVersion (wpMajorVersion, wpMinorVersion, wpBuildNumber, wpRevisionNumber);
}


/// <summary>
/// Get this library version numbers in a short form.
///
/// Equivalent DDC definition: aceGetLibVersion
/// @return Positive integer	An unsigned 16-bit value, where the MSByte contains the major version number, the MSNibble of the LSByte contains the minor version number, and the LSNibble of the LSByte contains the build number
/// @return Zero	Error condition or function failed
/// </summary>
U16BIT _DECL sitalStld1553_GetShortLibraryVersion (void)
{
	U16BIT wMajorVersionOfThisLibrary, wMinorVersionOfThisLibrary, wBuildNumberOfThisLibrary, wRevisionNumberOfThisLibrary; // Version numbers of this library.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalStld1553_GetLibraryVersion (&wMajorVersionOfThisLibrary, &wMinorVersionOfThisLibrary, &wBuildNumberOfThisLibrary, &wRevisionNumberOfThisLibrary);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return 0;
	}

	if ( (0U != (0xFF00U & wMajorVersionOfThisLibrary)) || (0U != (0xFFF0U & wMinorVersionOfThisLibrary)) || (0U != (0xFFF0U & wBuildNumberOfThisLibrary)) )
	{
		return 0;
	}

	return ( (wMajorVersionOfThisLibrary << 8U) | (wMinorVersionOfThisLibrary << 4U) | wBuildNumberOfThisLibrary );
}


/// <summary>
/// Get the device driver interface library version numbers in a short form.
///
/// Equivalent DDC definition: aceGetCoreVersion
/// @return Positive integer	An unsigned 16-bit value, where the MSByte contains the major version number, the MSNibble of the LSByte contains the minor version number, and the LSNibble of the LSByte contains the build number
/// @return Zero	Error condition or function failed
/// </summary>
U16BIT _DECL sitalStld1553_GetShortCoreVersion (void)
{
	U16BIT wMajorVersionOfLoadedDriverInterfaceLibrary, wMinorVersionOfLoadedDriverInterfaceLibrary, wBuildNumberOfLoadedDriverInterfaceLibrary, wRevisionNumberOfLoadedDriverInterfaceLibrary; // Version numbers of the loaded driver-interface-library.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDriverInterfaceLibrary_GetVersion (&wMajorVersionOfLoadedDriverInterfaceLibrary, &wMinorVersionOfLoadedDriverInterfaceLibrary, &wBuildNumberOfLoadedDriverInterfaceLibrary, &wRevisionNumberOfLoadedDriverInterfaceLibrary);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return 0U;
	}

	if ( (0U != (0xFF00U & wMajorVersionOfLoadedDriverInterfaceLibrary)) || (0U != (0xFFF0U & wMinorVersionOfLoadedDriverInterfaceLibrary)) || (0U != (0xFFF0U & wBuildNumberOfLoadedDriverInterfaceLibrary)) )
	{
		return 0U;
	}

	return ( (wMajorVersionOfLoadedDriverInterfaceLibrary << 8U) | (wMinorVersionOfLoadedDriverInterfaceLibrary << 4U) | wBuildNumberOfLoadedDriverInterfaceLibrary );
}


/// <summary>
/// Configure the printings to the console screen according to given parameters.
/// This configuration affects this library as well as the driver-interface library.
/// No printings are made if the current user application has no console screen.
/// Only printings of a level greater/equal to given base printings level will be made.
///
/// @param bIsConsoleScreen (in)	A flag that says whether the current user application has a console screen at all
/// @param pleBasePrintingsLevel (in)	The desired base level of printings (sitalPrintingsLevel_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalStld1553_ConfigurePrintings (BOOLEAN bIsConsoleScreen, sitalPrintingsLevelEnum pleBasePrintingsLevel)
{
	/// @pseudocode

	return sitalDriverInterfaceLibrary_ConfigurePrintings (bIsConsoleScreen, pleBasePrintingsLevel);
}


/// <summary>
/// Read and return the current value of the register at given address for given device.
///
/// Note:
/// - This function actually reads given device register, not from its host image.
/// - In order to stay compatible with DDC, this function returns zero in case it encounters any kind of problem (bad parameters, any irrelevancy, operation failure).
///   That's though this way a caller, in case zero is returned, can't realize whether the target register really contains zero, or may be some problem occurred.
/// - In case given device that wasn't initialized with mode-variant sitalModeVariant_ADVANCED, given register won't be read unless given device is currently in state sitalDeviceState_READY.
///
/// Equivalent DDC definition: aceRegRead
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wRegisterAddress (in)	The address of the target register in the registers section of the device
/// @return 0x0000-0xFFFF	The current value of the given register
/// @return 0	Error condition or function failed
/// </summary>
U16BIT _DECL sitalDevice_Register_Read (S16BIT swDevice, U16BIT wRegisterAddress)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return 0U;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ( (sitalModeVariant_ADVANCED != (sitalModeVariant_ADVANCED & dsspDeviceState->wModeVariants)) && (sitalDeviceState_READY != dsspDeviceState->wCurrentState) )
	{
		return 0U;
	}

	/// Read the current value of given register.
	U16BIT wRegisterValue; // The current value of a target register, or the value to set for a target register.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, wRegisterAddress, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return 0U;
	}

	return wRegisterValue;
}


/// <summary>
/// Write given value into the register at given address for given device.
///
/// Note:
/// - If given device is currently in state sitalDeviceState_READY, this function writes given value into given register's host image, not into the real device register.
///   If given device is currently in state sitalDeviceState_RUN, this function actually writes given value into given device register, not into its host image.
/// - In case given device that wasn't initialized with mode-variant sitalModeVariant_ADVANCED, given register won't be written unless given device is currently in state sitalDeviceState_READY.
///
/// Equivalent DDC definition: aceRegWrite
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wRegisterAddress (in)	The address of the target register in the registers section of the device
/// @param wRegisterValue (in)	The value to set for given register
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalDevice_Register_Write (S16BIT swDevice, U16BIT wRegisterAddress, U16BIT wRegisterValue)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ( (sitalModeVariant_ADVANCED != (sitalModeVariant_ADVANCED & dsspDeviceState->wModeVariants)) && (sitalDeviceState_READY != dsspDeviceState->wCurrentState) )
	{
		return sitalReturnCode_INVALID_STATE;
	}

	S16BIT swResult; // Result of operation or function call.
	if (sitalDeviceState_READY == dsspDeviceState->wCurrentState)
	{
		swResult = device_Register_UpdateImage (swDevice, wRegisterAddress, (U16BIT)registerMask_ALL_BITS_ON, wRegisterValue);
	}
	else
	if (sitalDeviceState_RUN == dsspDeviceState->wCurrentState)
	{
		/// Write given register value into given register of given device.
		S16BIT swResult; // Result of operation or function call.
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, wRegisterAddress, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
	}
	else
	{
		return sitalReturnCode_INVALID_STATE;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Use the current image of the registers to actually update the registers of given device.
///
/// Note:
/// - Besides for some exceptional cases, this library actually updates device register only when a frame is run.
///   Therefore, in situations where no frame run takes place, the registers aren't really written to the device, even in case they were properly configured using this library functions.
///   This function is aimed at solving this in such situations by forcing the actual update of given device register with its currently configured value.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wRegisterAddress (in)	The address of the target register in the registers section of the device
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalDevice_Register_UpdateDevice (S16BIT swDevice, U16BIT wRegisterAddress)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((U16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalModeVariant_ADVANCED != (sitalModeVariant_ADVANCED & dsspDeviceState->wModeVariants))
	{
		return sitalReturnCode_INVALID_STATE;
	}
	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	/// Use the current image of the registers to actually adaptively update given register of given device.
	U32BIT dwRegisterOffset; // The address of a register in device memory.
	dwRegisterOffset = sitalRegisterAddress_CONFIGURATION_2;
	U16BIT wRegisterValue; // The current value of a target register, or the value to set for a target register.
	wRegisterValue = dsspDeviceState->hrsRegistersImage.waRegister[dwRegisterOffset];
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, dwRegisterOffset, sitalDeviceMemorySection_Registers, registerMask_ALL_BITS_ON, &wRegisterValue);
	return swResult;
}


/// <summary>
/// Read and return the current value of the device memory word at given address for given device.
///
/// Note:
/// - In order to stay compatible with DDC, this function returns zero in case it encounters any kind of problem (bad parameters, any irrelevancy, operation failure).
///   That's though this way a caller, in case zero is returned, can't realize whether the target register really contains zero, or may be some problem occurred.
///
/// Equivalent DDC definition: aceMemRead
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wDeviceMemoryAddress (in)	The address of the target memory word in the memory section of the device
/// @return 0x0000-0xFFFF	The current value of the given device memory word
/// @return 0	Error condition or function failed
/// </summary>
U16BIT _DECL sitalDevice_Memory_Read (S16BIT swDevice, U16BIT wDeviceMemoryAddress)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return 0U;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ( (sitalModeVariant_ADVANCED != (sitalModeVariant_ADVANCED & dsspDeviceState->wModeVariants)) && (sitalDeviceState_READY != dsspDeviceState->wCurrentState) )
	{
		return 0U;
	}

	/// Read the current value of given register.
	U16BIT wDeviceMemoryValue; // The current value of a target memory word, or the value to set for a target memory word.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, wDeviceMemoryAddress, sitalDeviceMemorySection_Ram, 1U, &wDeviceMemoryValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return 0U;
	}

	return wDeviceMemoryValue;
}


/// <summary>
/// Write given value into the memory word at given address for given device.
///
/// Equivalent DDC definition: aceMemWrite
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wDeviceMemoryAddress (in)	The address of the target memory word in the memory section of the device
/// @param wDeviceMemoryValue (in)	The value to set for given memory word
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalDevice_Memory_Write (S16BIT swDevice, U16BIT wDeviceMemoryAddress, U16BIT wDeviceMemoryValue)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ( (sitalModeVariant_ADVANCED != (sitalModeVariant_ADVANCED & dsspDeviceState->wModeVariants)) && (sitalDeviceState_READY != dsspDeviceState->wCurrentState) )
	{
		return sitalReturnCode_INVALID_STATE;
	}

	/// Write given memory value into given memory word of given device.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, wDeviceMemoryAddress, sitalDeviceMemorySection_Ram, 1U, &wDeviceMemoryValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Build and return a string in which the designated errors are textually reported.
/// If no error is designated, a null string is returned.
///
/// Note:
/// - Block status word errors are relevant only with modes BC, RT, and MT, and the interpretation of errors is mode-dependent.
/// - This function returns the same error string as the library of DDC, just without the redundant trailing space, in order to stay compatible with DDC.
/// - This function returns a pointer to a static string and not to a dynamically allocated string or a user supplied string only in order to stay
///   compatible with DDC. This behavior isn't thread safe, and in case thread-1 calls this function right after thread-0, the string that has been
///   originally returned to thread-0 is principally changed.
///
/// Equivalent DDC definition: aceGetBSWErrString
/// @param wMode (in)	Operation mode (sitalMode_*)
/// @param wBlockStatus (in)	A block status word that typically designates one or more errors (An or-ed combination of sital*BlockStatusWord_*)
/// @return A pointer to a string in which the designated errors are textually reported (an empty string is returned in case an impossible mode/status combination is given)
/// </summary>
S8BIT* _DECL sitalStld1553_GetBlockStatusWordErrorString (U16BIT wMode, U16BIT wBlockStatus)
{
	/// @pseudocode

	static const S8BIT s_szBcBlockStatusWordError[][10] =
	{
		"INVWD ",
		"INSYN ",
		"WDCNT ",
		"NOGAP ",
		"LPTST ",
		"NORES ",
		"FORMT ",
	};

	static const S8BIT s_szRtBlockStatusWordError[][10] =
	{
		"FORMT ",
		"NORES ",
		"LPTST ",
		"ILCMD ",
		"WDCNT ",
		"INSYN ",
		"INVWD ",
		"RTRTG ",
		"RTRTC ",
		"CMDER "
	};

	static const S8BIT s_szMtBlockStatusWordError[][10] =
	{
		"FORMT ",
		"NORES ",
		"WDCNT ",
		"INSYN ",
		"INVWD ",
		"RTRTG ",
		"RTRTC ",
		"CMDER "
	};

	/// Create an empty error string.
	static S8BIT szBlockStatusWordErrorString[256];
	(*szBlockStatusWordErrorString) = '\0';

	/// If block status word is relevant with given mode:
	///		If given block status word designates any error:
	///			Translate given block status word into an error string.
	char* cp; // A pointer to a character.
	switch (wMode)
	{
	case sitalMode_BC:
		if ((U16BIT)0U != ((U16BIT)sitalBcBlockStatusWord_ERROR_FLAG & wBlockStatus))
		{
			if ((U16BIT)0U != ((U16BIT)sitalBcBlockStatusWord_INVALID_WORD & wBlockStatus))
			{
				cp = strcat (szBlockStatusWordErrorString, s_szBcBlockStatusWordError[0]);
			}
			if ((U16BIT)0U != ((U16BIT)sitalBcBlockStatusWord_BAD_SYNCHRONIZATION & wBlockStatus))
			{
				cp = strcat (szBlockStatusWordErrorString, s_szBcBlockStatusWordError[1]);
			}
			if ((U16BIT)0U != ((U16BIT)sitalBcBlockStatusWord_WORD_COUNT_ERROR & wBlockStatus))
			{
				cp = strcat (szBlockStatusWordErrorString, s_szBcBlockStatusWordError[2]);
			}
			if ((U16BIT)0U != ((U16BIT)sitalBcBlockStatusWord_WRONG_RT_ADDRESS & wBlockStatus))
			{
				cp = strcat (szBlockStatusWordErrorString, s_szBcBlockStatusWordError[3]);
			}
			if ((U16BIT)0U != ((U16BIT)sitalBcBlockStatusWord_LOOPBACK_FAIL & wBlockStatus))
			{
				cp = strcat (szBlockStatusWordErrorString, s_szBcBlockStatusWordError[4]);
			}
			if ((U16BIT)0U != ((U16BIT)sitalBcBlockStatusWord_NO_RESPONSE & wBlockStatus))
			{
				cp = strcat (szBlockStatusWordErrorString, s_szBcBlockStatusWordError[5]);
			}
			if ((U16BIT)0U != ((U16BIT)sitalBcBlockStatusWord_FORMAT_ERROR & wBlockStatus))
			{
				cp = strcat (szBlockStatusWordErrorString, s_szBcBlockStatusWordError[6]);
			}
		}
		break;
	case sitalMode_RT:
		if ((U16BIT)0U != ((U16BIT)sitalRtBlockStatusWord_ERROR_FLAG & wBlockStatus))
		{
			if ((U16BIT)0U != ((U16BIT)sitalRtBlockStatusWord_FORMAT_ERROR & wBlockStatus))
			{
				cp = strcat (szBlockStatusWordErrorString, s_szRtBlockStatusWordError[0]);
			}
			if ((U16BIT)0U != ((U16BIT)sitalRtBlockStatusWord_NO_RESPONSE & wBlockStatus))
			{
				cp = strcat (szBlockStatusWordErrorString, s_szRtBlockStatusWordError[1]);
			}
			if ((U16BIT)0U != ((U16BIT)sitalRtBlockStatusWord_LOOPBACK_FAIL & wBlockStatus))
			{
				cp = strcat (szBlockStatusWordErrorString, s_szRtBlockStatusWordError[2]);
			}
			if ((U16BIT)0U != ((U16BIT)sitalRtBlockStatusWord_ILLEGAL_COMMAND & wBlockStatus))
			{
				cp = strcat (szBlockStatusWordErrorString, s_szRtBlockStatusWordError[3]);
			}
			if ((U16BIT)0U != ((U16BIT)sitalRtBlockStatusWord_WORD_COUNT_ERROR & wBlockStatus))
			{
				cp = strcat (szBlockStatusWordErrorString, s_szRtBlockStatusWordError[4]);
			}
			if ((U16BIT)0U != ((U16BIT)sitalRtBlockStatusWord_BAD_SYNCHRONIZATION & wBlockStatus))
			{
				cp = strcat (szBlockStatusWordErrorString, s_szRtBlockStatusWordError[5]);
			}
			if ((U16BIT)0U != ((U16BIT)sitalRtBlockStatusWord_INVALID_WORD & wBlockStatus))
			{
				cp = strcat (szBlockStatusWordErrorString, s_szRtBlockStatusWordError[6]);
			}
			if ((U16BIT)0U != ((U16BIT)sitalRtBlockStatusWord_RT_TO_RT_RESPONSE_ERROR & wBlockStatus))
			{
				cp = strcat (szBlockStatusWordErrorString, s_szRtBlockStatusWordError[7]);
			}
			if ((U16BIT)0U != ((U16BIT)sitalRtBlockStatusWord_RT_TO_RT_COMMAND_ERROR & wBlockStatus))
			{
				cp = strcat (szBlockStatusWordErrorString, s_szRtBlockStatusWordError[8]);
			}
			if ((U16BIT)0U != ((U16BIT)sitalRtBlockStatusWord_COMMAND_ERROR & wBlockStatus))
			{
				cp = strcat (szBlockStatusWordErrorString, s_szRtBlockStatusWordError[9]);
			}
		}
		break;
	case sitalMode_MT:
		if ((U16BIT)0U != ((U16BIT)sitalMtBlockStatusWord_ERROR_FLAG & wBlockStatus))
		{
			if ((U16BIT)0U != ((U16BIT)sitalMtBlockStatusWord_PROTOCOL_VIOLATION & wBlockStatus))
			{
				cp = strcat (szBlockStatusWordErrorString, s_szMtBlockStatusWordError[0]);
			}
			if ((U16BIT)0U != ((U16BIT)sitalMtBlockStatusWord_NO_RESPONSE & wBlockStatus))
			{
				cp = strcat (szBlockStatusWordErrorString, s_szMtBlockStatusWordError[1]);
			}
			if ((U16BIT)0U != ((U16BIT)sitalMtBlockStatusWord_WORD_COUNT_ERROR & wBlockStatus))
			{
				cp = strcat (szBlockStatusWordErrorString, s_szMtBlockStatusWordError[2]);
			}
			if ((U16BIT)0U != ((U16BIT)sitalMtBlockStatusWord_BAD_SYNCHRONIZATION & wBlockStatus))
			{
				cp = strcat (szBlockStatusWordErrorString, s_szMtBlockStatusWordError[3]);
			}
			if ((U16BIT)0U != ((U16BIT)sitalMtBlockStatusWord_INVALID_WORD & wBlockStatus))
			{
				cp = strcat (szBlockStatusWordErrorString, s_szMtBlockStatusWordError[4]);
			}
			if ((U16BIT)0U != ((U16BIT)sitalMtBlockStatusWord_RT_TO_RT_RESPONSE_ERROR & wBlockStatus))
			{
				cp = strcat (szBlockStatusWordErrorString, s_szMtBlockStatusWordError[5]);
			}
			if ((U16BIT)0U != ((U16BIT)sitalMtBlockStatusWord_RT_TO_RT_COMMAND_ERROR & wBlockStatus))
			{
				cp = strcat (szBlockStatusWordErrorString, s_szMtBlockStatusWordError[6]);
			}
			if ((U16BIT)0U != ((U16BIT)sitalMtBlockStatusWord_COMMAND_ERROR & wBlockStatus))
			{
				cp = strcat (szBlockStatusWordErrorString, s_szMtBlockStatusWordError[7]);
			}
		}
		break;
	default:
		// Irrelevant mode.
		break;
	}

	/// If any error was found:
	///		Remove the redundant trailing space character.
	U32BIT dwBlockStatusWordErrorStringLength; // The length of the block status word error string.
	dwBlockStatusWordErrorStringLength = strlen (szBlockStatusWordErrorString);
	if (0U < dwBlockStatusWordErrorStringLength )
	{
		szBlockStatusWordErrorString[dwBlockStatusWordErrorStringLength - 1U] = '\0';
	}

	return (S8BIT*)szBlockStatusWordErrorString;
}


/// <summary>
/// Return a string that describes given return code.
///
/// Note:
/// - Given return code may be either an error code, a warning code, or a notification code.
/// - If given return code code isn't recognized, a suitable notification string is returned, and the function reports success.
///
/// Equivalent DDC definition: aceErrorStr
/// @param swError (in)	Error code (sitalReturnCode_*)
/// @param szpErrorString (out)	A pointer to a string buffer in which a null-terminated string that describes given error code is returned
/// @param wMaximumStringLength (in) The size of the buffer in which the error string is returned, including the terminating null character (>=80)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalStld1553_GetReturnCodeDescriberString (S16BIT swError, S8BIT* szpErrorString, U16BIT wMaximumStringLength)
{
	if (((S8BIT*)NULL) == szpErrorString)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if (80U > wMaximumStringLength)
	{
		return sitalReturnCode_INVALID_BUFFER;
	}

	int iResult; // The value returned by function sprintf.
	switch (swError)
	{
	case sitalReturnCode_SUCCESS: iResult = sprintf (szpErrorString, "No error"); break;
	case sitalReturnCode_POSSIBLY_DETRIMENTAL_CONFIGURATION: iResult = sprintf (szpErrorString, "A possibly detrimental configuration"); break;
	case sitalReturnCode_UNKNOWN_ERROR: iResult = sprintf (szpErrorString, "Unknown error"); break;
	case sitalReturnCode_VERSION_ERROR: iResult = sprintf (szpErrorString, "Fail to get version number"); break;
	case sitalReturnCode_LIBRARY_LOAD_ERROR: iResult = sprintf (szpErrorString, "Fail to load library"); break;
	case sitalReturnCode_INVALID_DEVICE_NUMBER: iResult = sprintf (szpErrorString, "Invalid device number"); break;
	case sitalReturnCode_INVALID_ACCESS: iResult = sprintf (szpErrorString, "Invalid access type"); break;
	case sitalReturnCode_INVALID_MODE: iResult = sprintf (szpErrorString, "Invalid mode of operation"); break;
	case sitalReturnCode_INVALID_STATE: iResult = sprintf (szpErrorString, "Invalid device state"); break;
	case sitalReturnCode_INVALID_MEMORY_SIZE: iResult = sprintf (szpErrorString, "Invalid size of memory"); break;
	case sitalReturnCode_INVALID_ADDRESS: iResult = sprintf (szpErrorString, "Invalid device memory or register address"); break;
	case sitalReturnCode_INVALID_OPERATING_SYSTEM: iResult = sprintf (szpErrorString, "Invalid operating system"); break;
	case sitalReturnCode_INVALID_ALLOCATION: iResult = sprintf (szpErrorString, "Invalid allocation"); break;
	case sitalReturnCode_INVALID_BUFFER: iResult = sprintf (szpErrorString, "Invalid buffer"); break;
	case sitalReturnCode_INVALID_ADDRESS_MODE: iResult = sprintf (szpErrorString, "Invalid address mode"); break;
	case sitalReturnCode_INVALID_REGISTER_ADDRESS: iResult = sprintf (szpErrorString, "Invalid register address"); break;
	case sitalReturnCode_INVALID_TIME_TAG_RESOLUTION: iResult = sprintf (szpErrorString, "Invalid time tag resolution"); break;
	case sitalReturnCode_INVALID_RESPONSE_TIMEOUT: iResult = sprintf (szpErrorString, "Invalid response timeout"); break;
	case sitalReturnCode_INVALID_CLOCK_FREQUENCY: iResult = sprintf (szpErrorString, "Invalid clock frequency"); break;
	case sitalReturnCode_INVALID_MESSAGE_STRUCTURE: iResult = sprintf (szpErrorString, "Invalid message structure"); break;
	case sitalReturnCode_INVALID_PARAMETER: iResult = sprintf (szpErrorString, "Invalid parameter"); break;
	case sitalReturnCode_INVALID_MODE_OPTIONS: iResult = sprintf (szpErrorString, "Invalid mode options"); break;
	case sitalReturnCode_OPERATIONAL_STATISTICS_NOT_ENABLED: iResult = sprintf (szpErrorString, "Operational statistics collection not enabled"); break;
	case sitalReturnCode_NOT_SUPPORTED: iResult = sprintf (szpErrorString, "Not supported"); break;
	case sitalReturnCode_ISQ_DISABLED: iResult = sprintf (szpErrorString, "ISQ disabled"); break;
	case sitalReturnCode_OPERATION_FAIL: iResult = sprintf (szpErrorString, "Operation fail"); break;
	case sitalReturnCode_INVALID_CAN_ADDRESS: iResult = sprintf (szpErrorString, "Invalid CAN bus address"); break;
	case sitalReturnCode_INVALID_DIO_PORT: iResult = sprintf (szpErrorString, "Invalid discrete I/O port"); break;
	case sitalReturnCode_REGISTERS_ACCESS_FAIL: iResult = sprintf (szpErrorString, "Fail to access device registers"); break;
	case sitalReturnCode_INVALID_CARD: iResult = sprintf (szpErrorString, "Invalid card"); break;
	case sitalReturnCode_DRIVER_OPEN_FAIL: iResult = sprintf (szpErrorString, "Fail to open device driver"); break;
	case sitalReturnCode_MAPPED_MEMORY_ACCESS_FAIL: iResult = sprintf (szpErrorString, "Fail to access mapped memory"); break;
	case sitalReturnCode_INVALID_CARD_NUMBER: iResult = sprintf (szpErrorString, "Invalid card number"); break;
	case sitalReturnCode_UNDEFINED_NODE: iResult = sprintf (szpErrorString, "Undefined node"); break;
	case sitalReturnCode_NODE_NOT_MEMORY_BLOCK: iResult = sprintf (szpErrorString, "Node is not a memory block node"); break;
	case sitalReturnCode_NODE_EXISTS: iResult = sprintf (szpErrorString, "Node already exists"); break;
	case sitalReturnCode_ALLOCATION_FAIL: iResult = sprintf (szpErrorString, "Allocation fail"); break;
	case sitalReturnCode_INVALID_TEST_STRUCTURE: iResult = sprintf (szpErrorString, "Invalid test result structure"); break;
	case sitalReturnCode_INVALID_FILE: iResult = sprintf (szpErrorString, "Invalid file"); break;
	case sitalReturnCode_MT_INVALID_STACK_OPTION: iResult = sprintf (szpErrorString, "Invalid MT stack option"); break;
	case sitalReturnCode_MT_INVALID_COMMAND_STACK_SIZE: iResult = sprintf (szpErrorString, "Invalid size of MT command stack"); break;
	case sitalReturnCode_MT_INVALID_DATA_STACK_SIZE: iResult = sprintf (szpErrorString, "Invalid size of MT data stack"); break;
	case sitalReturnCode_MT_INVALID_RT_ADDRESS: iResult = sprintf (szpErrorString, "Invalid RT address"); break;
	case sitalReturnCode_MT_INVALID_DIRECTION_BIT: iResult = sprintf (szpErrorString, "Invalid direction (Rx-Tx) bit"); break;
	case sitalReturnCode_MT_INVALID_SUBADDRESS_BUFFER: iResult = sprintf (szpErrorString, "Invalid subaddress buffer"); break;
	case sitalReturnCode_MT_INVALID_STACK_SELECTOR: iResult = sprintf (szpErrorString, "Invalid MT stack selector"); break;
	case sitalReturnCode_MT_INVALID_MESSAGE_LOCATION: iResult = sprintf (szpErrorString, "Invalid MT message location"); break;
	case sitalReturnCode_MT_INVALID_HOST_BUFFER_SIZE: iResult = sprintf (szpErrorString, "Invalid size of MT host buffer"); break;
	case sitalReturnCode_MT_HOST_BUFFER_NOT_INSTALLED: iResult = sprintf (szpErrorString, "MT host buffer not allocated"); break;
	case sitalReturnCode_RT_AND_MT_NON_COMBINED_HOST_BUFFER_MODE: iResult = sprintf (szpErrorString, "RT-MT host buffer used"); break;
	case sitalReturnCode_RT_AND_MT_INVALID_HOST_BUFFER_SIZE: iResult = sprintf (szpErrorString, "Invalid size of RT-MT host buffer"); break;
	case sitalReturnCode_RT_AND_MT_HOST_BUFFER_NOT_INSTALLED: iResult = sprintf (szpErrorString, "RT-MT host buffer not allocated"); break;
	case sitalReturnCode_RT_AND_MT_INVALID_MESSAGE_LOCATION: iResult = sprintf (szpErrorString, "Invalid RT-MT message location"); break;
	case sitalReturnCode_RT_DATA_BLOCK_EXISTS: iResult = sprintf (szpErrorString, "RT data block already exists"); break;
	case sitalReturnCode_RT_DATA_BLOCK_ALLOCATION_FAIL: iResult = sprintf (szpErrorString, "RT data block allocation fail"); break;
	case sitalReturnCode_RT_DATA_BLOCK_MAPPED: iResult = sprintf (szpErrorString, "RT data block already mapped"); break;
	case sitalReturnCode_RT_DATA_BLOCK_NOT_CIRCULAR: iResult = sprintf (szpErrorString, "RT data block is not circular"); break;
	case sitalReturnCode_RT_HOST_BUFFER_NOT_INSTALLED: iResult = sprintf (szpErrorString, "RT host buffer not initialized"); break;
	case sitalReturnCode_BC_OBJECT_ALREADY_EXISTS: iResult = sprintf (szpErrorString, "BC object already exists"); break;
	case sitalReturnCode_BC_DATA_BLOCK_ALLOCATION_FAIL: iResult = sprintf (szpErrorString, "BC data block allocation fail"); break;
	case sitalReturnCode_BC_INVALID_DATA_BLOCK_SIZE: iResult = sprintf (szpErrorString, "Invalid size of BC data stack"); break;
	case sitalReturnCode_UNDEFINED_DATA_BLOCK: iResult = sprintf (szpErrorString, "Undefined data block"); break;
	case sitalReturnCode_UNDEFINED_MESSAGE_BLOCK: iResult = sprintf (szpErrorString, "Undefined message block"); break;
	case sitalReturnCode_ILLEGAL_FRAME: iResult = sprintf (szpErrorString, "Illegal frame"); break;
	case sitalReturnCode_UNDEFINED_COMMAND: iResult = sprintf (szpErrorString, "Undefined command"); break;
	case sitalReturnCode_UNRESOLVED_JUMP: iResult = sprintf (szpErrorString, "Cannot resolve illegal jump command"); break;
	case sitalReturnCode_NOT_MAJOR_FRAME: iResult = sprintf (szpErrorString, "Not a major frame"); break;
	case sitalReturnCode_SUITABLE_ASYNCHRONOUS_MODE_UNDEFINED: iResult = sprintf (szpErrorString, "Suitable asynchronous mode is not defined"); break;
	case sitalReturnCode_UNRESOLVED_ASYNCHRONOUS_COMMAND: iResult = sprintf (szpErrorString, "Cannot resolve undefined asynchronous command"); break;
	case sitalReturnCode_ASYNCHRONOUS_LIST_IS_EMPTY: iResult = sprintf (szpErrorString, "The list of low-priority asynchronous messages is empty"); break;
	case sitalReturnCode_ASYNCHRONOUS_LIST_NOT_EMPTY: iResult = sprintf (szpErrorString, "The list of low-priority asynchronous messages is not empty"); break;
	case sitalReturnCode_ASYNCHRONOUS_MESSAGE_ERROR: iResult = sprintf (szpErrorString, "Asynchronous message error"); break;
	case sitalReturnCode_MESSAGE_ERROR: iResult = sprintf (szpErrorString, "Message error"); break;
	case sitalReturnCode_ASYNCHRONOUS_SUBROUTINE_BUSY: iResult = sprintf (szpErrorString, "The asynchronous message Tx subroutine is now executed"); break;
	case sitalReturnCode_BC_POSSIBLY_DETRIMENTAL_OPCODE: iResult = sprintf (szpErrorString, "A possibly detrimental opcode"); break;
	case sitalReturnCode_INVALID_HOST_BUFFER_SIZE: iResult = sprintf (szpErrorString, "Invalid size of host buffer"); break;
	case sitalReturnCode_HOST_BUFFER_NOT_INSTALLED: iResult = sprintf (szpErrorString, "Host buffer not initialized"); break;
	case sitalReturnCode_TOO_MANY_DEVICES: iResult = sprintf (szpErrorString, "Too many devices"); break;
	case sitalReturnCode_DEVICE_CONNECTION_FAIL: iResult = sprintf (szpErrorString, "Device connection fail"); break;
	case sitalReturnCode_WRITE_ERROR: iResult = sprintf (szpErrorString, "Device write fail"); break;
	case sitalReturnCode_READ_ERROR: iResult = sprintf (szpErrorString, "Device read fail"); break;
	case sitalReturnCode_MEMORY_MAP_FAIL: iResult = sprintf (szpErrorString, "Memory mapping fail"); break;
	case sitalReturnCode_TASK_SPAWN_FAIL: iResult = sprintf (szpErrorString, "Task spawn fail"); break;
	case sitalReturnCode_INVALID_MESSAGE_TYPE: iResult = sprintf (szpErrorString, "Invalid type of message"); break;
	case sitalReturnCode_INVALID_RT_ADDRESS: iResult = sprintf (szpErrorString, "Invalid RT address"); break;
	case sitalReturnCode_INVALID_DIRECTION_BIT: iResult = sprintf (szpErrorString, "Invalid direction (Rx-Tx) bit"); break;
	case sitalReturnCode_INVALID_SUBADDRESS_OR_MODE_SELECTOR: iResult = sprintf (szpErrorString, "Invalid subaddress-or-mode selector"); break;
	case sitalReturnCode_INVALID_WORD_COUNT_OR_MODE_CODE: iResult = sprintf (szpErrorString, "Invalid word-count or mode-code"); break;
	case sitalReturnCode_INVALID_MESSAGE_OPTIONS: iResult = sprintf (szpErrorString, "Invalid message options"); break;
	case sitalReturnCode_FRAME_NESTING_STACK_OVERFLOW: iResult = sprintf (szpErrorString, "Frame nesting goes too deep"); break;
	case sitalReturnCode_NESTED_MAJOR_FRAME: iResult = sprintf (szpErrorString, "Nested major frame"); break;
	case sitalReturnCode_FRAME_NESTING_RECURSION: iResult = sprintf (szpErrorString, "Frame nesting recursion"); break;
	case sitalReturnCode_MESSAGE_NOT_DETECTED: iResult = sprintf (szpErrorString, "Message not detected"); break;
	case sitalReturnCode_TEST_FAIL: iResult = sprintf (szpErrorString, "Test fail"); break;
	case sitalReturnCode_LIMITED_DEVICE: iResult = sprintf (szpErrorString, "Limited device"); break;
	case sitalReturnCode_DEVICE_BUSY: iResult = sprintf (szpErrorString, "Device is BUSY"); break;
	default: iResult = sprintf (szpErrorString, "Unrecognized error code"); break;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Build and return a text string describing given message type.
///
/// Note:
/// - This function returns a pointer to a static string and not to a dynamically allocated string or a user supplied string only in order to stay
///   compatible with DDC. This behavior isn't thread safe, and in case thread-1 calls this function right after thread-0, the string that has been
///   originally returned to thread-0 is principally changed.
///
/// Equivalent DDC definition: aceGetMsgTypeString
/// @param wMessageType (in)	Operation mode (sitalMessageType_*)
/// @return A pointer to a string in which the designated errors are textually reported (an empty string is returned in case an impossible mode/status combination is given)
/// </summary>
S8BIT* _DECL sitalStld1553_GetMessageTypeString (U16BIT wMessageType)
{
	/// @pseudocode

	static const S8BIT s_szMessageType[][25] =
	{
		"BC to RT",
		"RT to BC",
		"RT to RT",
		"Invalid message type",
		"Invalid message type",
		"Mode no data",
		"Mode Rx data",
		"Mode Tx data",
		"Broadcast",
		"Invalid message type",
		"Broadcast RT to RT",
		"Invalid message type",
		"Invalid message type",
		"Broadcast mode no data",
		"Broadcast mode data",
		"Invalid message type",
	};

	if (messageType_BORDER <= wMessageType)
	{
		wMessageType = (messageType_BORDER - 1U);
	}

	return (S8BIT*)s_szMessageType[wMessageType];
}


/// <summary>
/// Create a suitable IEEE-1553 command word based on given parameters.
///
/// Equivalent DDC definition: aceCmdWordCreate
/// @param wpCommandWord (out)	A pointer to a variable in which requested command word is returned
/// @param wRtAddress (in)	A RT address (sitalRtAddress_0-sitalRtAddress_31 or sital1553_BROADCAST)
/// @param wMessageDirection (in)	RT-related message direction (sitalMessageDirection_RX or sitalMessageDirection_TX)
/// @param wSubaddressOrMode (in)	Subaddress/mode selector (subaddress: sitalRtSubaddress_1-sitalRtSubaddress_30; mode: sital1553_MODE_CODE1/sital1553_MODE_CODE2)
/// @param wWordCountOrModeCode (in)	Word-count/mode-word, depending whether regular/mode command, respectively (word-count: 1-32; mode-word: 1-32)
/// @param wWordCount (in)	Word count (1-32)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBcStld1553_Command_GetCode (	U16BIT* wpCommandWord,
												U16BIT wRtAddress,
												U16BIT wMessageDirection,
												U16BIT wSubaddressOrMode,
												U16BIT wWordCountOrModeCode)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((U16BIT*)NULL) == wpCommandWord)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}
	if ((0U > wRtAddress) || (rtAddress_BORDER <= wRtAddress))
	{
		return sitalReturnCode_INVALID_RT_ADDRESS;
	}
	if ((0U > wMessageDirection) || (messageDirection_BORDER <= wMessageDirection))
	{
		return sitalReturnCode_INVALID_DIRECTION_BIT;
	}
	if ((0U > wSubaddressOrMode) || (ieee1553_SUBADDRESS_BORDER <= wSubaddressOrMode))
	{
		return sitalReturnCode_INVALID_SUBADDRESS_OR_MODE_SELECTOR;
	}
	if ((0U > wWordCountOrModeCode) || (ieee1553_WORD_COUNT_OR_MODE_BORDER < wWordCountOrModeCode))
	{
		return sitalReturnCode_INVALID_WORD_COUNT_OR_MODE_CODE;
	}

	/// If given word-count is 32:
	///		Turn the word-count to 0.
	wWordCountOrModeCode &= commandWord_WORD_COUNT_OR_MODE_CODE;

	/// Use given message descriptors in order to code a command word.
	(*wpCommandWord) = ((wRtAddress << commandWord_OFFSET_OF_RT_ADDRESS) | (wMessageDirection << commandWord_OFFSET_OF_RX_OR_TX) | (wSubaddressOrMode << commandWord_OFFSET_OF_SUBADDRESS_OR_MODE) | (wWordCountOrModeCode << commandWord_OFFSET_OF_WORD_COUNT_OR_MODE_CODE));

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Parse given IEEE-1553 command word.
///
/// Equivalent DDC definition: aceCmdWordParse
/// @param wCommandWord (in)	Command word
/// @param wpRtAddress (out)	A pointer to a variable in which the parsed RT address is returned as sitalRtAddress_0-sitalRtAddress_31
/// @param wpMessageDirection (out)	A pointer to a variable in which the parsed RT-related message direction is returned as sitalMessageDirection_RX or sitalMessageDirection_TX
/// @param wpSubaddressOrMode (out)	A pointer to a variable in which the parsed subaddress/mode selector is returned as sitalRtSubaddress_0-sitalRtSubaddress_31
/// @param wpWordCountOrModeCode (out)	A pointer to a variable in which the parsed word-count/mode-word, depending whether regular/mode command, respectively, is returned as 0-31
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBcStld1553_Command_Parse (	U16BIT wCommandWord,
												U16BIT* wpRtAddress,
												U16BIT* wpMessageDirection,
												U16BIT* wpSubaddressOrMode,
												U16BIT* wpWordCountOrModeCode)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if ( (((U16BIT*)NULL) == wpRtAddress) || (((U16BIT*)NULL) == wpMessageDirection) || (((U16BIT*)NULL) == wpSubaddressOrMode) || (((U16BIT*)NULL) == wpWordCountOrModeCode) )
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Parse given command word into required output message qualifiers.
	(*wpRtAddress) = (((U16BIT)commandWord_RT_ADDRESS & wCommandWord) >> commandWord_OFFSET_OF_RT_ADDRESS);
	(*wpMessageDirection) = (((U16BIT)commandWord_RX_OR_TX & wCommandWord) >> commandWord_OFFSET_OF_RX_OR_TX);
	(*wpSubaddressOrMode) = (((U16BIT)commandWord_SUBADDRESS_OR_MODE & wCommandWord) >> commandWord_OFFSET_OF_SUBADDRESS_OR_MODE);
	(*wpWordCountOrModeCode) = (((U16BIT)commandWord_WORD_COUNT_OR_MODE_CODE & wCommandWord) >> commandWord_OFFSET_OF_WORD_COUNT_OR_MODE_CODE);

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Initialize hardware & software resources (i.e., memory and register space) of given device for a given mode of operation.
/// Access modes:
/// - Card memory:
///   The card of target device is accessed using the device driver.
/// - Simulated memory:
///   A 64K or 4K chunk of host memory is allocated and manipulated as if it were hardware memory.
///   In this mode the user can produce a binary image file, but cannot actually run a frame.
///   This mode isn't supported currently.
/// - User memory:
///   Memory and register addresses are passed to the library.
///   This mode isn't supported currently.
///
/// Note:
/// - This function may be also used to reinitialize a device.
///   In such case all the data blocks, messages, commands, and frames that have been previously defined for this device will be deleted.
/// - Given device is initialized in given mode, but with default options.
///   In order to configure the device with specifically required options, after this function successfully completes,
///   call the suitable sital*_Initialize function, where '*' = Bc/Rt/Mt/RtMt, according to given mode.
/// - In order for a device to be supported, the total size of its memory must stand the following conditions:
///   - BC, RT, MT: Between sitalMinimum_SIZE_OF_DEVICE_MEMORY and sitalMaximum_SIZE_OF_DEVICE_MEMORY.
///   - RT&MT: Between sitalMinimum_SIZE_OF_RT_AND_MT_DEVICE_MEMORY and sitalMaximum_SIZE_OF_DEVICE_MEMORY.
///   - Any kind of device: A product of sitalMinimum_SIZE_OF_DEVICE_MEMORY by a power of 2.
/// - This function sets given device to the following default configuration:
///   - All devices (sitalMode_*):
///     - Interrupts: sitalIrqMode_LEVEL, sitalIrqClear_NO_AUTO_CLEAR
///     - Clock frequency: sitalClockSetup_16MHZ
///     - Decoder: sitalInputDevice_DoubleEnded, sitalExpendedXing_Enable
///     - Response timeout: sitalResponseTimeout_18US
///     - Time tag resolution: sitalTimeTagResolution_2US
///     - RAM parity check: sitalRamParityCheck_DISABLE
///   - RT devices (sitalMode_RT):
///     - Messages are illegalized for all address type, direction, subaddress, and word-count-or-mode-code combinations.
///       To legalize a specific combination, either of the following functions may be used, as appropriate: sitalRt_DataBlock_MapToSubaddress, sitalRt_MessageLegality_Enable.
///     - Size of command stack (in words) vs. total size of device memory (in words): >=65536/2048, >=32768/1024, >=16384/512, >=2048/256
///   - MT devices (sitalMode_MT):
///     - Message monitoring enabled for: sitalRtAddress_ALL, sitalMessageDirection_BOTH, sitalRtSubaddressMask_ALL.
///     - Stacks:
///       - Single pair of stacks, i.e., a single data stack and a single command stack (sitalMtStackOption_SINGLE).
///       - Size of data stack (in words) vs. total size of device memory (in words): >=65536/32768, >=32768/16384, >=16384/8192, >=8192/4096, >=4096/2048, >=2048/1024
///       - Size of command stack (in words) vs. total size of device memory (in words): >=65536/16384, >=16384/4096, >=8192/1024, >=4096/1024, >=2048/256
///   - RT&MT devices (sitalMode_RT_AND_MT):
///     - Messages are illegalized for all address type, direction, subaddress, and word-count-or-mode-code combinations.
///       To legalize a specific combination, either of the following functions may be used, as appropriate: sitalRt_DataBlock_MapToSubaddress, sitalRt_MessageLegality_Enable.
///     - Message monitoring enabled for: sitalRtAddress_ALL, sitalMessageDirection_BOTH, sitalRtSubaddressMask_ALL.
///     - Stacks:
///       - Size of RT command stack (in words) vs. total size of device memory (in words): >=65536/2048, >=32768/1024, >=16384/512, >=2048/256
///       - Single pair of MT stacks, i.e., a single MT data stack and a single MT command stack (sitalMtStackOption_SINGLE).
///       - Size of MT data stack (in words) vs. total size of device memory (in words): >=65536/32768, >=32768/16384, >=16384/8192, >=8192/4096, >=4096/1024
///       - Size of MT command stack (in words) vs. total size of device memory (in words): >=65536/16384, >=16384/4096, >=8192/1024, >=4096/256
///
/// Equivalent DDC definition: aceInitialize
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wAccess (in)	Type of device access (sitalAccess_*)
/// @param wMode (in)	Operation mode (any specific sitalMode_* or-ed with an or-ed combination of sitalModeVariant_*)
/// @param dwSizeOfAllocatedMemory (in)	Size of memory (unused)
/// @param dwRegistersAddress (in)	Base address for registers (unused)
/// @param dwMemoryAddress (in)	Base address for memory (unused)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalDevice_Initialize (	S16BIT swDevice,
										U16BIT wAccess,
										U16BIT wMode,
										U32BIT dwSizeOfAllocatedMemory,
										U32BIT dwRegistersAddress,
										U32BIT dwMemoryAddress)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	if (access_BORDER <= wAccess)
	{
		return sitalReturnCode_INVALID_ACCESS;
	}
	if (sitalAccess_CARD != wAccess)
	{
		return sitalReturnCode_INVALID_ACCESS;
	}

	U16BIT wBaseMode = ((U16BIT)mode_BASE & wMode); // Base mode isolated from mode variants.
	U16BIT wModeVariants = ((U16BIT)mode_VARIANT & wMode); // Mode variants isolated from basic mode.
	if (mode_BORDER <= wBaseMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}
	if (mode_BORDER <= wBaseMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}
	if (modeVariant_BORDER <= wModeVariants)
	{
		return sitalReturnCode_INVALID_MODE_OPTIONS;
	}
	if ((sitalMode_TEST == wBaseMode) && (sitalModeVariant_NONE != wModeVariants) && (sitalModeVariant_ADVANCED != wModeVariants))
	{
		return sitalReturnCode_INVALID_MODE_OPTIONS;
	}

	/// If given device wasn't opened yet:
	///		Open it.
	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	S16BIT swResult; // Result of operation or function call.
	if (FALSE == dsspDeviceState->bIsOpened)
	{
		dsspDeviceState->dcsDeviceCapabilities.dwStructureSize = sizeof(sitalDeviceCapabilitiesStructure);
		swResult = sitalDevice_Open (swDevice, &(dsspDeviceState->dcsDeviceCapabilities));
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
		if	(
					((sitalMode_RT_AND_MT == wBaseMode) && (sitalMinimum_SIZE_OF_RT_AND_MT_DEVICE_MEMORY > dsspDeviceState->dcsDeviceCapabilities.dwRamSize))
				||
					((sitalMode_RT_AND_MT != wBaseMode) && (sitalMinimum_SIZE_OF_DEVICE_MEMORY > dsspDeviceState->dcsDeviceCapabilities.dwRamSize))
				||
					(sitalMaximum_SIZE_OF_DEVICE_MEMORY < dsspDeviceState->dcsDeviceCapabilities.dwRamSize)
			)
		{
			return sitalReturnCode_INVALID_MEMORY_SIZE;
		}
		U32BIT dwNextRamSize; // The next accepted size (in words) of the RAM memory section of given device.
		dwNextRamSize = sitalMinimum_SIZE_OF_DEVICE_MEMORY;
		while ((sitalMaximum_SIZE_OF_DEVICE_MEMORY >= dwNextRamSize) && (dwNextRamSize != dsspDeviceState->dcsDeviceCapabilities.dwRamSize))
		{
			dwNextRamSize <<= 1;
		}
		if (sitalMaximum_SIZE_OF_DEVICE_MEMORY < dwNextRamSize)
		{
			return sitalReturnCode_INVALID_MEMORY_SIZE;
		}

		dsspDeviceState->bIsOpened = TRUE;
	}

	/// Actually reset given device, and properly update its state.
	swResult = device_Reset (swDevice);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		S16BIT swUnusedResult; // Result of operation or function call.
		swUnusedResult = sitalDevice_Free (swDevice);
		return swResult;
	}

	/// Configure the properties of given device.
	dsspDeviceState->wAccess = wAccess;
	dsspDeviceState->wMode = wBaseMode;
	dsspDeviceState->wModeVariants = wModeVariants;
	dsspDeviceState->bIsOperationalStatisticsCollected = FALSE;
	dsspDeviceState->bIsProtocol1553aSupported = FALSE;
	dsspDeviceState->dwInternalImr = 0U;
	dsspDeviceState->dwExternalImr = 0U;
	dsspDeviceState->funcpUserIsr = ((USER_ISR_FUNCTION)NULL);
	dsspDeviceState->funcpAsynchronousMessagesIsr = ((ASYNCHRONOUS_MESSAGE_ISR_FUNCTION)NULL);

	memset (dsspDeviceState->hrsRegistersImage.waRegister, 0, (sitalRegisterAddress_BORDER << 1U));

	// Now that given device is reset and its properties initialized:
	/// Sign given device as ready.
	//swResult = sitalProcess_Log_PrintLine ("#StldDll.Device.State.Change: device - %i, old - %i, new - %i\n", swDevice, dsspDeviceState->wCurrentState, sitalDeviceState_READY);
	dsspDeviceState->wCurrentState = sitalDeviceState_READY;

	/// Reset the host buffer state information of given device.
	/// Configure the device into the desired operation mode with a default configuration that suits the available size of device memory.
	// Note: The size of the stacks that are allocated by default for an initialized RT, MT, or RT&MT device are listed in the documentation of this function.
	U16BIT wRtCommandStackSize; // The selected size of command stack (sitalRtCommandStackSize_*).
	U16BIT wMtCommandStackSize; // The selected size of command stack (sitalMtCommandStackSize_*).
	U16BIT wMtDataStackSize; // The selected size of data stack (sitalMtDataStackSize_*).
	switch (wBaseMode)
	{
	case sitalMode_TEST:
		{
			/// Initialize device memory management.
			swResult = Device_Memory_Initialize (&(dsspDeviceState->hdmmsDeviceMemoryMap), dsspDeviceState->dcsDeviceCapabilities.dwRamSize);
			if (sitalReturnCode_SUCCESS != swResult)
			{
				return swResult;
			}

			// Nothing to do besides for that: Each of the different specific internal test functions will do whatever further initializations required by it.
			break;
		}
	case sitalMode_BC:
		{
			swResult = sitalBc_HostBuffer_Free (swDevice);

			swResult = sitalBc_Initialize (swDevice, 0U);
			if (sitalReturnCode_SUCCESS == swResult)
			{
				swResult = bc_ConfigureDefault (swDevice);
			}
			break;
		}
	case sitalMode_MRT:
		{
			//swResult = sitalMRT_HostBuffer_Free (swDevice);
			
			swResult = sital_mRt_Initialize (swDevice, 0U);
			if (sitalReturnCode_SUCCESS == swResult)
			{
				dsspDeviceState->wCurrentState = sitalDeviceState_RUN;
				return swResult;
			}
			break;
		}
	case sitalMode_RT:
		{

			swResult = sitalRt_HostBuffer_Free (swDevice);



			U32BIT dwRamSize; // The size (in words) of the RAM memory section of given unit.
			dwRamSize = dsspDeviceState->dcsDeviceCapabilities.dwRamSize;
			//U16BIT wRtCommandStackSize; // The selected size of command stack (sitalRtCommandStackSize_*).
			wRtCommandStackSize = (U16BIT)((65536U <= dwRamSize) ? sitalRtCommandStackSize_2048 : ((32768U <= dwRamSize) ? sitalRtCommandStackSize_1024 : ((16384U <= dwRamSize) ? sitalRtCommandStackSize_512 : sitalRtCommandStackSize_256)));

			swResult = sitalRt_Initialize (swDevice, wRtCommandStackSize, 0U);



			if (sitalReturnCode_SUCCESS == swResult)
			{
				swResult = rt_ConfigureDefault (swDevice);
			}
			break;
		}
	case sitalMode_MT:
		{
			swResult = sitalMt_HostBuffer_Free (swDevice);

			U32BIT dwMtMaximumDataStackSize; // The maximum possible size (in words) of the MT data stack (in case of a MT with a single stack) for given device.
			dwMtMaximumDataStackSize = (dsspDeviceState->dcsDeviceCapabilities.dwRamSize >> 1U);
			U32BIT dwMtMaximumCommandStackSize; // The maximum possible size (in words) of the MT command stack (in case of a MT with a single stack) for given device.
			dwMtMaximumCommandStackSize = (dsspDeviceState->dcsDeviceCapabilities.dwRamSize >> 2U);
			//U16BIT wMtCommandStackSize; // The selected size of command stack (sitalMtCommandStackSize_*).
			wMtCommandStackSize = (U16BIT)((16384U <= dwMtMaximumCommandStackSize) ? sitalMtCommandStackSize_16384 : ((4096U <= dwMtMaximumCommandStackSize) ? sitalMtCommandStackSize_4096 : ((1024U <= dwMtMaximumCommandStackSize) ? sitalMtCommandStackSize_1024 : sitalMtCommandStackSize_256)));
			//U16BIT wMtDataStackSize; // The selected size of data stack (sitalMtDataStackSize_*).
			wMtDataStackSize = (U16BIT)((32768U <= dwMtMaximumDataStackSize) ? sitalMtDataStackSize_32768 : ((16384U <= dwMtMaximumDataStackSize) ? sitalMtDataStackSize_16384 : ((8192U <= dwMtMaximumDataStackSize) ? sitalMtDataStackSize_8192 : ((4096U <= dwMtMaximumDataStackSize) ? sitalMtDataStackSize_4096 : ((2048U <= dwMtMaximumDataStackSize) ? sitalMtDataStackSize_2048 : ((1024U <= dwMtMaximumDataStackSize) ? sitalMtDataStackSize_1024 : sitalMtDataStackSize_512))))));
			swResult = sitalMt_Initialize (swDevice, sitalMtStackOption_SINGLE, wMtCommandStackSize, wMtDataStackSize, 0U);
			if (sitalReturnCode_SUCCESS == swResult)
			{
				swResult = mt_ConfigureDefault (swDevice);
			}
			break;
		}
	case sitalMode_RT_AND_MT:
		{
			sitalRtMt_HostBuffer_Free (swDevice);

			U32BIT dwUnitRamSize; // The size (in words) of the RAM memory section of given unit.
			dwUnitRamSize = dsspDeviceState->dcsDeviceCapabilities.dwRamSize;
			//U16BIT wRtCommandStackSize; // The selected size of command stack (sitalRtCommandStackSize_*).
			wRtCommandStackSize = (U16BIT)((65536U <= dwUnitRamSize) ? sitalRtCommandStackSize_2048 : ((32768U <= dwUnitRamSize) ? sitalRtCommandStackSize_1024 : ((16384U <= dwUnitRamSize) ? sitalRtCommandStackSize_512 : sitalRtCommandStackSize_256)));
			U32BIT dwHalfMemorySize; // Half of the memory size of given device.
			dwHalfMemorySize = (dsspDeviceState->dcsDeviceCapabilities.dwRamSize >> 1U);
			U32BIT dwQuarterMemorySize; // Quarter of the memory size of given device.
			dwQuarterMemorySize = (dsspDeviceState->dcsDeviceCapabilities.dwRamSize >> 2U);
			//U16BIT wMtCommandStackSize; // The selected size of command stack (sitalMtCommandStackSize_*).
			wMtCommandStackSize = (U16BIT)((16384U <= dwQuarterMemorySize) ? sitalMtCommandStackSize_16384 : ((4096U <= dwQuarterMemorySize) ? sitalMtCommandStackSize_4096 : ((2048U <= dwQuarterMemorySize) ? sitalMtCommandStackSize_1024 : sitalMtCommandStackSize_256)));
			//U16BIT wMtDataStackSize; // The selected size of data stack (sitalMtDataStackSize_*).
			wMtDataStackSize = (U16BIT)((32768U <= dwHalfMemorySize) ? sitalMtDataStackSize_32768 : ((16384U <= dwHalfMemorySize) ? sitalMtDataStackSize_16384 : ((8192U <= dwHalfMemorySize) ? sitalMtDataStackSize_8192 : ((4096U <= dwHalfMemorySize) ? sitalMtDataStackSize_4096 : sitalMtDataStackSize_1024))));
			swResult = sitalRtMt_Initialize (swDevice, wRtCommandStackSize, sitalMtStackOption_SINGLE, wMtCommandStackSize, wMtDataStackSize, 0U);
			if (sitalReturnCode_SUCCESS == swResult)
			{
				swResult = rtmt_ConfigureDefault (swDevice);
			}
			break;
		}
	case sitalMode_RS485:
		{
			// NB - 24.7.14 - modified to support RS485
			swResult = sitalReturnCode_SUCCESS;//sital_RS485_Initialize (swDevice, 0U);
			if (sitalReturnCode_SUCCESS == swResult)
			{
				dsspDeviceState->wCurrentState = sitalDeviceState_RUN;
				return swResult;
			}

			break;
		}
	case sitalMode_ARINC429:
		{
			// NB - 25.10.17 - modified to support ARINC 429
			swResult = sitalReturnCode_SUCCESS;
			for(int i = 0 ; i < sitalMaximum_CARDS_ARINC429 ; i++){
				for(int j = 0 ; j < sitalMaximum_DEVICES_ARINC429 ; j++){
					ArincDevices[i][j].ChannelIsOpen = false;
					ArincDevices[i][j].ChannelIsHighSpeed = false;
					if(j < 8) ArincDevices[i][j].DeviceType_Tx_nRx = true;
					else ArincDevices[i][j].DeviceType_Tx_nRx = false;
				}				
			}

			if (sitalReturnCode_SUCCESS == swResult){			
				dsspDeviceState->wCurrentState = sitalDeviceState_RUN;
				return swResult;
			}
			break;
		}
	default:
		{
			swResult = sitalReturnCode_INVALID_MODE;
			break;
		}
	}





	if (sitalReturnCode_SUCCESS != swResult)
	{
		S16BIT swUnusedResult; // Result of operation or function call.
		swUnusedResult = sitalDevice_Free (swDevice);
		return swResult;
	}

	/// In case of a real device:
	///		Actually reset given device.
	///		Query the device whether its an evaluation device of limited operation.
	if (sitalAccess_CARD == wAccess)
	{
		U16BIT wRegisterValue; // The current value of a target register, or the value to set for a target register.
		wRegisterValue = sitalStartResetRegister_RESET;
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_START_OR_RESET, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			S16BIT swUnusedResult; // Result of operation or function call.
			swUnusedResult = sitalDevice_Free (swDevice);
			return swResult;
		}

		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, sitalRegisterAddress_LIMITATIONS, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			S16BIT swUnusedResult; // Result of operation or function call.
			swUnusedResult = sitalDevice_Free (swDevice);
			return swResult;
		}
		dsspDeviceState->bLimitedOperationDevice = (BOOLEAN)( ((U16BIT)sitalLimitationsRegister_LIMITED_PERFORMANCE == ((U16BIT)sitalLimitationsRegister_LIMITED_PERFORMANCE & wRegisterValue)) ? TRUE : FALSE );
	}

	/// Inform the device driver about the up-to-date mode of given device.
	swResult = sitalDevice_SetMode (swDevice, wBaseMode);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		S16BIT swUnusedResult; // Result of operation or function call.
		swUnusedResult = sitalDevice_Free (swDevice);
		return swResult;
	}
	//printf("\nafter device_initialize");
	return sitalReturnCode_SUCCESS;

}


/// <summary>
/// Reset and free given device.
///
/// Note:
/// - This library avoids using any dynamic memory allocations, and this function therefore has no memory allocations to release.
/// - Once this function successfully completes, given device is reset, and must be reinitialized before any further use.
///
/// Equivalent DDC definition: aceFree
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalDevice_Free (S16BIT swDevice)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.

	/// Free the device.
	S16BIT swResult; // Result of operation or function call.
	swResult = device_Reset (swDevice);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Close the device.
	swResult = sitalDevice_Close (swDevice);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Reset the interrupt service routine.
	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	dsspDeviceState->funcpUserIsr = ((USER_ISR_FUNCTION)NULL);

	/// Disable any interrupts.
	dsspDeviceState->dwExternalImr = 0U;

	/// Flag the device as closed.
	dsspDeviceState = &(s_dssaDevices[swDevice]);
	dsspDeviceState->bIsOpened = FALSE;


	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Get the core configuration of given device.
///
/// Equivalent DDC definition: aceGetTimeTagValue
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wpCoreConfiguration (out)	A pointer to a variable in which the core configuration is returned (An or-ed combination of sitalCoreConfiguration_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalDevice_CoreConfiguration_Get (S16BIT swDevice, U16BIT* wpCoreConfiguration)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (((U16BIT*)NULL) == wpCoreConfiguration)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Create a bit pattern designating the core configuration of given device.
	(*wpCoreConfiguration) = 0U;
	(*wpCoreConfiguration) |= ( (TRUE == dsspDeviceState->bLimitedOperationDevice) ? sitalCoreConfiguration_LIMITED_OPERATION : 0U );

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Set the time tag register to given value.
///
/// Equivalent DDC definition: aceSetTimeTagValue
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wTimeTag (in)	The desired value to set the time tag register to
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalDevice_TimeTag_Set (S16BIT swDevice, U16BIT wTimeTag)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	/// Set both the time tag register and its image to given value.
	S16BIT swResult; // Result of operation or function call.
	swResult = device_Register_UpdateImage (swDevice, sitalRegisterAddress_TIME_TAG, registerMask_ALL_BITS_ON, wTimeTag);

	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_TIME_TAG, sitalDeviceMemorySection_Registers, 1U, &wTimeTag);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Get the current value of the time tag register.
///
/// Equivalent DDC definition: aceGetTimeTagValue
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wpTimeTag (out)	A pointer to a variable in which the current value of the time tag register is returned
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalDevice_TimeTag_Get (S16BIT swDevice, U16BIT* wpTimeTag)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	/// Get the current value of the time tag register.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, sitalRegisterAddress_TIME_TAG, sitalDeviceMemorySection_Registers, 1U, wpTimeTag);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Reset the time tag register.
///
/// Equivalent DDC definition: aceResetTimeTag
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalDevice_TimeTag_Reset (S16BIT swDevice)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	/// Reset the time tag register.
	U16BIT wResetTimeTag; // Contains the value that causes a reset of the time tag register.
	wResetTimeTag = sitalStartResetRegister_TIME_TAG_RESET;
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_START_OR_RESET, sitalDeviceMemorySection_Registers, 1U, &wResetTimeTag);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Set the resolution of the time tag register.
///
/// Equivalent DDC definition: aceSetTimeTagRes
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wTimeTagResolution (in)	The desired resolution for the time tag register (sitalTimeTagResolution_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalDevice_TimeTag_SetResolution (S16BIT swDevice, U16BIT wTimeTagResolution)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((0U > wTimeTagResolution) || (timeTagResolution_BORDER <= wTimeTagResolution))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// If that's the first time this function is executed:
	///		Build an array that contains the configuration value per resolution.
	///		Build an array that indicates whether the target configuration register should be actually updated per resolution.
	// Note that these arrays aren't made and initialized as constant arrays as this function abstains from making any assumption about the sitalTimeTagResolution_* values.
	static U16BIT waConfigurationValuePerResolution[timeTagResolution_BORDER]; // An array that contains the value into which the time tag resolution configuration bits are set per time tag resolution.
	static BOOLEAN baIsRegisterUpdatedPerResolution[timeTagResolution_BORDER]; // An array that indicates whether the target configuration register should be actually updated per resolution.
	static bool bIsFirstEntry = TRUE;
	if (TRUE == bIsFirstEntry)
	{
		waConfigurationValuePerResolution[sitalTimeTagResolution_2US] = sitalConfigurationRegister2_TIME_TAG_2US;
		waConfigurationValuePerResolution[sitalTimeTagResolution_4US] = sitalConfigurationRegister2_TIME_TAG_4US;
		waConfigurationValuePerResolution[sitalTimeTagResolution_8US] = sitalConfigurationRegister2_TIME_TAG_8US;
		waConfigurationValuePerResolution[sitalTimeTagResolution_16US] = sitalConfigurationRegister2_TIME_TAG_16US;
		waConfigurationValuePerResolution[sitalTimeTagResolution_32US] = sitalConfigurationRegister2_TIME_TAG_32US;
		waConfigurationValuePerResolution[sitalTimeTagResolution_64US] = sitalConfigurationRegister2_TIME_TAG_64US;
		waConfigurationValuePerResolution[sitalTimeTagResolution_TEST] = sitalConfigurationRegister2_TIME_TAG_TEST;
		waConfigurationValuePerResolution[sitalTimeTagResolution_EXTERNAL_CLOCK] = sitalConfigurationRegister2_TIME_TAG_EXTERNAL_CLOCK;

		baIsRegisterUpdatedPerResolution[sitalTimeTagResolution_2US] = TRUE;
		baIsRegisterUpdatedPerResolution[sitalTimeTagResolution_4US] = TRUE;
		baIsRegisterUpdatedPerResolution[sitalTimeTagResolution_8US] = TRUE;
		baIsRegisterUpdatedPerResolution[sitalTimeTagResolution_16US] = TRUE;
		baIsRegisterUpdatedPerResolution[sitalTimeTagResolution_32US] = TRUE;
		baIsRegisterUpdatedPerResolution[sitalTimeTagResolution_64US] = TRUE;
		baIsRegisterUpdatedPerResolution[sitalTimeTagResolution_TEST] = FALSE;
		baIsRegisterUpdatedPerResolution[sitalTimeTagResolution_EXTERNAL_CLOCK] = FALSE;

		bIsFirstEntry = FALSE;
	}

	/// Record desired time tag resolution within the image of configuration register #2.
	/// If also have to update the real configuration register #2:
	///		Record desired time tag resolution within configuration register #2.
	S16BIT swResult; // Result of operation or function call.
	swResult = device_Register_UpdateImage (swDevice, sitalRegisterAddress_CONFIGURATION_2, sitalConfigurationRegister2_TIME_TAG_RESOLUTION_MASK, waConfigurationValuePerResolution[wTimeTagResolution]);
	if	(
			(sitalModeVariant_NO_TIME_TAG_RESET == (sitalModeVariant_NO_TIME_TAG_RESET & dsspDeviceState->wModeVariants))
			&&
			(TRUE == baIsRegisterUpdatedPerResolution[wTimeTagResolution])
		)
	{
		///	Actually set the address source for given device.
		S16BIT swResult; // Result of operation or function call.
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, sitalRegisterAddress_CONFIGURATION_2, sitalDeviceMemorySection_Registers, sitalConfigurationRegister2_TIME_TAG_RESOLUTION_MASK, &(waConfigurationValuePerResolution[wTimeTagResolution]));
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Configure whether operational statistics shall be collected for given device.
/// These operational statistics include host buffer, stack, and GPQ fullness statistics.
///
/// Note:
/// - Collected operational statistics isn't reset in case operational statistics collection is turned on/off. Collected operational statistics simply aren't updated while collection is off.
///
/// Equivalent DDC definition: aceSetMetrics
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param bIsOperationalStatisticsCollected (in)	A flag that says whether operational statistics should be collected with this device
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalDevice_OperationalStatisticsCollection_Configure (S16BIT swDevice, U16BIT bIsOperationalStatisticsCollected)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_TEST == dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	/// Turn operational statistics collection on/off as desired for given device.
	dsspDeviceState->bIsOperationalStatisticsCollected = (U16BIT)( (FALSE == bIsOperationalStatisticsCollected) ? FALSE : TRUE );

	///	If configured to collect operational statistics for given device:
	///		Update host buffer fullness statistics for given device.
	// Note: Operational statistics are regularly updated only when relevant, so they must be specially updated when they become relevant.
	if (TRUE == dsspDeviceState->bIsOperationalStatisticsCollected)
	{
		HostBufferStructure* hbspHostBuffer; // A host buffer structure.
		hbspHostBuffer = &(dsspDeviceState->bsBcState.hbsHostBuffer);
		hbspHostBuffer->wFullnessPercentage = (U16BIT)( (double)100.0 * (double)(((hbspHostBuffer->dwOffsetOfNextMessageToRead > hbspHostBuffer->dwOffsetOfNextMessageToWrite) ? hbspHostBuffer->dwHostBufferSize : 0U) + hbspHostBuffer->dwOffsetOfNextMessageToWrite - hbspHostBuffer->dwOffsetOfNextMessageToRead) / ((double)(hbspHostBuffer->dwHostBufferSize)) );
		hbspHostBuffer->wMaximumFullnessPercentage = ( (hbspHostBuffer->wMaximumFullnessPercentage < hbspHostBuffer->wFullnessPercentage) ? hbspHostBuffer->wFullnessPercentage : hbspHostBuffer->wMaximumFullnessPercentage );
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Get the currently configured interrupt-related behavior (i.e., type of signal and post-read auto-clearing of interrupt status) for given device.
///
/// Note:
/// - See the documentation for function sitalDevice_Irq_Configure.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wpInterruptMode (in)	A pointer to a variable within which current type of interrupt signal (sitalIrqMode_*) is returned
/// @param wpAutoClear (in)	A pointer to a variable within which current configuration for post-read auto-clearing of interrupt status (sitalIrqClear_*) is returned
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalDevice_Irq_GetMode (S16BIT swDevice, U16BIT* wpInterruptMode, U16BIT* wpAutoClear)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	if ((((U16BIT*)NULL) == wpInterruptMode) || (((U16BIT*)NULL) == wpAutoClear))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	(*wpInterruptMode) = dsspDeviceState->wIrqConfig_InterruptMode;
	(*wpAutoClear) = dsspDeviceState->wIrqConfig_AutoClear;

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Configure interrupt-related behavior (i.e., type of signal and post-read auto-clearing of interrupt status) for given device.
///
/// Note:
/// - This library sets the interrupt mode to the proper value, level or pulse, depending on the operating-system and the card type upon device initialization.
///   The user is nevertheless allowed to use this function in order to change the interrupt mode, but such an operation may make the interrupts function in an improper way.
/// - In order for the user to change one of the two modes, the interrupt mode and the interrupt auto-clear mode, without changing the other, he/she may query the current modes using function sitalDevice_Irq_GetMode.
///
/// Equivalent DDC definition: aceSetIrqConfig
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wInterruptMode (in)	Requested configuration for type of interrupt signal (sitalIrqMode_*)
/// @param wAutoClear (in)	Requested configuration for post-read auto-clearing of interrupt status (sitalIrqClear_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalDevice_Irq_Configure (S16BIT swDevice, U16BIT wInterruptMode, U16BIT wAutoClear)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((0U > wInterruptMode) || (irqSetupSignalType_BORDER <= wInterruptMode))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if ((0U > wAutoClear) || (irqSetupAutoClear_BORDER <= wAutoClear))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Configure given device to use advanced interrupts.
	S16BIT swResult; // Result of operation or function call.
	swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_2, (U16BIT)sitalConfigurationRegister2_ENHANCED_INTERRUPTS, (U16BIT)registerMask_ALL_BITS_ON);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Configure given device to the desired type of interrupt signal.
	swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_2, (U16BIT)sitalConfigurationRegister2_LEVEL_OR_PULSE_INTERRUPTS, (U16BIT)((sitalIrqMode_LEVEL == wInterruptMode) ? registerMask_ALL_BITS_ON : registerMask_ALL_BITS_OFF));
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	dsspDeviceState->wIrqConfig_InterruptMode = wInterruptMode;

	/// Turn the post-read auto-clear of interrupt status feature on/off as desired for given device.
	swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_2, (U16BIT)sitalConfigurationRegister2_INTERRUPT_STATUS_AUTO_CLEAR, (U16BIT)((sitalIrqClear_AUTO_CLEAR == wAutoClear) ? registerMask_ALL_BITS_ON : registerMask_ALL_BITS_OFF));
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	dsspDeviceState->wIrqConfig_AutoClear = wAutoClear;

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Enable/disable interrupt service routine calls in case of given interrupts for given device.
///
/// Note:
/// - In order to receive notifications whenever a minor frame completes, the caller should use this function to enable sitalInterruptRegister2_BC_IRQ3 interrupts.
/// - The effect of arguments bIsInterruptEnabled and dwIrqMask is independent of that of argument funcpExternalIsr, and vice versa.
///
/// Equivalent DDC definition: aceSetIrqConditions
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param bIsInterruptEnabled (in)	A flag indicating whether each of the interrupts designated by parameter dwIrqMask should be enabled (if TRUE) or, otherwise, disabled (if FALSE)
/// @param dwIrqMask (in)	A mask designating a set of interrupts that should be enabled/disabled as indicated by parameter bIsInterruptEnabled (An or-ed combination of sitalInterruptRegister*)
/// @param funcpExternalIsr (in)	A pointer to an interrupt service routine to use with given device, or NULL to stop the usage of a formerly assigned interrupt service routine
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalDevice_Irq_Manipulate (	S16BIT swDevice,
											U16BIT bIsInterruptEnabled,
											U32BIT dwIrqMask,
											USER_ISR_FUNCTION funcpExternalIsr)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	/// Set the interrupt service routine.
	dsspDeviceState->funcpUserIsr = funcpExternalIsr;

	/// Enable/disable given interrupts.
	dsspDeviceState->dwExternalImr = ((TRUE == bIsInterruptEnabled) ? (dsspDeviceState->dwExternalImr | dwIrqMask) : (dsspDeviceState->dwExternalImr & (~dwIrqMask)));

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Set the interrupt service routine to use with given device in case some high priority asynchronous message violates the time frame of a minor frame.
///
/// Equivalent DDC definition: aceSetAsyncIsr
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param funcpAsynchronousMessagesIsr (in)	A pointer to an asynchronous messages interrupt service routine to use with given device, or NULL to stop the usage of an asynchronous messages interrupt service routine
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalDevice_SetAsynchronousMessagesIsr (S16BIT swDevice, ASYNCHRONOUS_MESSAGE_ISR_FUNCTION funcpAsynchronousMessagesIsr)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((sitalAccess_CARD != dsspDeviceState->wAccess) && (sitalAccess_USER != dsspDeviceState->wAccess))
	{
		return sitalReturnCode_INVALID_ACCESS;
	}

	/// Set the asynchronous messages interrupt service routine.
	dsspDeviceState->funcpAsynchronousMessagesIsr = funcpAsynchronousMessagesIsr;

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Set the clock frequency of given device to be the given frequency.
///
/// Equivalent DDC definition: aceSetClockFreq
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalDevice_Clock_SetFrequency (S16BIT swDevice, U16BIT wClockFrequency)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (sitalModeVariant_ADVANCED != (sitalModeVariant_ADVANCED & dsspDeviceState->wModeVariants))
	{
		return sitalReturnCode_NOT_SUPPORTED;
	}

	if ((0U > wClockFrequency) || (clockSetup_BORDER <= wClockFrequency))
	{
		return sitalReturnCode_INVALID_CLOCK_FREQUENCY;
	}

	/// Update clock frequency as requested.
	S16BIT swResult; // Result of operation or function call.
	switch (wClockFrequency)
	{
	case sitalClockSetup_16MHZ:
		swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_6, (U16BIT)sitalConfigurationRegister6_CLOCK_SELECT_MASK, (U16BIT)sitalConfigurationRegister6_CLOCK_SELECT_16MHZ);
		swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_5, (U16BIT)sitalConfigurationRegister5_CLOCK_SELECT_MASK, (U16BIT)sitalConfigurationRegister5_CLOCK_SELECT_16MHZ);
		break;
	case sitalClockSetup_12MHZ:
		swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_6, (U16BIT)sitalConfigurationRegister6_CLOCK_SELECT_MASK, (U16BIT)sitalConfigurationRegister6_CLOCK_SELECT_12MHZ);
		swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_5, (U16BIT)sitalConfigurationRegister5_CLOCK_SELECT_MASK, (U16BIT)sitalConfigurationRegister5_CLOCK_SELECT_12MHZ);
		break;
	case sitalClockSetup_20MHZ:
		swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_6, (U16BIT)sitalConfigurationRegister6_CLOCK_SELECT_MASK, (U16BIT)sitalConfigurationRegister6_CLOCK_SELECT_20MHZ);
		break;
	case sitalClockSetup_10MHZ:
		swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_6, (U16BIT)sitalConfigurationRegister6_CLOCK_SELECT_MASK, (U16BIT)sitalConfigurationRegister6_CLOCK_SELECT_10MHZ);
		break;
	default:
		// Irrelevant: All possible cases were already handled.
		break;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Read the oldest yet unread entry of the interrupt status queue, and track ISQ overruns.
///
/// Equivalent DDC definition: aceISQRead
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param iespIsqEntry (out)	A pointer to the structure in which the ISQ entry is returned
/// @return sitalReturnCode_ReadIsqEntry_NO_NEW_ONES	No entries were read
/// @return sitalReturnCode_ReadIsqEntry_READ_NEW_ENTRY	One entry was read
/// @return sitalReturnCode_ReadIsqEntry_READ_NEW_ENTRY_AND_DETECTED_OVERRUN	One entry was read, and one other or more were lost
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalDevice_Isq_ReadEntry (S16BIT swDevice, sitalIsqEntryStructure* iespIsqEntry)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	return sitalReturnCode_NOT_SUPPORTED; // By the device.

	//if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	//{
	//	return sitalReturnCode_INVALID_DEVICE_NUMBER;
	//}

	//const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
	//							= &(s_dssaDevices[swDevice]);
	//if	(
	//		(sitalMode_MT != (sitalMode_MT & dsspDeviceState->wMode)) &&
	//		(sitalMode_RT != (sitalMode_RT & dsspDeviceState->wMode)) &&
	//		(sitalMode_RT_AND_MT != (sitalMode_RT_AND_MT & dsspDeviceState->wMode))
	//	)
	//{
	//	return sitalReturnCode_INVALID_MODE;
	//}

	//if	(
	//		(
	//			(sitalMode_RT == (sitalMode_MT & dsspDeviceState->wMode)) ||
	//			(sitalMode_RT_AND_MT == (sitalMode_RT & dsspDeviceState->wMode))
	//		)
	//		&&
	//		(FALSE == dsspDeviceState->hisqssIsqState.bIsIsqEnabled)
	//	)
	//{
	//	return sitalReturnCode_ISQ_DISABLED;
	//}

	//if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	//{
	//	return sitalReturnCode_INVALID_STATE;
	//}

	//if (((sitalIsqEntryStructure*)NULL) == iespIsqEntry)
	//{
	//	return sitalReturnCode_INVALID_PARAMETER;
	//}

	///// Clear the pointed target ISQ entry.
	//iespIsqEntry->wHeader = 0U;
	//iespIsqEntry->wData = 0U;


	///// Read the number of the ISQ entry that's going to be filled by the device once the next interrupt occurs.
	//U16BIT wAddressOfNextFilledIsqEntry; // The address of ISQ entry that's going to be filled by the device once the next interrupt occurs.
	//S16BIT swResult; // Result of operation or function call.
	//swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, sitalRegisterAddress_RT_MT_INTERRUPT_STATUS_QUEUE_POINTER, sitalDeviceMemorySection_Registers, 1U, &wAddressOfNextFilledIsqEntry);
	//if (sitalReturnCode_SUCCESS != swResult)
	//{
	//	return swResult;
	//}
	//U16BIT wIndexOfNextFilledIsqEntry; // The index of ISQ entry that's going to be filled by the device once the next interrupt occurs.
	//wIndexOfNextFilledIsqEntry = ISQ_ENTRY_INDEX(wAddressOfNextFilledIsqEntry);

	///// If the ISQ pointer points to the ISQ data instead of the ISQ header of the last reported interrupt as it was read while the device was in the middle of adding another entry to the queue:
	/////		Artificially revert to pointing the last ISQ header.
	//if (0U != (wAddressOfNextFilledIsqEntry % rtMtMemoryObjectSize_ISQ_ENTRY))
	//{
	//	wAddressOfNextFilledIsqEntry -= (wAddressOfNextFilledIsqEntry % rtMtMemoryObjectSize_ISQ_ENTRY);
	//}

	///// Record the initial count of lost ISQ entries.
	//HostInterruptServiceQueueStateStructure* hisqsspIsqState; // A pointer to an ISQ state structure.
	//hisqsspIsqState = (HostInterruptServiceQueueStateStructure*)&(dsspDeviceState->hisqssIsqState);
	//U16BIT wPreviousCountOfLostIsqEntries; // The count of lost ISQ entries as it is when this function is being entered.
	//wPreviousCountOfLostIsqEntries = hisqsspIsqState->wLostIsqEntryCount;

	///// Locate the pointer to the presumably last handled ISQ entry.
	//U16BIT wIndexOfPreviouslyReadIsqEntry; // The index of ISQ entry that has been read in the previous call to this function.
	//if (0U == hisqsspIsqState->wIndexOfNextReadIsqEntry)
	//{
	//	// Last time reached the start of the stack, so the presumably last handled ISQ entry was the last one.
	//	wIndexOfPreviouslyReadIsqEntry = ((U16BIT)sitalBcCounter_ISQ_ENTRIES - (U16BIT)1U);
	//}
	//else
	//{
	//	// The presumably last handled ISQ entry is simply one entry backward.
	//	wIndexOfPreviouslyReadIsqEntry = (hisqsspIsqState->wIndexOfNextReadIsqEntry - (U16BIT)1U);
	//}

	///// Read the presumably last handled ISQ entry.
	///// If it contains a non zero:
	/////		Properly increment the count of lost entries.
	/////		Move to the entry past the one to be next filled.
	//// Note that if the presumably last handled ISQ entry has been really previously handled, it must have been zeroed (see the code below).
	//// Therefore, if it isn't zeroed, it says that ISQ overrun has occurred, along which this entry has been refilled.
	//// In this case we really don't know how many overruns really have happened since the last call to this function, but assume a single one.
	//// So assuming, it's clear that:
	//// - The number of entries we just lost is the sum of the following:
	////   - The total number of entries in the ISQ
	////   - The number of entries between the one that should have had read now and the one that is currently pointed by the ISQ pointer register
	//// - The oldest unhandled ISQ entry that now exists is the entry next to the one currently pointed by the ISQ pointer register
	//U16BIT wPreviouslyReadIsqEntry; // The current contents of the first word of the ISQ entry that has been read in the previous call to this function.
	//swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, ISQ_ENTRY_ADDRESS(wIndexOfPreviouslyReadIsqEntry), sitalDeviceMemorySection_Ram, 1U, &wPreviouslyReadIsqEntry);
	//if (sitalReturnCode_SUCCESS != swResult)
	//{
	//	return swResult;
	//}
	//if (0U != wPreviouslyReadIsqEntry)
	//{
	//	if (wIndexOfNextFilledIsqEntry < hisqsspIsqState->wIndexOfNextReadIsqEntry)
	//	{
	//		hisqsspIsqState->wLostIsqEntryCount += (sitalBcCounter_ISQ_ENTRIES + (sitalBcCounter_ISQ_ENTRIES - (hisqsspIsqState->wIndexOfNextReadIsqEntry - wIndexOfNextFilledIsqEntry)));
	//	}
	//	else
	//	{
	//		hisqsspIsqState->wLostIsqEntryCount += (sitalBcCounter_ISQ_ENTRIES + (wIndexOfNextFilledIsqEntry - hisqsspIsqState->wIndexOfNextReadIsqEntry));
	//	}

	//	hisqsspIsqState->wIndexOfNextReadIsqEntry = (wIndexOfNextFilledIsqEntry + (U16BIT)1U);
	//	if (sitalBcCounter_ISQ_ENTRIES == hisqsspIsqState->wIndexOfNextReadIsqEntry)
	//	{
	//		hisqsspIsqState->wIndexOfNextReadIsqEntry = 0U;
	//	}
	//}

	///// If no new ISQ entries were detected:
	/////		Return an appropriate indication.
	//if (hisqsspIsqState->wIndexOfNextReadIsqEntry == wIndexOfNextFilledIsqEntry)
	//{
	//	return sitalReturnCode_ReadIsqEntry_NO_NEW_ONES;
	//}

	//// There is at least one new entry to read:
	/////	Read the oldest unread entry.
	/////	Zero this entry.
	/////	Move to the next entry.
	//// The entry that is being read is zeroed in order to enable the tracking of ISQ overruns (see more above).
	//swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, ISQ_ENTRY_ADDRESS(hisqsspIsqState->wIndexOfNextReadIsqEntry), sitalDeviceMemorySection_Ram, rtMtMemoryObjectSize_ISQ_ENTRY, (U16BIT*)iespIsqEntry);
	//if (sitalReturnCode_SUCCESS != swResult)
	//{
	//	return swResult;
	//}

	//swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Zero, ISQ_ENTRY_ADDRESS(hisqsspIsqState->wIndexOfNextReadIsqEntry), sitalDeviceMemorySection_Ram, rtMtMemoryObjectSize_ISQ_ENTRY, ((U16BIT*)NULL));

	//hisqsspIsqState->wIndexOfNextReadIsqEntry += 1U;
	//if (sitalBcCounter_ISQ_ENTRIES == hisqsspIsqState->wIndexOfNextReadIsqEntry)
	//{
	//	hisqsspIsqState->wIndexOfNextReadIsqEntry = 0U;
	//}

	///// If one new ISQ entry have been read and no overrun has been detected:
	/////		Return an appropriate indication.
	//if (wPreviousCountOfLostIsqEntries == dsspDeviceState->hisqssIsqState.wLostIsqEntryCount)
	//{
	//	return sitalReturnCode_ReadIsqEntry_READ_NEW_ENTRY;
	//}
	//
	///// If one new ISQ entry have been read after an overrun has been detected:
	/////		Return an appropriate indication.
	//return sitalReturnCode_ReadIsqEntry_READ_NEW_ENTRY_AND_DETECTED_OVERRUN;
}


/// <summary>
/// Clear the ISQ, and reset the ISQ pointer REGISTER.
///
/// Equivalent DDC definition: aceISQClear
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalDevice_Isq_Clear (S16BIT swDevice)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	return sitalReturnCode_NOT_SUPPORTED; // By the device.

	//if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	//{
	//	return sitalReturnCode_INVALID_DEVICE_NUMBER;
	//}

	//DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
	//						= &(s_dssaDevices[swDevice]);
	//if	(
	//		(sitalMode_MT != (sitalMode_MT & dsspDeviceState->wMode)) &&
	//		(sitalMode_RT != (sitalMode_RT & dsspDeviceState->wMode)) &&
	//		(sitalMode_RT_AND_MT != (sitalMode_RT_AND_MT & dsspDeviceState->wMode))
	//	)
	//{
	//	return sitalReturnCode_INVALID_MODE;
	//}

	//if	(
	//		(
	//			(sitalMode_RT == (sitalMode_RT & dsspDeviceState->wMode)) ||
	//			(sitalMode_RT_AND_MT == (sitalMode_RT_AND_MT & dsspDeviceState->wMode))
	//		)
	//		&&
	//		(FALSE == dsspDeviceState->hisqssIsqState.bIsIsqEnabled)
	//	)
	//{
	//	return sitalReturnCode_ISQ_DISABLED;
	//}

	//if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	//{
	//	return sitalReturnCode_INVALID_STATE;
	//}

	//dsspDeviceState->hisqssIsqState.wIndexOfNextReadIsqEntry = 0U;
	//dsspDeviceState->hisqssIsqState.wLostIsqEntryCount = 0U;

	///// Zero the image of the ISQ pointer register.
	//S16BIT swResult; // Result of operation or function call.
	//swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_RT_MT_INTERRUPT_STATUS_QUEUE_POINTER, (U16BIT)registerMask_ALL_BITS_ON, (U16BIT)registerMask_ALL_BITS_OFF);

	///// Zero the ISQ pointer register in device memory.
	//swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Zero, sitalRegisterAddress_RT_MT_INTERRUPT_STATUS_QUEUE_POINTER, sitalDeviceMemorySection_Registers, 1U, ((U16BIT*)NULL));
	//if (sitalReturnCode_SUCCESS != swResult)
	//{
	//	return swResult;
	//}

	//return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Enable/disable the interrupt status queue.
///
/// Equivalent DDC definition: aceISQEnable
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param bIsIsqEnabled (in)	A flag that says whether the ISQ should be enabled, or otherwise disabled (TRUE/FALSE)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalDevice_Isq_Configure (S16BIT swDevice, U16BIT bIsIsqEnabled)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	return sitalReturnCode_NOT_SUPPORTED; // By the device.

	//if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	//{
	//	return sitalReturnCode_INVALID_DEVICE_NUMBER;
	//}

	//DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
	//						= &(s_dssaDevices[swDevice]);
	//if	(
	//		(sitalMode_RT != (sitalMode_RT & dsspDeviceState->wMode)) &&
	//		(sitalMode_RT_AND_MT != (sitalMode_RT_AND_MT & dsspDeviceState->wMode))
	//	)
	//{
	//	return sitalReturnCode_INVALID_MODE;
	//}

	//if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	//{
	//	return sitalReturnCode_INVALID_STATE;
	//}

	/////	Mark the ISQ as enabled/disabled, as required.
	//dsspDeviceState->hisqssIsqState.bIsIsqEnabled = (BOOLEAN)bIsIsqEnabled;
	//S16BIT swResult; // Result of operation or function call.
	//swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_6, (U16BIT)sitalConfigurationRegister6_RT_MT_INTERRUPT_STATUS_QUEUE, (U16BIT)((TRUE == bIsIsqEnabled) ? registerMask_ALL_BITS_ON : registerMask_ALL_BITS_OFF));

	//return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Set given response timeout for given device.
///
/// Equivalent DDC definition: aceSetRespTimeOut
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wResponseTimeout (in)	Response timeout (sitalResponseTimeout_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalDevice_SetResponseTimeout (S16BIT swDevice, U16BIT wResponseTimeout)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (responseTimeout_BORDER <= wResponseTimeout)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	///	Set the required response timeout.
	U16BIT wSpecificResponseTimeoutMask; // The bit mask used to set given response timeout.
	wSpecificResponseTimeoutMask = (U16BIT)(	(sitalResponseTimeout_18US == wResponseTimeout) ?	sitalConfigurationRegister5_RESPONSE_TIMEOUT_18US	:
												(sitalResponseTimeout_22US == wResponseTimeout) ?	sitalConfigurationRegister5_RESPONSE_TIMEOUT_22US	:
												(sitalResponseTimeout_50US == wResponseTimeout) ?	sitalConfigurationRegister5_RESPONSE_TIMEOUT_50US	:
																									sitalConfigurationRegister5_RESPONSE_TIMEOUT_130US	);
	S16BIT swResult; // Result of operation or function call.
	swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_5, (U16BIT)sitalConfigurationRegister5_RESPONSE_TIMEOUT_MASK, (U16BIT)wSpecificResponseTimeoutMask);

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Configure the watchdog timeout for given device, that is, either enable and set it to given timeout, or disable it, as requested.
///
/// Note:
/// - Parameter wWatchdogTimeout is used only is the watchdog timeout is enabled.
///
/// Equivalent DDC definition: aceBCSetWatchDogTimer
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param bIsWatchdogEnabled (in)	A flag that says if the watchdog should be enabled or not
/// @param wWatchdogTimeout (in)	The watchdog timeout (in units of 100us) to set for given device (>=0)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalDevice_ConfigureWatchdogTimeout (S16BIT swDevice, U16BIT bIsWatchdogEnabled, U16BIT wWatchdogTimeout)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	/// If the watchdog timer should be enabled for given BC device:
	///		Enable the watchdog timer for given BC device.
	/// Else:
	///		Disable the watchdog timer for given BC device.
	S16BIT swResult; // Result of operation or function call.
	swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_7, (U16BIT)sitalConfigurationRegister7_BC_ENHANCED_WATCHDOG_TIMER_ENABLE, (U16BIT)( (TRUE == bIsWatchdogEnabled) ? registerMask_ALL_BITS_ON : registerMask_ALL_BITS_OFF ));

	/// If the watchdog timer has been just enabled for given BC device:
	///		Record requested watchdog timeout for given BC device.
	/// Else:
	///		Zero the watchdog timeout for given BC device.
	dsspDeviceState->bsBcState.wWatchDogTimeout = ( (TRUE == bIsWatchdogEnabled) ? wWatchdogTimeout : (U16BIT)0U );

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Configure the Manchester-II decoder.
///
/// Equivalent DDC definition: aceSetDecoderConfig
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wDecodedInput (in)	The type of input to decode (sitalInputDevice_*)
/// @param wExpendedXingOption (in)	The sampling method (sitalExpendedXing_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalDevice_ConfigureDecoder (S16BIT swDevice, U16BIT wDecodedInput, U16BIT wExpendedXingOption)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalModeVariant_ADVANCED != (sitalModeVariant_ADVANCED & dsspDeviceState->wModeVariants))
	{
		return sitalReturnCode_NOT_SUPPORTED;
	}

	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	/// Properly set the decoded input to single or double ended.
	S16BIT swResult; // Result of operation or function call.
	if (sitalInputDevice_DoubleEnded == wDecodedInput)
	{
		swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_5, (U16BIT)sitalConfigurationRegister5_SINGLE_ENDED_SELECT, (U16BIT)registerMask_ALL_BITS_ON);
	}
	else
	{
		swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_5, (U16BIT)sitalConfigurationRegister5_SINGLE_ENDED_SELECT, (U16BIT)registerMask_ALL_BITS_OFF);
	}

	/// Properly set the sampling method to expanded zero-crossing or not.
	if (sitalExpendedXing_Enable == wExpendedXingOption)
	{
		swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_5, (U16BIT)sitalConfigurationRegister5_EXPANDED_CROSSING, (U16BIT)registerMask_ALL_BITS_ON);
	}
	else
	{
		swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_5, (U16BIT)sitalConfigurationRegister5_EXPANDED_CROSSING, (U16BIT)registerMask_ALL_BITS_OFF);
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Enable/disable RAM parity checking for hardware containing 17-bit buffered RAM.
///
/// Equivalent DDC definition: aceSetRamParityChecking
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wRamParityCheckEnabler (in)	Automatic RAM parity checking enabler (sitalRamParityCheck_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalDevice_ConfigureRamParityCheck (S16BIT swDevice, U16BIT wRamParityCheckEnabler)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	/// Properly set the RAM parity checking policy.
	S16BIT swResult; // Result of operation or function call.
	if (sitalRamParityCheck_ENABLE == wRamParityCheckEnabler)
	{
		swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_2, (U16BIT)sitalConfigurationRegister2_RAM_PARITY, (U16BIT)registerMask_ALL_BITS_ON);
	}
	else
	{
		swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_2, (U16BIT)sitalConfigurationRegister2_RAM_PARITY, (U16BIT)registerMask_ALL_BITS_OFF);
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Reset given device and perform device registers test.
/// This test consists of the following steps:
/// - Loop over a predetermined set of tested device registers, and with each tested register verify that:
///   - It properly responds r/w operations.
///   - It is reset upon device reset.
/// - Verify the correct operation of the time tag system.
///
/// Note:
/// - The following check-IDs are returned by this function in case of test failures:
///   - i: Either the index of the faulty register test iteration, or the index of the faulty time tag register test iteration.
///
/// Equivalent DDC definition: aceTestRegisters
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param dtrspTestResult (in)	A pointer to a structure within which the test result is returned
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalDevice_Test_Registers (S16BIT swDevice, sitalDeviceTestResultStructure* dtrspTestResult)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (sitalAccess_CARD != dsspDeviceState->wAccess)
	{
		return sitalReturnCode_INVALID_ACCESS;
	}

	if (sitalMode_TEST != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (((sitalDeviceTestResultStructure*)NULL) == dtrspTestResult)
	{
		return sitalReturnCode_INVALID_TEST_STRUCTURE;
	}

	/// Reset given test result structure.
	memset (dtrspTestResult, 0, sizeof(sitalDeviceTestResultStructure));

	///	Reset given device.
	U16BIT wRegisterValue; // The current value of a target register, or the value to set for a target register.
	wRegisterValue = sitalStartResetRegister_RESET;
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_START_OR_RESET, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Loop over all tested registers:
	static const U16BIT s_waRegisterAddress[] = // An array that contains the addresses of the registers that should be tested.
							{ sitalRegisterAddress_INTERRUPT_MASK_1, sitalRegisterAddress_CONFIGURATION_2 };
	U16BIT wTestedRegisterCount; // The number of tested registers.
	wTestedRegisterCount = ( sizeof(s_waRegisterAddress) / sizeof(s_waRegisterAddress[0]) );
	U16BIT wWrittenRegisterValue; // The value to set for a target register.
	wWrittenRegisterValue = (U16BIT)0xFF7FU;
	U16BIT wReadRegisterValue; // The current value of a target register.
	for (U16BIT wRegisterTestIterationIndex=0; wRegisterTestIterationIndex<wTestedRegisterCount; wRegisterTestIterationIndex++)
	{
		///		Turn given device into enhanced mode.
		wRegisterValue = sitalConfigurationRegister3_ENHANCED_MODE;
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_CONFIGURATION_3, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}

		///		Turn given device into register test mode.
		wRegisterValue = ( sitalConfigurationRegister4_RT_LATCH_ADDRESS | sitalConfigurationRegister4_TEST_MODE_REGISTER );
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_CONFIGURATION_4, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}

		///		Write a test value into the currently tested register.
		wRegisterValue = wWrittenRegisterValue;
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, s_waRegisterAddress[wRegisterTestIterationIndex], sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}

		///		Verify that the currently tested register has been properly set.
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, s_waRegisterAddress[wRegisterTestIterationIndex], sitalDeviceMemorySection_Registers, 1U, &wReadRegisterValue);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
		if (wWrittenRegisterValue != wReadRegisterValue)
		{
			dtrspTestResult->wResult = sitalDeviceTestResult_REGISTER_FAIL;
			dtrspTestResult->wDeviceMemoryAddress = s_waRegisterAddress[wRegisterTestIterationIndex];
			dtrspTestResult->wActualValue = wReadRegisterValue;
			dtrspTestResult->wExpectedValue = wWrittenRegisterValue;
			dtrspTestResult->wCheckId = wRegisterTestIterationIndex;

			wRegisterValue = sitalStartResetRegister_RESET;
			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_START_OR_RESET, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
			return swResult;
		}

		///		Reset given device.
		wRegisterValue = sitalStartResetRegister_RESET;
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_START_OR_RESET, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}

		///		Verify that the currently tested register has been zeroed.
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, s_waRegisterAddress[wRegisterTestIterationIndex], sitalDeviceMemorySection_Registers, 1U, &wReadRegisterValue);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
		if (0U != wReadRegisterValue)
		{
			dtrspTestResult->wResult = sitalDeviceTestResult_REGISTER_FAIL;
			dtrspTestResult->wDeviceMemoryAddress = s_waRegisterAddress[wRegisterTestIterationIndex];
			dtrspTestResult->wActualValue = wReadRegisterValue;
			dtrspTestResult->wExpectedValue = wWrittenRegisterValue;
			dtrspTestResult->wCheckId = wRegisterTestIterationIndex;

			wRegisterValue = sitalStartResetRegister_RESET;
			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_START_OR_RESET, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
			return swResult;
		}
	}

	///	Reset given device.
	wRegisterValue = sitalStartResetRegister_RESET;
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_START_OR_RESET, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	///	Turn given device into enhanced mode.
	wRegisterValue = sitalConfigurationRegister3_ENHANCED_MODE;
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_CONFIGURATION_3, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	///	Turn given device into register test mode.
	wRegisterValue = ( sitalConfigurationRegister4_RT_LATCH_ADDRESS | sitalConfigurationRegister4_TEST_MODE_REGISTER );
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_CONFIGURATION_4, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	///	Turn given device into time tag test mode.
	wRegisterValue = sitalConfigurationRegister2_TIME_TAG_TEST;
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_CONFIGURATION_2, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	///	Reset the time tag for given device.
	wRegisterValue = sitalStartResetRegister_TIME_TAG_RESET;
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_START_OR_RESET, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Loop to test the operation of the time tag of given device:
	for (U16BIT wTimeTagTestIterationIndex=0U; wTimeTagTestIterationIndex<100U; wTimeTagTestIterationIndex++)
	{
		///		Verify that the time tag register has a proper value.
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, sitalRegisterAddress_TIME_TAG, sitalDeviceMemorySection_Registers, 1U, &wReadRegisterValue);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
		if (wTimeTagTestIterationIndex != wReadRegisterValue)
		{
			dtrspTestResult->wResult = sitalDeviceTestResult_REGISTER_FAIL;
			dtrspTestResult->wDeviceMemoryAddress = sitalRegisterAddress_TIME_TAG;
			dtrspTestResult->wActualValue = wReadRegisterValue;
			dtrspTestResult->wExpectedValue = wTimeTagTestIterationIndex;
			dtrspTestResult->wCheckId = wTimeTagTestIterationIndex;

			wRegisterValue = sitalStartResetRegister_RESET;
			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_START_OR_RESET, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
			return swResult;
		}

		///		Force the increment of the time tag register of given device.
		wRegisterValue = sitalStartResetRegister_TIME_TAG_TEST_CLOCK;
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_START_OR_RESET, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
	}

	/// Set proper test result.
	dtrspTestResult->wResult = sitalDeviceTestResult_PASS;

	///	Reset given device.
	wRegisterValue = sitalStartResetRegister_RESET;
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_START_OR_RESET, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
	return swResult;
}


/// <summary>
/// Reset given device and perform device memory test.
/// Fill all the memory of given device with given value, and verify that the written values may be read back from the device.
///
/// Note:
/// - The following check-IDs are returned by this function in case of test failures:
///   - i: The memory address whose r/w test failed.
///
/// Equivalent DDC definition: aceTestMemory
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param dtrspTestResult (in)	A pointer to a structure within which the test result is returned
/// @param wWrittenValue (in)	A value to fill device memory with.
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalDevice_Test_Memory (S16BIT swDevice, sitalDeviceTestResultStructure* dtrspTestResult, U16BIT wWrittenValue)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (sitalAccess_CARD != dsspDeviceState->wAccess)
	{
		return sitalReturnCode_INVALID_ACCESS;
	}

	if (sitalMode_TEST != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (((sitalDeviceTestResultStructure*)NULL) == dtrspTestResult)
	{
		return sitalReturnCode_INVALID_TEST_STRUCTURE;
	}

	/// Zero given test result structure.
	memset (dtrspTestResult, 0, sizeof(sitalDeviceTestResultStructure));

	///	Reset given device.
	U16BIT wRegisterValue; // The current value of a target register, or the value to set for a target register.
	wRegisterValue = sitalStartResetRegister_RESET;
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_START_OR_RESET, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Loop over all the memory space of given device:
	U16BIT wReadValue; // The value currently stored in a target device memory address.
	for (U32BIT dwDeviceWordAddress=0; dwDeviceWordAddress<dsspDeviceState->hdmmsDeviceMemoryMap.dwRamSize; dwDeviceWordAddress++)
	{
		///		Write given written value into the current device memory address of given device.
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, dwDeviceWordAddress, sitalDeviceMemorySection_Ram, 1U, &wWrittenValue);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}

		///		Verify that the constants of the currently tested device memory address has been properly set.
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, dwDeviceWordAddress, sitalDeviceMemorySection_Ram, 1U, &wReadValue);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
		if (wWrittenValue != wReadValue)
		{
			dtrspTestResult->wResult = sitalDeviceTestResult_RAM_FAIL;
			dtrspTestResult->wDeviceMemoryAddress = (U16BIT)dwDeviceWordAddress;
			dtrspTestResult->wActualValue = wReadValue;
			dtrspTestResult->wExpectedValue = wWrittenValue;
			dtrspTestResult->wCheckId = (U16BIT)dwDeviceWordAddress;

			return sitalReturnCode_SUCCESS;
		}
	}

	/// Set proper test result.
	dtrspTestResult->wResult = sitalDeviceTestResult_PASS;

	///	Reset given device.
	wRegisterValue = sitalStartResetRegister_RESET;
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_START_OR_RESET, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
	return swResult;
}


/// <summary>
/// Reset given device and perform device protocol test.
/// This test consists of the following steps:
/// - Configure given device: Set bits 8-11 of its Configuration Register #1 to 1111(2).
/// - Set the device time tag resolution to 2 us: Set bits 7-9 of its Configuration Register #2 to 101(2).
/// - Perform a series of tests on the hardware protocol functions, and verify that given device properly functions.
///
/// Note:
/// - This test function, unlike function sitalBc_Start, does not configure the BC into enhanced mode, and therefore uses a command stack and BC-style message blocks rather than micro-code frames and eBC-style message blocks (for more information read about the Stack and the Message Block in the BC Users Manual).
///   Now, as micro-code commands won't be executed while the test frame is run, the GPQ, that's usually located at RAM address 0x0000 of the device, won't be used, and the stack may be located at that address.
/// - The following check-IDs are returned by this function in case of test failures:
///   - 0: One of the messages resulted with an unexpected block status word in its command stack entry.
///   - 1, 2, 3, ...: The number of the message for which an unexpected data word has been received.
///
/// Equivalent DDC definition: aceTestProtocol
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param dtrspTestResult (in)	A pointer to a structure within which the test result is returned
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
#define SIZE_OF_PART_OF_MESSAGE_BLOCK_RELEVANT_IN_THIS_TEST		4U // The size (in words) of the initial part of the BC-style message blocks of the messages defined in this test, in which case the message block consists of the following quadruplet: (control-word, command-word, broadcast-data-word, data-word-received-in-loop-back).
#define MESSAGE_BLOCK_OFFSET_OF_CONTROL_WORD_IN_THIS_TEST		0U // The offset (in words) of the control word in the BC-style message blocks of the messages defined in this test.
#define MESSAGE_BLOCK_OFFSET_OF_COMAND_WORD_IN_THIS_TEST		1U // The offset (in words) of the command word in the BC-style message blocks of the messages defined in this test.
#define MESSAGE_BLOCK_OFFSET_OF_TX_DATA_WORD_IN_THIS_TEST		2U // The offset (in words) of the transmitted data word in the BC-style message blocks of the messages defined in this test.
#define MESSAGE_BLOCK_OFFSET_OF_RX_DATA_WORD_IN_THIS_TEST		3U // The offset (in words) of the received data word in the BC-style message blocks of the messages defined in this test.
S16BIT _DECL sitalDevice_Test_Protocol (S16BIT swDevice, sitalDeviceTestResultStructure* dtrspTestResult)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (sitalAccess_CARD != dsspDeviceState->wAccess)
	{
		return sitalReturnCode_INVALID_ACCESS;
	}

	if (sitalMode_TEST != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (((sitalDeviceTestResultStructure*)NULL) == dtrspTestResult)
	{
		return sitalReturnCode_INVALID_TEST_STRUCTURE;
	}

	/// Zero given test result structure.
	memset (((void*)dtrspTestResult), 0, sizeof(sitalDeviceTestResultStructure));

	///	Reset given device.
	U16BIT wRegisterValue; // The current value of a target register, or the value to set for a target register.
	wRegisterValue = sitalStartResetRegister_RESET;
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_START_OR_RESET, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Configure given device to auto-repeat a transmitted frame until a status set or error condition is encountered.
	wRegisterValue = ( sitalConfigurationRegister1_BC_FRAME_AUTOREPEAT | sitalConfigurationRegister1_BC_STATUS_SET_STOP_ON_FRAME| sitalConfigurationRegister1_BC_STATUS_SET_STOP_ON_MESSAGE | sitalConfigurationRegister1_BC_FRAME_STOP_ON_ERROR );
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_CONFIGURATION_1, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Configure given device to use time tag register resolution of 2 us.
	wRegisterValue = sitalConfigurationRegister2_TIME_TAG_2US;
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_CONFIGURATION_2, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Create a stack entry and a message block for messages #1-4.
	/// If the size of RAM in given device is greater than 12K words:
	///		Create a stack entry and a message block for message #5 in the bottom of device memory.
	// Note: See in the documentation of this function (above) a note about the method it uses in order to run a test frame.
	U16BIT waStackCommandEntry[bcMemoryObjectSize_COMMAND_STACK_ENTRY]; // An array that stores the contents of a stack command entry, which consists of the following quadruplet: (block-status-word, time-tag, message-gap, message-block-address).
	U16BIT waMessageBlock[SIZE_OF_PART_OF_MESSAGE_BLOCK_RELEVANT_IN_THIS_TEST]; // An array that stores the initial part of the BC-style message blocks of the messages defined in this test, in which case the message block consists of the following quadruplet: (control-word, command-word, broadcast-data-word, data-word-received-in-loop-back).
	U16BIT wCommandStackBaseAddress; // The device memory address where the command stack is located.
	wCommandStackBaseAddress = 0x0000U;
	U16BIT wMessageBlocksBaseAddress; // The device memory address where the message blocks are located.
	wMessageBlocksBaseAddress = 0x0140U;
	U16BIT wCommandStackEntryAddress; // The device memory address where the current command stack entry is located.
	U16BIT wMessageBlockAddress; // The device memory address where the current message block is located.
	U16BIT waMessageCommandWords[] = // The command word of the different messages used in this test.
			{ 0xF821U, 0xF821U, 0xF821U, 0x0821U, 0xF821U }; // 0xF821: BCST Rx SA=1 WC=1 (i.e., BC-to-BCST SA01 1-word);	0x0821: RT=01 Rx SA=1 WC=1 (i.e., BC-to-RT01 SA01 1-word).
	U16BIT waMessageControlWords[] = // The control word of the different messages used in this test.
			{ 0x00C2U, 0x00C2U, 0x00C2U, 0x00C0U, 0x00C2U }; // 0x00C2: Internal loop back test on bus-a (broadcast designated, but ignored: the device simply acts as dictated by the command word);	0x00C0: Internal loop back test on bus-a.
	U16BIT wMessageCount; // The number of entries in the currently created stack entry, which is the number of messages in the tested frame.
	wMessageCount = (U16BIT)( (0x3000U <= dsspDeviceState->hdmmsDeviceMemoryMap.dwRamSize) ? 5U : 4U );
	U16BIT wMessageIndex; // The index of the currently created stack entry and message block.
	for (wMessageIndex=0U; wMessageIndex<wMessageCount; wMessageIndex++)
	{
		wCommandStackEntryAddress = (wCommandStackBaseAddress + (wMessageIndex * (U16BIT)bcMemoryObjectSize_COMMAND_STACK_ENTRY));
		wMessageBlockAddress = (wMessageBlocksBaseAddress + (wMessageIndex * (U16BIT)bcMemoryObjectSize_MESSAGE_BLOCK));

		waStackCommandEntry[0] = 0x0000U;
		waStackCommandEntry[1] = 0x0000U;
		waStackCommandEntry[2] = 0x0000U;
		waStackCommandEntry[3] = wMessageBlockAddress; // The device memory address of the corresponding message block.

		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, wCommandStackEntryAddress, sitalDeviceMemorySection_Ram, bcMemoryObjectSize_COMMAND_STACK_ENTRY, waStackCommandEntry);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}

		waMessageBlock[0] = waMessageControlWords[wMessageIndex]; // Message control word.
		waMessageBlock[1] = waMessageCommandWords[wMessageIndex]; // Message command.
		waMessageBlock[2] = (wMessageIndex + (U16BIT)1U); // The data word for the BC to transmit.
		waMessageBlock[3] = (wMessageIndex + (U16BIT)1U + wMessageCount); // Here the received data word will be stored, so it is initially set to another value than the expected one, in order to be sure that the correct word has been really received.

		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, wMessageBlockAddress, sitalDeviceMemorySection_Ram, SIZE_OF_PART_OF_MESSAGE_BLOCK_RELEVANT_IN_THIS_TEST, waMessageBlock);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
	}

	/// Set the command stack pointer and frame length.
	// Note:
	// - In order to be compatible with DDC's library, the device memory addresses of the command stack pointer and frame length that are used here are those of frame non-auto-repeat mode, though the actually configured mode is frame auto-repeat.
	// - The frame length is stored in one's-complement representation, and zero is represented by 0xFFFF.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, bcAddressMap_COMMAND_STACK_IN_NON_AUTO_REPEAT_MODE, sitalDeviceMemorySection_Ram, 1U, &wCommandStackBaseAddress);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	U16BIT wFrameLength; // The number of messages in the test frame in one's-complement representation.
	wFrameLength = ( ~ wMessageCount );
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, bcAddressMap_FRAME_LENGTH_IN_NON_AUTO_REPEAT_MODE, sitalDeviceMemorySection_Ram, 1U, &wFrameLength);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Order the BC to run the test frame.
	wRegisterValue = sitalStartResetRegister_BC_MT_START;
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_START_OR_RESET, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Wait enough time for the whole frame to be transmitted.
	Sleep_NonOsDependent(1000U);

	/// Verify that the frame length has been reset.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, bcAddressMap_FRAME_LENGTH_IN_NON_AUTO_REPEAT_MODE, sitalDeviceMemorySection_Ram, 1U, &wFrameLength);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	if (0xFFFFU != wFrameLength)
	{
		return sitalReturnCode_TEST_FAIL;
	}

	/// Loop over all transmitted messages:
	///		Verify that all message blocks contain the expected received data word.
	///		Verify that all block status words contain the expected statuses.
	U16BIT wTransmittedDataWord; // A transmitted data word.
	U16BIT wReceivedDataWord; // A received data word.
	U16BIT wBlockStatusWord; // The block status word of some BC command stack entry.
	U16BIT wCheckedBlockStatusMask; // A mask of the bits of the block status word that are tested here.
	wCheckedBlockStatusMask = (sitalBcBlockStatusWord_LOOPBACK_FAIL | sitalBcBlockStatusWord_NO_RESPONSE | sitalBcBlockStatusWord_FORMAT_ERROR | sitalBcBlockStatusWord_STATUS_SET | sitalBcBlockStatusWord_ERROR_FLAG | sitalBcBlockStatusWord_BUS_B | sitalBcBlockStatusWord_START_OF_MESSAGE | sitalBcBlockStatusWord_END_OF_MESSAGE);
	U16BIT wExpectedBroadcastCheckedBlockStatusMask; // A mask of the bits of the block status word that are tested here and expected to be on in result of BC-to-BCST messages.
	wExpectedBroadcastCheckedBlockStatusMask = sitalBcBlockStatusWord_END_OF_MESSAGE;
	U16BIT wExpectedRtCheckedBlockStatusMask; // A mask of the bits of the block status word that are tested here and expected to be on in result of BC-to-RT messages.
	wExpectedRtCheckedBlockStatusMask = (sitalBcBlockStatusWord_NO_RESPONSE | sitalBcBlockStatusWord_ERROR_FLAG | sitalBcBlockStatusWord_END_OF_MESSAGE);
	U16BIT waExpectedCheckedBlockStatusMask[] = // The masks of the bits of the block status word that are tested here and expected to be on in result of tested messages.
			{ wExpectedBroadcastCheckedBlockStatusMask, wExpectedBroadcastCheckedBlockStatusMask, wExpectedBroadcastCheckedBlockStatusMask, wExpectedRtCheckedBlockStatusMask, wExpectedBroadcastCheckedBlockStatusMask };
	for (wMessageIndex=0U; wMessageIndex<wMessageCount; wMessageIndex++)
	{
		wCommandStackEntryAddress = (wCommandStackBaseAddress + (wMessageIndex * (U16BIT)bcMemoryObjectSize_COMMAND_STACK_ENTRY));
		wMessageBlockAddress = (wMessageBlocksBaseAddress + (wMessageIndex * (U16BIT)bcMemoryObjectSize_MESSAGE_BLOCK));

		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, (wMessageBlockAddress + MESSAGE_BLOCK_OFFSET_OF_TX_DATA_WORD_IN_THIS_TEST), sitalDeviceMemorySection_Ram, 1U, &wTransmittedDataWord);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}

		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, (wMessageBlockAddress + MESSAGE_BLOCK_OFFSET_OF_RX_DATA_WORD_IN_THIS_TEST), sitalDeviceMemorySection_Ram, 1U, &wReceivedDataWord);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}

		if (wTransmittedDataWord != wReceivedDataWord)
		{
			dtrspTestResult->wResult = (U16BIT)sitalDeviceTestResult_PROTOCOL_FAIL;
			dtrspTestResult->wDeviceMemoryAddress = (wMessageBlockAddress + (U16BIT)MESSAGE_BLOCK_OFFSET_OF_RX_DATA_WORD_IN_THIS_TEST);
			dtrspTestResult->wActualValue = wReceivedDataWord;
			dtrspTestResult->wExpectedValue = wTransmittedDataWord;
			dtrspTestResult->wCheckId = (wMessageIndex + (U16BIT)1U);
		}

		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, (wCommandStackEntryAddress + bcCommandStackEntry_OFFSET_OF_BLOCK_STATUS_WORD), sitalDeviceMemorySection_Ram, 1U, &wBlockStatusWord);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}

		if (waExpectedCheckedBlockStatusMask[wMessageIndex] != (wCheckedBlockStatusMask & wBlockStatusWord))
		{
			dtrspTestResult->wResult = (U16BIT)sitalDeviceTestResult_PROTOCOL_FAIL;
			dtrspTestResult->wDeviceMemoryAddress = (wCommandStackEntryAddress + (U16BIT)bcCommandStackEntry_OFFSET_OF_BLOCK_STATUS_WORD);
			dtrspTestResult->wActualValue = wBlockStatusWord;
			dtrspTestResult->wExpectedValue = waExpectedCheckedBlockStatusMask[wMessageIndex];
			dtrspTestResult->wCheckId = (U16BIT)0U;
		}
	}

	/// Set proper test result.
	dtrspTestResult->wResult = sitalDeviceTestResult_PASS;

	///	Reset given device.
	wRegisterValue = sitalStartResetRegister_RESET;
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_START_OR_RESET, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
	return swResult;
}


/// <summary>
/// Reset given device and perform device interrupts test.
/// This test consists of the following steps:
/// - Set the device time tag resolution to test mode: Set bits 7-9 of its Configuration Register #2 to 011(2).
/// - Set the device to use level type interrupts: Set bit 3 of its Configuration Register #2 to 1(2).
/// - Configure the device to issue time tag rollover interrupts: Set bit 6 of its Interrupt Mask Register #1 to 1(2).
/// - Assign an ISR to the device that will record the IRQ status of informed interrupts.
/// - Make the device generate a time tag rollover interrupt: Load its time tag register with a value of 0xFFFF, and then increment it to force a time tag rollover.
/// - Verify that the expected interrupts has indeed been tracked by the assigned ISR.
///
/// Note:
/// - The following check-IDs are returned by this function in case of test failures:
///   - 1: The time tag register was not reset though a rollover condition has been artificially created.
///   - 2: A time tag rollover interrupt was not issued.
///
/// Equivalent DDC definition: aceTestIrqs
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param dtrspTestResult (in)	A pointer to a structure within which the test result is returned
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalDevice_Test_Interrupts (S16BIT swDevice, sitalDeviceTestResultStructure* dtrspTestResult)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (sitalAccess_CARD != dsspDeviceState->wAccess)
	{
		return sitalReturnCode_INVALID_ACCESS;
	}

	if (sitalMode_TEST != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (((sitalDeviceTestResultStructure*)NULL) == dtrspTestResult)
	{
		return sitalReturnCode_INVALID_TEST_STRUCTURE;
	}

	/// Zero given test result structure.
	memset (dtrspTestResult, 0, sizeof(sitalDeviceTestResultStructure));

	///	Reset given device.
	U16BIT wRegisterValue; // The current value of a target register, or the value to set for a target register.
	wRegisterValue = sitalStartResetRegister_RESET;
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_START_OR_RESET, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	///	Turn given device into time tag test mode.
	///	Configure given device to issue level interrupts.
	///	Configure given device to auto-clear interrupt statuses.
	// On Sep 6, 2018, the level of interrupt is changed to PULSE so consignation register 0x42 in VME card can be reset by writing back its value
	//wRegisterValue = ( sitalConfigurationRegister2_TIME_TAG_TEST | sitalConfigurationRegister2_LEVEL_INTERRUPTS | sitalConfigurationRegister2_INTERRUPT_STATUS_AUTO_CLEAR );
	wRegisterValue = ( sitalConfigurationRegister2_TIME_TAG_TEST |  sitalConfigurationRegister2_INTERRUPT_STATUS_AUTO_CLEAR );
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_CONFIGURATION_2, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Configure given device to issue time tag rollover interrupts.
	wRegisterValue = sitalInterruptMaskRegister1_TIME_TAG_ROLLOVER;
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_INTERRUPT_MASK_1, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	///	Set for given device an internal ISR that simply records informed IRQ status.
	dsspDeviceState->dwInterruptCount = 0U;
	dsspDeviceState->dwIrqStatus = 0x00000000U;
	swResult = sitalProcess_SetInterruptServiceRoutine ((ISR_FUNCTION)device_TestIsr);

	/// Set the time tag register of given device to be on the edge of a rollover.
	wRegisterValue = (U16BIT)0xFFFFU;
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_TIME_TAG, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		sitalProcess_SetInterruptServiceRoutine ((ISR_FUNCTION)NULL);

		return swResult;
	}

	///	Force the increment of the time tag register of given device.
	wRegisterValue = sitalStartResetRegister_TIME_TAG_TEST_CLOCK;
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_START_OR_RESET, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		sitalProcess_SetInterruptServiceRoutine ((ISR_FUNCTION)NULL);

		return swResult;
	}

	///	Verify that the time tag register has a proper value.
	U16BIT wReadRegisterValue; // The current value of a target register.
	/*swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, sitalRegisterAddress_TIME_TAG, sitalDeviceMemorySection_Registers, 1U, &wReadRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		sitalProcess_SetInterruptServiceRoutine ((ISR_FUNCTION)NULL);

		return swResult;
	}
	if (0x0000 != wReadRegisterValue)
	{
		dtrspTestResult->wResult = sitalDeviceTestResult_INTERRUPT_FAIL;
		dtrspTestResult->wDeviceMemoryAddress = sitalRegisterAddress_TIME_TAG;
		dtrspTestResult->wActualValue = wReadRegisterValue;
		dtrspTestResult->wExpectedValue = 0x0000U;
		dtrspTestResult->wCheckId = 1U;

		sitalProcess_SetInterruptServiceRoutine ((ISR_FUNCTION)NULL);

		return sitalReturnCode_SUCCESS;
	}*/

	/// Wait enough time for the time tag interrupt to be detected and for the ISR to be called.
	U32BIT dwMaximumInterruptLatency; // The maximum possible interrupt latency (milliseconds) for the current combination of process and operating-system.
	swResult = sitalProcess_GetInterruptLatency (&dwMaximumInterruptLatency);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		swResult = sitalProcess_Log_PrintLine ("#StldTester.Process.InterruptLatency.Get.Warning: error - %i\n", swResult);
		dwMaximumInterruptLatency = 1000U; // 1000 milliseconds.
	}
	Sleep_NonOsDependent(dwMaximumInterruptLatency);

	///	Verify that the expected time tag rollover interrupt has really been issued.
	if (
			(1U != dsspDeviceState->dwInterruptCount)
		||
			((sitalInterruptRegister1_MASTER_INTERRUPT | sitalInterruptRegister1_TIME_TAG_ROLLOVER) != ((sitalInterruptRegister1_MASTER_INTERRUPT | sitalInterruptRegister1_TIME_TAG_ROLLOVER) & dsspDeviceState->dwIrqStatus))
	   )
	{
		//S16BIT swResult; // Result of operation or function call.
		swResult = sitalProcess_Log_PrintLine ("#StldDll.Test.Interrupts.TimeTag.Error: device - %i, count - %i, irq_status - %08X\n", swDevice, dsspDeviceState->dwInterruptCount, dsspDeviceState->dwIrqStatus);
		dtrspTestResult->wResult = sitalDeviceTestResult_INTERRUPT_FAIL;
		dtrspTestResult->wDeviceMemoryAddress = sitalRegisterAddress_INTERRUPT_MASK_1;
		dtrspTestResult->wActualValue = (U16BIT)dsspDeviceState->dwIrqStatus;
		dtrspTestResult->wExpectedValue = (sitalInterruptRegister1_MASTER_INTERRUPT | sitalInterruptRegister1_TIME_TAG_ROLLOVER);
		dtrspTestResult->wCheckId = 2U;

		sitalProcess_SetInterruptServiceRoutine ((ISR_FUNCTION)NULL);

		return sitalReturnCode_SUCCESS;
	}

	///	Unset the previously installed internal ISR for given device.
	swResult = sitalProcess_SetInterruptServiceRoutine ((ISR_FUNCTION)device_TestIsr);

	/// Set proper test result.
	dtrspTestResult->wResult = sitalDeviceTestResult_PASS;

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Reset given device and perform device vector test.
/// All the test vectors that are available in given vector file will be retrieved one at a time, and applied to given device hardware.
/// While applying these vectors, in case a "read" vector is detected, it will be ensured that the involved register or memory contains the expected value.
///
/// Note:
/// - In case given device has been initialized as:
///   - A test device: It must be in state "ready", and a h/w reset will be performed before starting the test.
///   - An operative device (BC, RT, MT, or RT&MT): It must be in either state "ready" or "run", and a h/w reset won't be performed before starting the test.
/// - A line in the vector file is ignored unless beginning with a 'V' and describing a legal vector.
/// - A legal vector is made of the following components:
///   - A character that designates the type test operation, read ('R') or write ('W').
///     A test operation of type "write" does no test: It simply writes a desired value into a specific address in prepare to a following "read" test operation.
///     A test operation of type "read" verifies that the expected value is held in a specific address.
///   - A character that designates the target section of the test operation, registers ('R') or RAM ('M').
///   - A hexadecimal word (a 4-digit zero-padded number) that designates the target address in the target section.
///   - A hexadecimal word (a 4-digit zero-padded number) that designates in case of a test of type:
///     - "write": The value to write to the target address in the target section.
///     - "read": The value expected to be read from the target address in the target section.
/// - Here are sample legal vector lines:
///   - "V W R 0000 FFFF"
///   - "V R R 0000 FFFF"
///   - "V W M 1234 ABCD"
///   - "V R M 1234 ABCD"
/// - Though any line not beginning with 'V' is ignored, the caller is urged to comment-out lines using a starting 'D'.
/// - The following check-IDs are returned by this function:
///   - In case of test failures: The number (1, 2, 3, ...) of the line in given vectors file whose test failed.
///   - In case all vector tests succeeded: The total number of lines in given file.
///
/// Equivalent DDC definition: aceTestVectors
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param dtrspTestResult (in)	A pointer to a structure within which the test result is returned
/// @param szpVectorsFilePath (in)	A pointer to a null-terminated string that contains the path of the vector file to use for the test
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalDevice_Test_Vectors (S16BIT swDevice, sitalDeviceTestResultStructure* dtrspTestResult, char* szpVectorsFilePath)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalMode_TEST == dsspDeviceState->wMode)
	{
		if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
		{
			return sitalReturnCode_INVALID_STATE;
		}
	}
	else
	{
		if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
		{
			return sitalReturnCode_INVALID_STATE;
		}
	}

	if (sitalAccess_CARD != dsspDeviceState->wAccess)
	{
		return sitalReturnCode_INVALID_ACCESS;
	}

	if (((sitalDeviceTestResultStructure*)NULL) == dtrspTestResult)
	{
		return sitalReturnCode_INVALID_TEST_STRUCTURE;
	}

	if (((S8BIT*)NULL) == szpVectorsFilePath)
	{
		return sitalReturnCode_INVALID_FILE;
	}

	FILE* fpVectorsFile; // A pointer to a vectors file object.
	fpVectorsFile = fopen (szpVectorsFilePath, "r");
	if (((FILE*)NULL) == fpVectorsFile)
	{
		return sitalReturnCode_INVALID_FILE;
	}

	/// Zero given test result structure.
	memset (dtrspTestResult, 0, sizeof(sitalDeviceTestResultStructure));

	///	Reset given device.
	U16BIT wRegisterValue; // The current value of a target register, or the value to set for a target register.
	wRegisterValue = sitalStartResetRegister_RESET;
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_START_OR_RESET, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Read given vectors file line by line:
	char szLineBuffer[sitalDeviceVectorTest_MAXIMUM_NUMBER_OF_CHARACTERS_IN_A_LINE_OF_THE_VECTORS_FILE + 1]; // A buffer to read into the next processed line in given vectors file.
	U32BIT dwLineCount; // The number (1, 2, 3, ...) of the currently processed line in given vectors file, or, in the end, the total number of lines in given file.
	dwLineCount = 0U;
	S32BIT sdwNumberOfConvertedAndAssignedFields; // The number of fields that have been successfully converted and assigned while scanning the currently processed line of the vectors file.
	char cTypeOfLine; // The first character in the currently processed line of the vectors file, which designates the type of the contents of this line, vector ('V') or comment ('D').
	char cIoOperation; // The second character in the currently processed line of the vectors file, which designates the type test operation, read ('R') or write ('W').
	char cTargetSection; // The third character in the currently processed line of the vectors file, which designates the target of the test operation, registers ('R') or RAM ('M').
	S32BIT sdwDeviceAddress; // The address of a word in the target section of device memory.
	S32BIT sdwVectorValue; // The assumed value of a target memory word, or the value to set for a target memory word.
	U16BIT wMemoryValue; // The current value of a target memory word, or the value to set for a target memory word.
	BOOLEAN bLegalTestOperation; // A flag that says whether a legal test operation is requested.
	sitalDeviceAccessOperationEnum daoeAccessType; // The desired type of device access operation.
	daoeAccessType = sitalDeviceAccessOperation_Read;
	sitalDeviceMemorySectionEnum dmseAccessedSection; // The target section of device memory.
	dmseAccessedSection = sitalDeviceMemorySection_Ram;
	U16BIT wReadTestFailResult; // The result to report in case requested "read" test operation fails.
	wReadTestFailResult = sitalDeviceTestResult_PASS;
	int iResult; // Result of operation or function call.
	while (((char*)NULL) != fgets (szLineBuffer, sitalDeviceVectorTest_MAXIMUM_NUMBER_OF_CHARACTERS_IN_A_LINE_OF_THE_VECTORS_FILE, fpVectorsFile))
	{
		dwLineCount++;

		///		If no field has been successfully converted and assigned while scanning the currently processed line of the vectors file:
		///			Ignore this line.
		sdwNumberOfConvertedAndAssignedFields = sscanf (szLineBuffer,"%c  %c  %c  %x  %x", &cTypeOfLine, &cIoOperation, &cTargetSection, &sdwDeviceAddress, &sdwVectorValue);
		(*szLineBuffer) = '\0';
		if ((S32BIT)0U < sdwNumberOfConvertedAndAssignedFields)
		{
			if ( ((S32BIT)dsspDeviceState->dcsDeviceCapabilities.dwRamSize <= sdwDeviceAddress) || ((S32BIT)0xFFFFU < sdwVectorValue) )
			{
				iResult = fclose (fpVectorsFile);

				return sitalReturnCode_INVALID_PARAMETER;
			}

			///		If the type of the currently processed line of the vectors file is not "vector":
			///			Ignore this line.
			if ('V' == cTypeOfLine)
			{
				///		Diagnose the requested i/o operation and device memory section.
				///		If the requested i/o operation or the requested device memory section is illegal:
				///			Ignore this line.
				bLegalTestOperation = TRUE;
				switch (cIoOperation)
				{
				case 'R':	daoeAccessType = sitalDeviceAccessOperation_Read;	break;
				case 'W':	daoeAccessType = sitalDeviceAccessOperation_Write;	wMemoryValue = (U32BIT)sdwVectorValue;	break;
				default:	bLegalTestOperation = FALSE;
				}
				switch (cTargetSection)
				{
				case 'R':	dmseAccessedSection = sitalDeviceMemorySection_Registers;	wReadTestFailResult = sitalDeviceTestResult_REGISTER_READ_VECTOR_FAIL;	break;
				case 'M':	dmseAccessedSection = sitalDeviceMemorySection_Ram;	wReadTestFailResult = sitalDeviceTestResult_MEMORY_READ_VECTOR_FAIL;	break;
				default:	bLegalTestOperation = FALSE;
				}
				if (bLegalTestOperation)
				{
					///		Perform the requested test operation.
					swResult = sitalDevice_AccessMemory	(swDevice, daoeAccessType, (U32BIT)sdwDeviceAddress, dmseAccessedSection, (U32BIT)1U, &wMemoryValue);
					if (sitalReturnCode_SUCCESS != swResult)
					{
						iResult = fclose (fpVectorsFile);

						return swResult;
					}
					if ( ('R' == cIoOperation) && (sdwVectorValue != wMemoryValue) )
					{
						dtrspTestResult->wResult = wReadTestFailResult;
						dtrspTestResult->wDeviceMemoryAddress = sdwDeviceAddress;
						dtrspTestResult->wActualValue = wMemoryValue;
						dtrspTestResult->wExpectedValue = sdwVectorValue;
						dtrspTestResult->wCheckId = (U16BIT)dwLineCount;

						iResult = fclose (fpVectorsFile);

						return sitalReturnCode_SUCCESS;
					}
				}
			}
		}
	}

	iResult = fclose (fpVectorsFile);

	/// Set proper test result.
	dtrspTestResult->wResult = (U16BIT)sitalDeviceTestResult_PASS;
	dtrspTestResult->wCheckId = (U16BIT)dwLineCount;

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Initialize given device as a BC in accordance with given initialization options.
/// Release any past allocations of device memory.
///
/// Note:
/// - This function assumes that function sitalDevice_Initialize has already been called, initialized given device, and inquired its capabilities.
///   This function then lets the user reinitialize given device with a non default configuration.
///
/// Equivalent DDC definition: aceBCConfigure
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param dwOptions (in)	Initialization options (An or-ed combination of sitalBcSetupOption_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_Initialize (S16BIT swDevice, U32BIT dwOptions)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	/// Clear device memory.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Zero, 0, sitalDeviceMemorySection_Ram, dsspDeviceState->dcsDeviceCapabilities.dwRamSize, ((U16BIT*)NULL));
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Initialize device memory management.
	swResult = Device_Memory_Initialize (&(dsspDeviceState->hdmmsDeviceMemoryMap), dsspDeviceState->dcsDeviceCapabilities.dwRamSize);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Catch any permanently allocated regions of device memory.
	swResult = Device_Memory_TopSection_CatchRegion (&(dsspDeviceState->hdmmsDeviceMemoryMap), 0U, (bcAddressMap_FREE_MEMORY - 1U));

	/// Locate the GPQ at the desired address.
	swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_BC_GENERAL_PURPOSE_QUEUE_POINTER, (U16BIT)registerMask_ALL_BITS_ON, (U16BIT)bcAddressMap_GPQ);


	/// Initialize BC state.
	dsspDeviceState->bsBcState.dwOptions = dwOptions;
	dsspDeviceState->bsBcState.wWatchDogTimeout = (U16BIT)0U;
	dsspDeviceState->bsBcState.hfspRunningMajorFrame = ((HostFrameStructure*)NULL);
	dsspDeviceState->bsBcState.wAsynchronousMessagesCount = (U16BIT)0U;

	memset (&(dsspDeviceState->bsBcState.hbsHostBuffer), 0, sizeof(HostBufferStructure));

	memset (&(dsspDeviceState->bsBcState.gpqssGpqState), 0, sizeof(GeneralPurposeQueueStateStructure));

	dsspDeviceState->bsBcState.hgpqsUserGpqContents.wIndexOfNextReadGpqEntry = 0U;
	dsspDeviceState->bsBcState.hgpqsUserGpqContents.wIndexOfNextFilledGpqEntry = 0U;
	sitalGpqEntryStructure* sgespCurrentGpqEntry; // A pointer to the currently initialized host GPQ entry.
	sgespCurrentGpqEntry = dsspDeviceState->bsBcState.hgpqsUserGpqContents.sgesaHostGpq;
	for (U32BIT i=0; i<sitalBcCounter_GPQ_ENTRIES; i++)
	{
		sgespCurrentGpqEntry->wHeader = 0U;
		sgespCurrentGpqEntry->wData = 0U;
		sgespCurrentGpqEntry++;
	}

	dsspDeviceState->bsBcState.hgpqsLibraryGpqContents.wIndexOfNextReadGpqEntry = 0U;
	dsspDeviceState->bsBcState.hgpqsLibraryGpqContents.wIndexOfNextFilledGpqEntry = 0U;
	sgespCurrentGpqEntry = dsspDeviceState->bsBcState.hgpqsLibraryGpqContents.sgesaHostGpq;
	for (U32BIT iGpqEntryIndex=0; iGpqEntryIndex<sitalBcCounter_GPQ_ENTRIES; iGpqEntryIndex++)
	{
		sgespCurrentGpqEntry->wHeader = 0U;
		sgespCurrentGpqEntry->wData = 0U;
		sgespCurrentGpqEntry++;
	}

	/// Initialize any relevant object definitions.
	for (U32BIT iDataBlockIndex=0; iDataBlockIndex<sitalBcCounter_DATA_BLOCKS; iDataBlockIndex++)
	{
		dsspDeviceState->bsBcState.hdbsaDataBlock[iDataBlockIndex].bIsFreeForUse = TRUE;
	}
	for (U32BIT iMessageIndex=0; iMessageIndex<sitalBcCounter_MESSAGES; iMessageIndex++)
	{
		dsspDeviceState->bsBcState.hmsaMessage[iMessageIndex].bIsFreeForUse = TRUE;
	}
	for (U32BIT iCommandIndex=0; iCommandIndex<sitalBcCounter_COMMANDS; iCommandIndex++)
	{
		dsspDeviceState->bsBcState.hcsaCommand[iCommandIndex].bIsFreeForUse = TRUE;
	}
	for (U32BIT iFrameIndex=0; iFrameIndex<sitalBcCounter_FRAMES; iFrameIndex++)
	{
		dsspDeviceState->bsBcState.hfsaFrame[iFrameIndex].bIsFreeForUse = TRUE;
	}

	/// In case of a real device:
	///		Set a suitable internal ISR.
	///		Configure the user's interrupt mask pseudo register in accordance with the configured support in high priority asynchronous messaging.
	if (sitalAccess_CARD == dsspDeviceState->wAccess)
	{
		swResult = sitalProcess_SetInterruptServiceRoutine ((ISR_FUNCTION)bc_HandleInterrupt);

		if (sitalBcSetupOption_ASYNCHRONOUS_HIGH_PRIORITY_MODE == (sitalBcSetupOption_ASYNCHRONOUS_HIGH_PRIORITY_MODE & dwOptions))
		{
			dsspDeviceState->dwInternalImr |= (sitalInterruptRegister2_BC_IRQ2 | sitalInterruptRegister2_BC_IRQ3);
		}
		else
		{
			dsspDeviceState->dwInternalImr |= sitalInterruptRegister2_BC_IRQ3;
		}
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Configure the message retry policy of given BC device to given number of retries and given first and second chance bus to retry the message with.
///
/// Note:
/// - In order to make a BC device retry a message in case of error, all the following terms must be matched:
///   - Function sitalBc_MessageRetryPolicy_Set has been called to configure the BC device with a suitable number of retries and actually available retry buses.
///   - Each of the messages that should be retried on error has been defined with option sitalBcControlWord_RETRY_ENABLED upon its creation using function sitalBc_Message_Create* (or similarly modified after creation using function italBc_Message_Modify*).
///
///
/// Equivalent DDC definition: aceBCSetMsgRetry
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wNumberOfRetries (in)	Desired number of retries on message failure (sitalMessageRetryCount_*)
/// @param wFirstRetryBus (in)	The bus to retry the message with in the first time in case of message failure (sitalMessageRetryBus_*)
/// @param wSecondRetryBus (in)	The bus to retry the message with in the second time in case of message failure (sitalMessageRetryBus_*)
/// @param wReserved (in)	Reserved for future use
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_MessageRetryPolicy_Set (	S16BIT swDevice,
												U16BIT wNumberOfRetries,
												U16BIT wFirstRetryBus,
												U16BIT wSecondRetryBus,
												U16BIT wReserved)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((0U > wNumberOfRetries) || (messageRetryCount_BORDER <= wNumberOfRetries))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if ((0U > wFirstRetryBus) || (messageRetryBus_BORDER <= wFirstRetryBus))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if ((0U > wSecondRetryBus) || (messageRetryBus_BORDER <= wSecondRetryBus))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Configure the retry count as requested.
	S16BIT swResult; // Result of operation or function call.
	swResult = device_Register_UpdateImage	(
												swDevice,
												(U16BIT)sitalRegisterAddress_CONFIGURATION_1,
												(U16BIT)sitalConfigurationRegister1_BC_RETRY_MASK,
												(
													(sitalMessageRetryCount_NONE == wNumberOfRetries) ?
														(U16BIT)registerMask_ALL_BITS_OFF
														:
														(
															(sitalMessageRetryCount_ONE == wNumberOfRetries) ?
																(U16BIT)sitalConfigurationRegister1_BC_SINGLE_RETRY_ENABLED
																:
																(U16BIT)sitalConfigurationRegister1_BC_DOUBLE_RETRY_ENABLED
														)
												)
											);

	/// Configure the bus used on the first retry.
	swResult = device_Register_UpdateImage	(
												swDevice,
												(U16BIT)sitalRegisterAddress_CONFIGURATION_4,
												(U16BIT)sitalConfigurationRegister4_BC_RETRY_BUS_1,
												(
													(U16BIT)(sitalMessageRetryBus_SAME == wFirstRetryBus) ?	registerMask_ALL_BITS_OFF : registerMask_ALL_BITS_ON
												)
											);

	/// Configure the bus used on the second retry.
	swResult = device_Register_UpdateImage	(
												swDevice,
												(U16BIT)sitalRegisterAddress_CONFIGURATION_4,
												(U16BIT)sitalConfigurationRegister4_BC_RETRY_BUS_2,
												(
													(U16BIT)(sitalMessageRetryBus_SAME == wSecondRetryBus) ?	registerMask_ALL_BITS_OFF : registerMask_ALL_BITS_ON
												)
											);

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Make given BC device start running given major frame for given number of times.
///
/// Note:
/// - A major frame may only be run directly using function sitalBc_Start.
/// - A major frame may not be contained within any frame, neither within itself, nor within another major frame, nor within any minor frame.
/// - A major frame may contain nested minor frames, and each contained minor frame may in its turn contain other minor frames.
/// - A minor frame may not be contained within itself, either directly or indirectly.
///   Here are examples of forbidden frame nesting stacks:
///   - Major frame 1 >> Minor frame 2 >> Minor frame 2
///   - Major frame 1 >> Minor frame 2 >> Minor frame 3 >> Minor frame 2
///   In order to verify that this rule isn't overridden by the caller, a tracking nesting stack is used, which is a stack that tracks the state of
///   frame nesting. In other words, this stack is properly updated all along the process of building the requested major frame in device memory in
///   order to always reflect the current stack of nested frames. For example, if major frame 1 contains minor frame 2, and minor frame 2 contains
///   minor frame 3, then when reaching minor frame 3 the nesting stack will be (1, 2, 3).
///   A demand imposed by the device is that any moment along this process the size of the nesting stack may not exceed sitalBcMaximum_FRAME_NESTING_STACK.
/// - Though frame recursion is prevented using the above described mechanism, the caller still has to be careful not to create endless loops in its code.
/// - When a major frame is being created in device memory, special framing commands are added to those defined for it by the user;
///   \n Here's the framing scheme for major frames:
///   \n * The numbers at the left are logical word addresses.
///   \n * The 'F'-s at the left designate framing commands.
///   \n * The command is executed always where no condition is specified.
///   \n F 00 - Focus-variable No.8
///   \n F 01 - Load-focused-variable with the LSWord of iterations count
///   \n F 02 - Focus-variable No.9
///   \n F 03 - Load-focused-variable with the MSWord of iterations count
///   \n   04 - Perform the series of commands assigned for this frame by the user
///   \n        * 04 is the body of the loop that's performed by the major frame.
///   \n F 05 - Jump always(if running forever)-or-never(if running 1 or more times) to-address-04
///   \n F 06 - Focus-variable No.8
///   \n F 07 - Decrement-focused-variable by-1
///   \n F 08 - Compare-focused-variable to-zero
///   \n F 09 - Jump if-not-equal to-address-04
///   \n F 10 - Focus-variable No.9
///   \n F 11 - Compare-focused-variable to-zero
///   \n F 12 - Jump if-equal to-address-15
///   \n F 13 - Decrement-focused-variable by-1
///   \n F 14 - Jump to-address-04
///   \n F 15 - Push-to-general-purpose-queue major-frame-ended-flag
///   \n F 16 - Push-to-general-purpose-queue major-frame-ID
///   \n F 17 - Halt
///   \n
///   \n
///   These framing commands may be divided into groups as follows:
///   - Group A - Loop commands (14):
///     - Commands that make the major frame repeat itself for the requested number of times (one or more, or even forever).
///     - Relevant: Always.
///   - Group B - Report commands (2):
///     - Commands that are aimed at reporting the user via the GPQ about the end of another iteration of the major frame.
///     - Relevant: Always.
///   - Group C - A closing halt command (1):
///     - Relevant: Always.
///   These sum up to a total of 17 commands.
///   NOTICE: As may be seen above, hardware variables 8 & 9 are used by this library for framing major frames;
///           They shouldn't, therefore, be used for any other purpose.
/// - When a minor frame is being created in device memory, special framing commands are added to those defined for it by the user.
///   \n Here's the framing scheme for minor frames:
///   \n * The numbers at the left are logical word addresses.
///   \n * The 'F'-s at the left designate framing commands.
///   \n * The command is executed always where no condition is specified.
///   \n * Some of the framing commands are required only in certain conditions. Nevertheless, for the sake of simplicity and uniformity all framing commands are always added, just that suitable conditions are added.
///   \n F 00 - Load-frame-time
///   \n F 01 - Start-frame-time
///   \n   02 - Perform the series of commands assigned for this frame by the user
///   \n        * Above mentioned series is usually a series of message execution commands.
///   \n F 03 - Call if-GPF-7-is-on(if low priority asynchronous message Tx is supported)-or-never(otherwise) the-low-priority-asynchronous-message-Tx-subroutine
///   \n F 04 - Push-to-general-purpose-queue minor-frame-ended-flag
///   \n F 05 - Push-to-general-purpose-queue minor-frame-ID
///   \n F 06 - Issue-interrupt always(if interrupts are supported with given minor frame)-or-never(otherwise) IRQ-3
///   \n F 07 - Compare-frame-time always(if high priority asynchronous message Tx is supported)-or-never(otherwise) to-expected-time
///   \n F 08 - Push-to-general-purpose-queue if-greater-than(if high priority asynchronous message Tx is supported)-or-never(otherwise) frame-time-overflow-flag
///   \n F 09 - Push-to-general-purpose-queue if-greater-than(if high priority asynchronous message Tx is supported)-or-never(otherwise) minor-frame-ID
///   \n F 10 - Compare-frame-time to-expected-time
///   \n        * 10 starts a loop whose aim is to spend the required amount of passive time at the end of the current minor frame.
///   \n F 11 - Call if-GPF-6-is-on(if high priority asynchronous message Tx is supported)-or-never(otherwise) the-high-priority-asynchronous-message-Tx-subroutine
///   \n F 12 - Jump if-less-than to-address-10
///   \n F 13 - Issue-interrupt if-good-message(if both high priority asynchronous message Tx is supported and host buffer is assigned)-or-never(otherwise) IRQ-2
///   \n F 14 - Return
///   \n
///   \n
///   These framing commands may be divided into groups as follows:
///   - Group A - Frame time measuring commands (4):
///     - Commands that load the requested frame time, measure the active phase of the frame, and complete it with long enough passive phase.
///     - Relevant: Always.
///   - Group B - Report commands (2):
///     - Commands that are aimed at reporting the user via the GPQ about the end of another iteration of the minor frame and of the possibly following
///       low priority asynchronous messages.
///     - Relevant: Always.
///   - Group C - A closing return command (1):
///     - Relevant: Always.
///   - Group D - IRQ-3 interrupt command (1):
///     To sign the end of another iteration of the minor frame (including its active phase alone) together with the low (not high!) priority asynchronous
///     messages that possibly follow this minor frame.
///     - Relevant: Always (Indeed, interrupt is only issued in case IRQs aren't disabled for either this minor frame or its containing major frame, but
///       as the containing major frame and its configuration become known only once frame run is requested, and in order to determine already upon the
///       creation of a frame its overall size in device memory, this group will be always included, just that in cases where interrupts aren't enabled,
///       the relevant commands will be conditioned 'never').
///   - Group E - Low priority asynchronous messages Tx subroutine calling command (1):
///     - Relevant: If low priority asynchronous messages are supported.
///   - Group F - Time overflow report commands (3):
///     - Commands that are aimed at reporting the user via the GPQ about frame time overflow.
///     - Relevant: If high priority asynchronous messages are supported.
///   - Group G - High priority asynchronous message Tx subroutine calling command (1):
///     - To transmit the high priority asynchronous message along the passive phase.
///     - Relevant: If high priority asynchronous messages are supported.
///   - Group H - IRQ-2 interrupt command (1):
///     - To sign the end of another iteration of the minor frame (including both its active and passive phase) together with the low and high priority
///       asynchronous messages that possibly follow this minor frame.
///     - Relevant: If high priority asynchronous messages are supported (recall that the end of the minor frame itself and of the possibly following low
///       priority asynchronous messages has already been signed using IRQ-3), and a host buffer has been assigned to given device (this final interrupt is
///       merely used to update this host buffer).
///   These sum up to a total of 7 to 14 truly relevant commands.
/// - Calling the subroutines that perform the high & low priority asynchronous message Tx (including their initial stubs) is conditioned by GPF-6 &
///   GPF-7, respectively, being on; User applications should restrict themselves to never use GPF-6 and GPF-7!
/// - The subroutines that transmit asynchronous messages are both common to all the frames that take part in running given major frame.
///   With the subroutine that's dedicated to low priority asynchronous messages, the count of included asynchronous messages is anyway only determined at
///   the moment when their transmission is actually requested.
///   For these reasons, these subroutines aren't part of the major frame, nor of any of the nested minor frames.
/// - Function sitalBc_Start is an asynchronous function, and does not wait for given BC device to accomplish the transmission of all the requested frames.
///   Once function sitalBc_Start is called for some BC device, function sitalBc_Stop must be called in order to stop that BC, even if it already
///   completed the transmission of the requested number of frames.
///
/// Equivalent DDC definition: aceBCStart
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swFrameId (in)	A unique ID designating a frame (0-(sitalBcCounter_FRAMES-1))
/// @param sdwFrameCount (in)	The number of times given frame should be transmitted (zero also means single Tx), or sitalBcFrameIterations_RUN_FOREVER if the frame should be run forever (>=-1)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_Start (S16BIT swDevice, S16BIT swFrameId, S32BIT sdwFrameCount)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (((S16BIT)0U > swFrameId) || ((S16BIT)sitalBcCounter_FRAMES <= swFrameId))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	HostFrameStructure* hfspFrame; // A pointer to a host frame structure.
	hfspFrame = &(dsspDeviceState->bsBcState.hfsaFrame[swFrameId]);
	if (TRUE == hfspFrame->bIsFreeForUse)
	{
		return sitalReturnCode_UNDEFINED_NODE;
	}

	if (sitalBcFrameType_MAJOR != hfspFrame->wFrameType)
	{
		return sitalReturnCode_NOT_MAJOR_FRAME;
	}

	if (-1 > sdwFrameCount)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Loop over all the currently defined messages of given device:
	///		Set the data block address within the message block of each such message to point its data block.
	// Note that this update isn't really needed for the following reasons:
	// - Function bc_Message_Write already wrote the data block addresses within the messages.
	// - The data block[s] used by a message must be created before creating that message.
	// - There's no way to change the address of data blocks.
	// - A data block that is used by any messages may not be deleted until all these messages are deleted.
	// This update is nevertheless performed just in order to enable future changes in above policy of dealing with data blocks.
	S16BIT swResult; // Result of operation or function call.
	U16BIT wIoContents; // The variable into which the contents of a device word is read, or the variable whose contents are written to device.
	//swResult = sitalProcess_Log_PrintLine ("#StldDll.Bc.Start.MessageDataBlockAddresses.Write: unit - %i\n", swDevice);
	for (U32BIT i=0; i<sitalBcCounter_MESSAGES; i++)
	{
		HostMessageStructure* hmspMessage; // A pointer to a host message structure.
		hmspMessage = &(dsspDeviceState->bsBcState.hmsaMessage[i]);
		if (FALSE == hmspMessage->bIsFreeForUse)
		{
			HostDataBlockStructure* hdbspDataBlock; // A pointer to a host data block structure.
			hdbspDataBlock = &(dsspDeviceState->bsBcState.hdbsaDataBlock[hmspMessage->swDataBlockIdForMessage1]);

			// Function sitalBc_Message_Create verifies that given data block ID specifies an already defined data block.
			// Function sitalBc_DataBlock_Delete verifies that given data block, whose deletion is required, isn't used in any message.
			// Therefore, the following error condition must never be triggered.
			Assert_NonOsDependent(FALSE == hdbspDataBlock->bIsFreeForUse);

			//U16BIT wIoContents; // The variable into which the contents of a device word is read, or the variable whose contents are written to device.
			wIoContents = (U16BIT)hdbspDataBlock->dwAddress;
			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, (hmspMessage->dwAddress + bcMessageBlock_OFFSET_OF_DATA_BLOCK_ADDRESS), sitalDeviceMemorySection_Ram, 1U, &wIoContents);
			if (sitalReturnCode_SUCCESS != swResult)
			{
				return swResult;
			}
		}
	}

	/// If should explicitly reset the time tag:
	///		Reset the time tag.
	U16BIT wRegisterValue; // The current value of a target register, or the value to set for a target register.
	if (sitalModeVariant_NO_TIME_TAG_RESET != (sitalModeVariant_NO_TIME_TAG_RESET & dsspDeviceState->wModeVariants))
	{
		wRegisterValue = sitalStartResetRegister_RESET;
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_START_OR_RESET, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
	}

	/// Turn given device into enhanced mode.
	wRegisterValue = sitalConfigurationRegister3_ENHANCED_MODE;
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_CONFIGURATION_3, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Reset collected GPQ statistics.
	dsspDeviceState->bsBcState.gpqssGpqState.wIndexOfNextReadGpqEntry = 0U;
	dsspDeviceState->bsBcState.gpqssGpqState.wLostGpqEntryCount = 0U;
	dsspDeviceState->bsBcState.gpqssGpqState.wFullnessPercentage = 0U;

	/// Clear the library's internal GPQ.
	dsspDeviceState->bsBcState.hgpqsLibraryGpqContents.wIndexOfNextReadGpqEntry = 0U;
	dsspDeviceState->bsBcState.hgpqsLibraryGpqContents.wIndexOfNextFilledGpqEntry = 0U;
	memset (dsspDeviceState->bsBcState.hgpqsLibraryGpqContents.sgesaHostGpq, 0, sizeof(dsspDeviceState->bsBcState.hgpqsLibraryGpqContents.sgesaHostGpq));

	/// Clear the real GPQ that's in device memory.
	swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_BC_GENERAL_PURPOSE_QUEUE_POINTER, (U16BIT)registerMask_ALL_BITS_ON, (U16BIT)bcAddressMap_GPQ);
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, bcAddressMap_GPQ, sitalDeviceMemorySection_Ram, (sizeof(dsspDeviceState->bsBcState.hgpqsLibraryGpqContents.sgesaHostGpq) >> 1U), (U16BIT*)dsspDeviceState->bsBcState.hgpqsLibraryGpqContents.sgesaHostGpq);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Record given major frame and the required number of iterations.
	dsspDeviceState->bsBcState.hfspRunningMajorFrame = hfspFrame;
	dsspDeviceState->bsBcState.sdwMajorFrameIterationCount = ( ((S32BIT)0U == sdwFrameCount) ? (S32BIT)1U : sdwFrameCount );

	/// If high priority asynchronous messages are supported:
	///		Use the bottom section of device memory to allocate place for a high priority asynchronous message Tx subroutine.
	///		Build a stub high priority asynchronous message Tx subroutine in host memory.
	///		Copy the stub high priority asynchronous message Tx subroutine from host memory to device memory.
	/// In any case of failure to write to device memory:
	///		Release all device memory that has been allocated for the sake of building the frame.
	BOOLEAN bIsAllocationSuccessfullyAccomplished; // A flag that says whether the allocation actually succeeded.
	U32BIT dwAllocationBaseAddress; // The address in device memory where a suitable segment of memory has been allocated for the newly created object.
	U32BIT dwAllocationSize; // The size of the allocation of device memory that's required for the newly created object.
	S16BIT swUnusedResult; // Result of operation or function call.
	U16BIT* wpCurrentWrittenWord; // A pointer to the currently written word.
	if (sitalBcSetupOption_ASYNCHRONOUS_HIGH_PRIORITY_MODE == (sitalBcSetupOption_ASYNCHRONOUS_HIGH_PRIORITY_MODE & dsspDeviceState->bsBcState.dwOptions))
	{
		//swResult = sitalProcess_Log_PrintLine ("#StldDll.Bc.Start.Async.Hi.Sub.Write: unit - %i\n", swDevice);
		dwAllocationSize = (asynchronousMessaging_HIGH_PRIORITY_MESSAGE_TX_COMMAND_COUNT * bcMemoryObjectSize_COMMAND);
		swResult = Device_Memory_BottomSection_AllocateContinuity (&(dsspDeviceState->hdmmsDeviceMemoryMap), &dwAllocationSize, 5U, &bIsAllocationSuccessfullyAccomplished, &dwAllocationBaseAddress);
		if ( (sitalReturnCode_SUCCESS != swResult) || (FALSE == bIsAllocationSuccessfullyAccomplished) )
		{
			return sitalReturnCode_ALLOCATION_FAIL;
		}

		// As no high priority asynchronous message has been designated for Tx yet, a stub subroutine is created.
		// Asynchronous messages are transmitted using a XQF message that's conditioned with "good message", so that the desired flip to the other message of the dual message takes place only upon Tx success.
		// This stub subroutine does not really point to any message: Only once the user requests the actual Tx of some specific high priority asynchronous message, will the XQF command be properly updated.
		// It is assumed here that this subroutine won't be called until finalized upon user request, what's achieved by conditioning its call with GFP-6 on.
		U16BIT waHostHighAsynchronousTxSubroutine[asynchronousMessaging_HIGH_PRIORITY_MESSAGE_TX_COMMAND_COUNT * bcMemoryObjectSize_COMMAND]; // Helper host buffer that prepares a writing to device.
		memset (waHostHighAsynchronousTxSubroutine, 0, sizeof(waHostHighAsynchronousTxSubroutine));
		//U16BIT* wpCurrentWrittenWord; // A pointer to the currently written word.
		wpCurrentWrittenWord = waHostHighAsynchronousTxSubroutine;
		swResult = sitalBc_Command_GetWord (sitalOpcode_EXECUTE_AND_FLIP, sitalOpcodeCondition_GOOD_MESSAGE, wpCurrentWrittenWord);
		wpCurrentWrittenWord += bcMemoryObjectSize_COMMAND;
		// NB - 9.1.2017 - added send once high async message, regardless flip on good
		if((sitalBcSetupOption_ASYNCHRONOUS_HIGH_PRIORITY_ONCE_ANYWAY & dsspDeviceState->bsBcState.dwOptions) == sitalBcSetupOption_ASYNCHRONOUS_HIGH_PRIORITY_ONCE_ANYWAY){
			swResult = sitalBc_Command_GetWord (sitalOpcode_UPDATE_GENERAL_PURPOSE_FLAG, sitalOpcodeCondition_ALWAYS, wpCurrentWrittenWord);
			wpCurrentWrittenWord++;
			(*wpCurrentWrittenWord) = (U16BIT)(0x0100U << 0x6); // Clear specified GPF.
			wpCurrentWrittenWord++;
		}
		swResult = sitalBc_Command_GetWord (sitalOpcode_RETURN_FROM_SUBROUTINE, sitalOpcodeCondition_ALWAYS, wpCurrentWrittenWord);

		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, dwAllocationBaseAddress, sitalDeviceMemorySection_Ram, dwAllocationSize, waHostHighAsynchronousTxSubroutine);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			swUnusedResult = Device_Memory_BottomSection_FreeAll (&(dsspDeviceState->hdmmsDeviceMemoryMap));
			return swResult;
		}

		dsspDeviceState->bsBcState.dwAddressOfHighAsynchronousTxSubroutine = dwAllocationBaseAddress;
		dsspDeviceState->bsBcState.dwLastAddressOfHighAsynchronousTxSubroutine = (dwAllocationBaseAddress + ((asynchronousMessaging_HIGH_PRIORITY_MESSAGE_TX_COMMAND_COUNT * bcMemoryObjectSize_COMMAND) - 1U));
	}

	/// Sign all frames as not yet actually created in device memory.
	HostFrameStructure* hfspCurrentFrame; // A pointer to the currently dealt with frame.
	hfspCurrentFrame = dsspDeviceState->bsBcState.hfsaFrame;
	for (U16BIT iFrameIndex=0U; iFrameIndex<sitalBcCounter_FRAMES; iFrameIndex++, hfspCurrentFrame++)
	{
		hfspCurrentFrame->wActualSize = 0U;
	}

	/// Sign all data blocks as not used by a message that gets transmitted by some XQF command.
	HostDataBlockStructure* hdbspCurrentDataBlock; // A pointer to the currently dealt with data block.
	hdbspCurrentDataBlock = dsspDeviceState->bsBcState.hdbsaDataBlock;
	for (U16BIT iDataBlockIndex=0U; iDataBlockIndex<sitalBcCounter_DATA_BLOCKS; iDataBlockIndex++, hdbspCurrentDataBlock++)
	{
		hdbspCurrentDataBlock->dwOwnerMessageXqfCommandAddress = 0U;
	}

	/// Create an empty nesting stack.
	NestingStackStructure nssNestingStack; // A nesting stack.
	nssNestingStack.wCurrentSizeOfStack = 0U;

	/// Reset the total number of minor frames that are directly/indirectly nested in the currently executed major frame.
	dsspDeviceState->bsBcState.wNestedMinorFrameCount = 0U;

	/// Write given major frame (and its nested minor frames) in device memory.
	swResult = bc_Frame_Write (swDevice, (U16BIT)swFrameId, &nssNestingStack);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		swUnusedResult = Device_Memory_BottomSection_FreeAll (&(dsspDeviceState->hdmmsDeviceMemoryMap));
		return swResult;
	}

	/// If low priority asynchronous messages are supported and there are any minor frames nested in given major frame:
	///		Use the bottom section of device memory to allocate place for a low priority asynchronous message Tx subroutine.
	///		Build a stub low priority asynchronous message Tx subroutine in host memory.
	///		Copy the stub low priority asynchronous message Tx subroutine from host memory to device memory.
	///		Record the address of the low priority asynchronous messages Tx subroutine as the parameter of corresponding subroutine call commands.
	if (sitalBcSetupOption_ASYNCHRONOUS_LOW_PRIORITY_MODE == (sitalBcSetupOption_ASYNCHRONOUS_LOW_PRIORITY_MODE & dsspDeviceState->bsBcState.dwOptions))
	{
		if (0U != dsspDeviceState->bsBcState.wNestedMinorFrameCount)
		{
			// As no low priority asynchronous message has been designated for Tx yet, a stub subroutine is created.
			// This stub subroutine is an empty subroutine, i.e., merely contains a return command.
			// Once the user requests the actual Tx of defined low priority asynchronous message, a suitable replacing subroutine will be created.
			//swResult = sitalProcess_Log_PrintLine ("#StldDll.Bc.Start.Async.Lo.Sub.Write: unit - %i, nested_minor_frms_count - %i\n", swDevice, dsspDeviceState->bsBcState.wNestedMinorFrameCount);
			dwAllocationSize = (asynchronousMessaging_STUB_LOW_PRIORITY_MESSAGE_TX_COMMAND_COUNT * bcMemoryObjectSize_COMMAND);
			swResult = Device_Memory_BottomSection_AllocateContinuity (&(dsspDeviceState->hdmmsDeviceMemoryMap), &dwAllocationSize, 5U, &bIsAllocationSuccessfullyAccomplished, &dwAllocationBaseAddress);
			if ( (sitalReturnCode_SUCCESS != swResult) || (FALSE == bIsAllocationSuccessfullyAccomplished) )
			{
				swUnusedResult = Device_Memory_BottomSection_FreeAll (&(dsspDeviceState->hdmmsDeviceMemoryMap));
				return sitalReturnCode_ALLOCATION_FAIL;
			}

			U16BIT waHostLowAsynchronousTxSubroutine[asynchronousMessaging_STUB_LOW_PRIORITY_MESSAGE_TX_COMMAND_COUNT * bcMemoryObjectSize_COMMAND]; // Helper host buffer that prepares a writing to device.
			memset (waHostLowAsynchronousTxSubroutine, 0, sizeof(waHostLowAsynchronousTxSubroutine));
			//U16BIT* wpCurrentWrittenWord; // A pointer to the currently written word.
			wpCurrentWrittenWord = waHostLowAsynchronousTxSubroutine;
			swResult = sitalBc_Command_GetWord (sitalOpcode_RETURN_FROM_SUBROUTINE, sitalOpcodeCondition_ALWAYS, wpCurrentWrittenWord);

			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, dwAllocationBaseAddress, sitalDeviceMemorySection_Ram, dwAllocationSize, waHostLowAsynchronousTxSubroutine);
			if (sitalReturnCode_SUCCESS != swResult)
			{
				swUnusedResult = Device_Memory_BottomSection_FreeAll (&(dsspDeviceState->hdmmsDeviceMemoryMap));
				return swResult;
			}

			dsspDeviceState->bsBcState.dwAddressOfLowAsynchronousTxSubroutine = dwAllocationBaseAddress;
			dsspDeviceState->bsBcState.dwLastAddressOfLowAsynchronousTxSubroutine = (dwAllocationBaseAddress + ((asynchronousMessaging_STUB_LOW_PRIORITY_MESSAGE_TX_COMMAND_COUNT * bcMemoryObjectSize_COMMAND) - 1U));
			dsspDeviceState->bsBcState.wSizeOfLowAsynchronousTxSubroutine = (U16BIT)dwAllocationSize;
			dsspDeviceState->bsBcState.wTotalTxTimeOfLowAsynchronousTxSubroutine = 0U;

			// Now that there's a temporary stub low priority asynchronous messages Tx subroutine, record its address as the parameter
			// of the corresponding subroutine call command for each of the minor frames that are nested in the executed major frame.
			// Indeed, recording these addresses isn't really required, as the condition set for these commands won't fulfill until Tx
			// of low priority asynchronous messages is actually requested by the user, a suitable subroutine is built, its address is
			// copied to the nested minor frames, and the proper general purpose flag is set. So below writing operations are really optional.
			U32BIT* dwpCurrentLowAsynchronousTxSubroutineCallAddress; // A pointer to the current entry in the array that stores the device memory addresses where the address of the low priority asynchronous messages Tx subroutine is recorded as parameter of call commands.
			dwpCurrentLowAsynchronousTxSubroutineCallAddress = dsspDeviceState->bsBcState.dwaLowAsynchronousTxSubroutineCallAddress;
			//U16BIT wIoContents; // The variable into which the contents of a device word is read, or the variable whose contents are written to device.
			wIoContents = (U16BIT)dsspDeviceState->bsBcState.dwAddressOfLowAsynchronousTxSubroutine;
			for (U16BIT iNestedMinorFrameIndex=0U; iNestedMinorFrameIndex<dsspDeviceState->bsBcState.wNestedMinorFrameCount; iNestedMinorFrameIndex++, dwpCurrentLowAsynchronousTxSubroutineCallAddress++)
			{
				swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, (*dwpCurrentLowAsynchronousTxSubroutineCallAddress), sitalDeviceMemorySection_Ram, 1U, &wIoContents);
				if (sitalReturnCode_SUCCESS != swResult)
				{
					swUnusedResult = Device_Memory_BottomSection_FreeAll (&(dsspDeviceState->hdmmsDeviceMemoryMap));
					return swResult;
				}
			}
		}
	}

	/// Set the instruction pointer to point given major frame in device memory.
	swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_BC_INITIAL_INSTRUCTION_POINTER, (U16BIT)registerMask_ALL_BITS_ON, (U16BIT)dsspDeviceState->bsBcState.hfspRunningMajorFrame->dwAddress);

	/// Copy the registers from host to device memory.
	swResult = device_Register_UpdateDevice (swDevice);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		swUnusedResult = Device_Memory_BottomSection_FreeAll (&(dsspDeviceState->hdmmsDeviceMemoryMap));
		return swResult;
	}

	/// Actually start the device.
	wRegisterValue = sitalStartResetRegister_BC_MT_START;
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_START_OR_RESET, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		swUnusedResult = Device_Memory_BottomSection_FreeAll (&(dsspDeviceState->hdmmsDeviceMemoryMap));
		return swResult;
	}

	/// Update the state of given device.
	//swResult = sitalProcess_Log_PrintLine ("#StldDll.Device.State.Change: device - %i, old - %i, new - %i\n", swDevice, dsspDeviceState->wCurrentState, sitalDeviceState_RUN);
	dsspDeviceState->wCurrentState = sitalDeviceState_RUN;

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Stop given BC device from transmitting frames, either at the end of the current message or at the end of the current frame (what comes first).
/// In case of a failure to do so, reset given device.
///
/// Note:
/// - Once function sitalBc_Start is called for some BC device, function sitalBc_Stop must be called in order to stop that BC, even if it already
///   completed the transmission of the requested number of frame.
///
/// Equivalent DDC definition: aceBCStop
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_Stop (S16BIT swDevice)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	// NB - 4.9.2018 - changing the flow to support internal memory blocks cleanup
	// NB - this line was added 15.7.14 -> to support stop of already stopped device without returning error
	/*if (sitalDeviceState_READY == dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_SUCCESS;
	}*/
	if (dsspDeviceState->wCurrentState != sitalDeviceState_READY){
		if (sitalDeviceState_RUN != dsspDeviceState->wCurrentState)
		{
			return sitalReturnCode_INVALID_STATE;
		}

		/// While given BC device didn't halt yet and for a predetermined maximum number of trials:
		///		Try/retry to normally stop given BC device.
		U16BIT uiStopTrialsDownCounter; // The number of BC stop trials still left.
		uiStopTrialsDownCounter = bcStopTrialsCount_MAXIMUM;
		U16BIT bIsBcOnHalt; // A flag that says whether given BC device has already halted.
		bIsBcOnHalt = FALSE;
		S16BIT swResult; // Result of operation or function call.
		U16BIT wRegisterValue; // The current value of a target register, or the value to set for a target register.
		do
		{
			uiStopTrialsDownCounter--;

			// Check whether given BC device has already halted.
			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, sitalRegisterAddress_CONFIGURATION_1, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
			if (sitalReturnCode_SUCCESS == swResult)
			{
				if (sitalConfigurationRegister1_BC_BUSY == (sitalConfigurationRegister1_BC_BUSY & wRegisterValue))
				{
					// given BC device is still running a frame.
					// Order it to stop at end of message/frame, what comes first (this would actually cause it to stop at the end of the current command).
					// Note:
					// The DDC library uses an alternative approach. It reads the current instruction pointer, and insert a halt command next to the current instruction.
					// This approach has some prominent disadvantages:
					// - Doing this does not guarantee that the BC stops, as the command before the inserted halt may be a branch command (e.g., a jump command).
					// - Though it seemingly would make no harm to overwrite a command that is part of the current frame, as the frame is recreated with each frame run,
					//   it is still possible that the address right after the current command contains a message, which will be spoiled by this writing operation.
					wRegisterValue = (sitalStartResetRegister_BC_MT_STOP_AT_END_OF_MESSAGE | sitalStartResetRegister_BC_STOP_AT_END_OF_FRAME);
					swResult = sitalDevice_AccessMemory (swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_START_OR_RESET, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
				}
				else
				{
					bIsBcOnHalt = TRUE;
				}
			}
		}
		while ((FALSE == bIsBcOnHalt) && (0U < uiStopTrialsDownCounter));

		/// If failed to stop given BC device:
		///		Reset it.
		if (FALSE == bIsBcOnHalt)
		{
			wRegisterValue = registerMask_ALL_BITS_OFF;
			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, sitalRegisterAddress_CONFIGURATION_6, sitalDeviceMemorySection_Registers, sitalConfigurationRegister6_BC_ENHANCED, &wRegisterValue);
			if (sitalReturnCode_SUCCESS != swResult)
			{
				return swResult;
			}
		}
	}
	/// Release all device memory that has been allocated when the frame was built.
	S16BIT swUnusedResult; // Result of operation or function call.
	swUnusedResult = Device_Memory_BottomSection_FreeAll (&(dsspDeviceState->hdmmsDeviceMemoryMap));
	//Device_Memory_TopSection_FreeRegion (&(dsspDeviceState->hdmmsDeviceMemoryMap), 0, (sitalMaximum_SIZE_OF_DEVICE_MEMORY - 1U));
	///// Re-catch all device memory that has been originally allocated for either permanent or dynamic usage.
	//Device_Memory_TopSection_CatchRegion (&(dsspDeviceState->hdmmsDeviceMemoryMap), 0, (bcAddressMap_FREE_MEMORY - 1U));
	//HostDataBlockStructure* hdbspDataBlock; // A pointer to a host's data block structure of a data block.
	//hdbspDataBlock = dsspDeviceState->bsBcState.hdbsaDataBlock;
	//for (S32BIT i=0; i<sitalBcCounter_DATA_BLOCKS; i++, hdbspDataBlock++)
	//{
	//	if (FALSE == hdbspDataBlock->bIsFreeForUse)
	//	{
	//		Device_Memory_TopSection_CatchRegion (&(dsspDeviceState->hdmmsDeviceMemoryMap), hdbspDataBlock->dwAddress, (hdbspDataBlock->dwAddress + hdbspDataBlock->wDeviceMemorySize - 1U));
	//	}
	//}
	//HostMessageStructure* hmspMessage; // A pointer to a host's message structure of a message.
	//hmspMessage = dsspDeviceState->bsBcState.hmsaMessage;
	//for (S32BIT i=0; i<sitalBcCounter_MESSAGES; i++, hmspMessage++)
	//{
	//	if (FALSE == hmspMessage->bIsFreeForUse)
	//	{
	//		Device_Memory_TopSection_CatchRegion (&(dsspDeviceState->hdmmsDeviceMemoryMap), hmspMessage->dwAddress, (hmspMessage->dwAddress + hmspMessage->wDeviceMemorySize - 1U));
	//	}
	//}

	//swResult = sitalProcess_Log_PrintLine ("#StldDll.Device.State.Change: device - %i, old - %i, new - %i\n", swDevice, dsspDeviceState->wCurrentState, sitalDeviceState_READY);
	dsspDeviceState->wCurrentState = sitalDeviceState_READY;

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Get the activation state, idle or busy, of given BC device.
///
/// Note:
/// - A BC device becomes busy when it starts running a frame, and automatically returns to be idle when all required frame iterations are finished (i.e., halt command reached).
///
/// Equivalent DDC definition: aceBCGetStatus
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wpCurrentState (out)	A pointer to a variable within which current state, idle (sitalBcActivationState_IDLE) or busy (sitalBcActivationState_BUSY), is returned
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_GetActivationState (S16BIT swDevice, U16BIT *wpCurrentState)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	U16BIT wRegisterValue; // The current value of a target register, or the value to set for a target register.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, sitalRegisterAddress_CONFIGURATION_1, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	
	//(*wpCurrentState) = (U16BIT)( (sitalConfigurationRegister1_BC_BUSY == (sitalConfigurationRegister1_BC_BUSY & wRegisterValue)) ? sitalBcActivationState_BUSY : sitalBcActivationState_IDLE );
	if(sitalConfigurationRegister1_BC_BUSY == (sitalConfigurationRegister1_BC_BUSY & wRegisterValue)) (*wpCurrentState) = sitalBcActivationState_BUSY;
	else (*wpCurrentState) = sitalBcActivationState_IDLE;
	if((*wpCurrentState) == sitalBcActivationState_IDLE)
		dsspDeviceState->wCurrentState = sitalDeviceState_READY;
	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Create for given BC device a data block of given ID and size, and fill its allocated device memory with the contents of given buffer.
///
/// Note:
/// - An actual data block may contain up to 32 data words, but this function automatically allocates 64 words of device memory for all data blocks.
/// - Its address/offset (in word) in device memory must be a number whose 5 LSBits are zeros.
/// - With data blocks that are used with mode code messages with data, the single data word is always read from or written into the first data word of the data block.
///
/// Equivalent DDC definition: aceBCDataBlkCreate
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swDataBlockId (in)	A unique ID designating a data block (0-(sitalBcCounter_DATA_BLOCKS-1))
/// @param wDataBlockSize (in)	The size (in words) of the new data block (1-32 or sitalBcDataBlockSizeOption_DOUBLE)
/// @param wapBuffer (in)	A pointer to an array of data words to be copied into the new data block, or NULL if this buffer isn't required
/// @param wBufferSize (in)	The size (in words) of the data buffer that is pointed by wapBuffer (0-wDataBlockSize)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_DataBlock_Create (	S16BIT swDevice,
										S16BIT swDataBlockId,
										U16BIT wDataBlockSize,
										U16BIT* wapBuffer,
										U16BIT wBufferSize)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		printf("\n\r error 0\n\r");
		return sitalReturnCode_INVALID_MODE;

	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (((S16BIT)0U > swDataBlockId) || ((S16BIT)sitalBcCounter_DATA_BLOCKS <= swDataBlockId))
	//sitalBcCounter_DATA_BLOCKS is 1u to support simplest board
	{
		//printf("\n\rhere error 1");
		return sitalReturnCode_INVALID_PARAMETER;
	}

	HostDataBlockStructure* hdbspDataBlock; // A pointer to a host data block structure.
	hdbspDataBlock = (HostDataBlockStructure*)&(dsspDeviceState->bsBcState.hdbsaDataBlock[swDataBlockId]);
	if (FALSE == hdbspDataBlock->bIsFreeForUse)
	{
		return sitalReturnCode_BC_OBJECT_ALREADY_EXISTS;
	}

	if ((0U >= wDataBlockSize) || (32U < wDataBlockSize))
	{
		if (sitalBcDataBlockSizeOption_DOUBLE == wDataBlockSize)
		{
			wDataBlockSize = bcMemoryObjectSize_DOUBLE_DATA_BLOCK;
		}
		else
		{
			//printf("\n\rhere error 2");
			return sitalReturnCode_INVALID_PARAMETER;
		}
	}

	if ((((U16BIT*)NULL) != wapBuffer) && (wBufferSize > wDataBlockSize))
	{
		//printf("\n\rhere error 3");
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Allocate and initialize a corresponding host structure for the new data block.
	// The longest possible data block is statically allocated for each data block, never mind what size of data block is actually requested.
	// The data block whose ID is i:
	// - Has a corresponding structure at host memory, i.e., the entry whose index is i within his device's data block array.
	U32BIT dwAllocationSize; // The size (in words) of the device memory allocation.
	dwAllocationSize = bcMemoryObjectSize_DOUBLE_DATA_BLOCK;
	BOOLEAN bIsAllocationSuccessfullyAccomplished; // A flag that says whether the allocation actually succeeded.
	U32BIT dwAllocationBaseAddress; // The address in device memory where a suitable segment of memory has been allocated for the newly created object.
	S16BIT swResult; // Result of operation or function call.
	swResult = Device_Memory_TopSection_AllocateContinuity ((HostDeviceMemoryMapStructure*)&(dsspDeviceState->hdmmsDeviceMemoryMap), bcAddressMap_FREE_MEMORY, (dsspDeviceState->dcsDeviceCapabilities.dwRamSize - 1U), &dwAllocationSize, 5, &bIsAllocationSuccessfullyAccomplished, &dwAllocationBaseAddress);
	if ( (sitalReturnCode_SUCCESS != swResult) || (FALSE == bIsAllocationSuccessfullyAccomplished) )
	{
		return sitalReturnCode_ALLOCATION_FAIL;
	}
	hdbspDataBlock->bIsFreeForUse = (BOOLEAN)FALSE;
	hdbspDataBlock->wId = (U16BIT)swDataBlockId;
	hdbspDataBlock->dwAddress = dwAllocationBaseAddress;
	hdbspDataBlock->wDeviceMemorySize = (U16BIT)dwAllocationSize;
	hdbspDataBlock->wActualSize = wDataBlockSize;
	hdbspDataBlock->dwNextAccessedDataWord = (U32BIT)0U;

	/// Copy given data words to device memory:
	if ((((U16BIT*)NULL) != wapBuffer) && ((U16BIT)0U < wBufferSize))
	{
		swResult = sitalBc_DataBlock_Write (swDevice, swDataBlockId, wapBuffer, wBufferSize, 0U);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			hdbspDataBlock->bIsFreeForUse = TRUE;
			return swResult;
		}
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Delete given data block which has been previously created for given BC device, and free the segment of device memory that has been allocated for it.
///
/// Note:
/// - A data block may be principally deleted along frame run in order to be compatible with DDC's library;
///   Yet, delete isn't supported if this data block is used by any existing message,
///   so that a situation in which a transmitted message tries to use an already deleted data block is prohibited.
///
/// Equivalent DDC definition: aceBCDataBlkDelete
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swDataBlockId (in)	A unique ID designating a data block (0-(sitalBcCounter_DATA_BLOCKS-1))
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_DataBlock_Delete (S16BIT swDevice, S16BIT swDataBlockId)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
		//printf("error 1");

	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (((S16BIT)0U > swDataBlockId) || ((S16BIT)sitalBcCounter_DATA_BLOCKS <= swDataBlockId))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	HostDataBlockStructure* hdbspDataBlock; // A pointer to a host data block structure.
	hdbspDataBlock = &(dsspDeviceState->bsBcState.hdbsaDataBlock[swDataBlockId]);
	if (TRUE == hdbspDataBlock->bIsFreeForUse)
	{
		return sitalReturnCode_UNDEFINED_NODE;
	}

	// Verify that no message exists that uses given data block.
	BOOLEAN bIsDeletedObjectStillInUse; // A flag that says whether given deleted object is currently in use by any existing object of relevant type.
	bIsDeletedObjectStillInUse = FALSE;
	for (U16BIT i=0U; ((i<sitalBcCounter_MESSAGES) && (FALSE == bIsDeletedObjectStillInUse)); i++)
	{
		HostMessageStructure* hmspMessage; // A pointer to a host message structure.
		hmspMessage = &(dsspDeviceState->bsBcState.hmsaMessage[i]);
		if	(
				(FALSE == hmspMessage->bIsFreeForUse)
				&&
				(
					(swDataBlockId == hmspMessage->swDataBlockIdForMessage1)
					||
					((sitalBcMessageOption_DUAL_MESSAGE == (sitalBcMessageOption_DUAL_MESSAGE & hmspMessage->dwOptions)) && (swDataBlockId == hmspMessage->swDataBlockIdForMessage2))
				)
			)
		{
			bIsDeletedObjectStillInUse = TRUE;
		}
	}
	if (TRUE == bIsDeletedObjectStillInUse)
	{
		return sitalReturnCode_NOT_SUPPORTED;
	}

	/// Free the device memory that has been allocated for given data block.
	S16BIT swResult; // Result of operation or function call.
	swResult = Device_Memory_TopSection_FreeRegion (&(dsspDeviceState->hdmmsDeviceMemoryMap), hdbspDataBlock->dwAddress, (hdbspDataBlock->dwAddress + hdbspDataBlock->wDeviceMemorySize - 1U));

	/// Delete given data block.
	dsspDeviceState->bsBcState.hdbsaDataBlock[swDataBlockId].bIsFreeForUse = TRUE;

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Write the contents of given buffer in given data block of given BC device at given offset.
/// For this purpose consider the data block as a cyclic buffer, i.e., continue the copy operation from its start if/when reaching its end.
///
/// Note:
/// - With IEEE-1553 a message data block is up to 32 words long, where the actual number of words depends on the definition of the message.
///   Now, since this function knows nothing about the message that uses or will use given data blobk, it lets the caller write up to 32 words into it.
///   Taking this approach, the user is responsible to write only words that will be used by the message that eventually points given data block.
/// - In case of a dual data block and a dual message that's transmitted using a XQF command:
///   - The first data block is used by the first message.
///   - The second data block is used by the second message.
///   After a XQF command is executed with either its first/second message, then if the condition is fulfilled, the device turns to the other message.
///   When the device is about to execute one of such two messages, this function writes to the data block of the other message in prepare for the next
///   turn, and then performs a flip.
/// - With data blocks that are used with mode code messages with data, the single data word is always read from or written into the first data word of the data block.
///
/// Equivalent DDC definition: aceBCDataBlkWrite
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swDataBlockId (in)	A unique ID designating a data block (0-(sitalBcCounter_DATA_BLOCKS-1))
/// @param wapBuffer (in)	A pointer to an array of data words to be copied into the new data block
/// @param wBufferSize (in)	The size (in words) of the data buffer that is pointed by wapBuffer (0-<size-of-given-data-block>)
/// @param wOffset (in)	The offset (in words) from the beginning of the data block in device memory where cyclic copy begins (0-(<size-of-given-data-block>-1))
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_DataBlock_Write (	S16BIT swDevice,
										S16BIT swDataBlockId,
										U16BIT* wapBuffer,
										U16BIT wBufferSize,
										U16BIT wOffset)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
		//printf("error 2");

	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (((S16BIT)0U > swDataBlockId) || ((S16BIT)sitalBcCounter_DATA_BLOCKS <= swDataBlockId))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	HostDataBlockStructure* hdbspDataBlock; // A pointer to a host data block structure.
	hdbspDataBlock = (HostDataBlockStructure*)&(dsspDeviceState->bsBcState.hdbsaDataBlock[swDataBlockId]);
	if (TRUE == hdbspDataBlock->bIsFreeForUse)
	{
		return sitalReturnCode_UNDEFINED_NODE;
	}

	if (((U16BIT*)NULL) == wapBuffer)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if ((0U == wBufferSize) || (hdbspDataBlock->wActualSize < wBufferSize))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if (hdbspDataBlock->wActualSize <= wOffset)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// If given data block is a double data block:
	///		If given data block isn't pointed by a message that's transmitted by a XQF command:
	///			Use given data block's base address as the base address for this copy operation.
	///		Else:
	///			Read the address parameter of the corresponding XQF command.
	///			If it shows that a flip already occurred (i.e., the first message has been successfully transmitted):
	///				Use given data block's base address (i.e., the address of the data block of the first message) as the base address for this copy operation.
	///			Else:
	///				Use given data block's base address (i.e., the address of the data block of the second message) as the base address for this copy operation.
	/// Else:
	///		Use given data block's base address plus the requested offset as the base address for this copy operation.
	// (See the documentation for this function.)
	U32BIT dwCopyAddress; // The address in device memory where to start writing.
	U16BIT wCurrentAddressInTxCommand; // The address stored in device memory for the XQF command of the transmitter message of given data block.
	wCurrentAddressInTxCommand = 0U; // An assignment that prevents a casual compilation warning.
	S16BIT swResult; // Result of operation or function call.
	if (bcMemoryObjectSize_DOUBLE_DATA_BLOCK == hdbspDataBlock->wActualSize)
	{
		if (0U == hdbspDataBlock->dwOwnerMessageXqfCommandAddress)
		{
			dwCopyAddress = hdbspDataBlock->dwAddress;
		}
		else
		{
			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, (hdbspDataBlock->dwOwnerMessageXqfCommandAddress + 1U), sitalDeviceMemorySection_Ram, 1U, &wCurrentAddressInTxCommand);
			if (sitalReturnCode_SUCCESS != swResult)
			{
				return swResult;
			}
			if (bcCommandBlock_ExecuteAndFlip_AddressFlipBitMask == (bcCommandBlock_ExecuteAndFlip_AddressFlipBitMask & wCurrentAddressInTxCommand))
			{
				dwCopyAddress = hdbspDataBlock->dwAddress;
			}
			else
			{
				dwCopyAddress = (hdbspDataBlock->dwAddress + bcMemoryObjectSize_NORMAL_DATA_BLOCK);
			}
		}
	}
	else
	{
		dwCopyAddress = (hdbspDataBlock->dwAddress + wOffset);
	}

	/// Limit the number of copied data words.
	wBufferSize = ( (bcMemoryObjectSize_NORMAL_DATA_BLOCK < wBufferSize) ? (U16BIT)bcMemoryObjectSize_NORMAL_DATA_BLOCK : wBufferSize );

	/// Cyclically copy given data words to device memory.
	U16BIT wChunkSize; // The size (in words) of the copied portion of the buffer.
	U16BIT wBlockSizeRequiredForSingleCopy; // The size that our data block should have had in order for the required copy to be performed in one piece.
	wBlockSizeRequiredForSingleCopy = (wOffset + wBufferSize); // The size that our data block should have had in order for the required copy to be performed in one piece.
	if (hdbspDataBlock->wActualSize >= wBlockSizeRequiredForSingleCopy)
	{
		// No cyclic wrap required: Whole given buffer may be copied at once.
		wChunkSize = wBufferSize;
		swResult = sitalDevice_AccessMemory (swDevice, sitalDeviceAccessOperation_Write, dwCopyAddress, sitalDeviceMemorySection_Ram, wChunkSize, wapBuffer);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
	}
	else
	{
		// Cyclic wrap required: Copy given buffer in two chunks.
		// First copy enough to fill the tail of the data block.
		wChunkSize = (hdbspDataBlock->wActualSize - wOffset);
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, dwCopyAddress, sitalDeviceMemorySection_Ram, wChunkSize, wapBuffer);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}

		// Next copy the rest of the data buffer into the beginning of the data block.
		dwCopyAddress = hdbspDataBlock->dwAddress;
		wapBuffer += wChunkSize;
		wChunkSize = (wBufferSize - wChunkSize);
		wBlockSizeRequiredForSingleCopy = wChunkSize;
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, dwCopyAddress, sitalDeviceMemorySection_Ram, wChunkSize, wapBuffer);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
	}

	/// Update the offset of the next accessed data word.
	hdbspDataBlock->dwNextAccessedDataWord = wBlockSizeRequiredForSingleCopy;

	/// If given data block is a double data block and given data block is pointed by a message that's transmitted by a XQF command:
	///		Flip to the other message.
	if ((bcMemoryObjectSize_DOUBLE_DATA_BLOCK == hdbspDataBlock->wActualSize) && (0U != hdbspDataBlock->dwOwnerMessageXqfCommandAddress))
	{
		if (bcCommandBlock_ExecuteAndFlip_AddressFlipBitMask == (bcCommandBlock_ExecuteAndFlip_AddressFlipBitMask & wCurrentAddressInTxCommand))
		{
			wCurrentAddressInTxCommand &= (~bcCommandBlock_ExecuteAndFlip_AddressFlipBitMask);
		}
		else
		{
			wCurrentAddressInTxCommand |= bcCommandBlock_ExecuteAndFlip_AddressFlipBitMask;
		}

		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, (hdbspDataBlock->dwOwnerMessageXqfCommandAddress + 1U), sitalDeviceMemorySection_Ram, 1U, &wCurrentAddressInTxCommand);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Read the contents of given data block of given BC device starting at given offset into given buffer.
/// For this purpose consider the data block as a cyclic buffer, i.e., continue the copy operation from its start if/when reaching its end.
///
/// Note:
/// - With IEEE-1553 a message data block is up to 32 words long, where the actual number of words depends on the definition of the message.
///   Now, since this function knows nothing about the message that uses or will use given data blobk, it lets the caller read up to 32 words from it.
///   Taking this approach, the user is responsible to write only words that will be used by the message that eventually points given data block.
/// - In case of a dual data block and a dual message that's transmitted using a XQF command:
///   - The first data block is used by the first message.
///   - The second data block is used by the second message.
///   After a XQF command is executed with either its first/second message, then if the condition is fulfilled, the device turns to the other message.
///   When the device is about to execute one of such two messages, this function first prevents it from flipping to the other message, then it reads
///   data from the data block of the other message (which is the one previously updated by the device), and then reenables the device to perform flips.
/// - With data blocks that are used with mode code messages with data, the single data word is always read from or written into the first data word of the data block.
///
/// Equivalent DDC definition: aceBCDataBlkRead
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swDataBlockId (in)	A unique ID designating a data block (0-(sitalBcCounter_DATA_BLOCKS-1))
/// @param wapBuffer (in)	A pointer to an array of data words to be copied into the new data block
/// @param wBufferSize (in)	The size (in words) of the data buffer that is pointed by wapBuffer (0-<size-of-given-data-block>)
/// @param wOffset (in)	The offset (in words) from the beginning of the data block in device memory where cyclic copy begins (0-(<size-of-given-data-block>-1))
/// @return Positive integer	The number of words that were read into given buffer
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_DataBlock_Read (	S16BIT swDevice,
										S16BIT swDataBlockId,
										U16BIT* wapBuffer,
										U16BIT wBufferSize,
										U16BIT wOffset)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
		//printf("error 3");

	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (((S16BIT)0U > swDataBlockId) || ((S16BIT)sitalBcCounter_DATA_BLOCKS <= swDataBlockId))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	HostDataBlockStructure* hdbspDataBlock; // A pointer to a host data block structure.
	hdbspDataBlock = (HostDataBlockStructure*)&(dsspDeviceState->bsBcState.hdbsaDataBlock[swDataBlockId]);
	if ((BOOLEAN)TRUE == hdbspDataBlock->bIsFreeForUse)
	{
		return sitalReturnCode_UNDEFINED_NODE;
	}

	if (((U16BIT*)NULL) == wapBuffer)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if ((0U == wBufferSize) || (hdbspDataBlock->wActualSize < wBufferSize))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if (hdbspDataBlock->wActualSize <= wOffset)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}
	/// If given data block is a double data block:
	///		If given data block isn't pointed by a message that's transmitted by a XQF command:
	///			Use given data block's base address as the base address for this copy operation.
	///		Else:
	///			Update the condition of this XQF command to "never".
	///			Read the address parameter of the corresponding XQF command.
	///			If it shows that a flip already occurred (i.e., the first message has been successfully transmitted):
	///				Use given data block's base address (i.e., the address of the data block of the first message) as the base address for this copy operation.
	///			Else:
	///				Use given data block's base address (i.e., the address of the data block of the second message) as the base address for this copy operation.
	/// Else:
	///		Use given data block's base address plus the requested offset as the base address for this copy operation.
	// (See the documentation for this function.)
	U32BIT dwCopyAddress; // The address in device memory where to start reading.
	U16BIT wCurrentAddressInTxCommand; // The address stored in device memory for the XQF command of the transmitter message of given data block.
	S16BIT swResult; // Result of operation or function call.
	if (bcMemoryObjectSize_DOUBLE_DATA_BLOCK == hdbspDataBlock->wActualSize)
	{
		if (0U == hdbspDataBlock->dwOwnerMessageXqfCommandAddress)
		{
			dwCopyAddress = hdbspDataBlock->dwAddress;
		}
		else
		{
			U16BIT wXqfNeverCommand; // A XQF command that's conditioned "never".
			swResult = sitalBc_Command_GetWord (sitalOpcode_EXECUTE_AND_FLIP, sitalOpcodeCondition_NEVER, &wXqfNeverCommand);
			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, hdbspDataBlock->dwOwnerMessageXqfCommandAddress, sitalDeviceMemorySection_Ram, 1U, &wXqfNeverCommand);
			if (sitalReturnCode_SUCCESS != swResult)
			{
				return swResult;
			}

			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, (hdbspDataBlock->dwOwnerMessageXqfCommandAddress + 1U), sitalDeviceMemorySection_Ram, 1U, &wCurrentAddressInTxCommand);
			if (sitalReturnCode_SUCCESS != swResult)
			{
				return swResult;
			}

			if (bcCommandBlock_ExecuteAndFlip_AddressFlipBitMask == (bcCommandBlock_ExecuteAndFlip_AddressFlipBitMask & wCurrentAddressInTxCommand))
			{
				dwCopyAddress = hdbspDataBlock->dwAddress;
			}
			else
			{
				dwCopyAddress = (hdbspDataBlock->dwAddress + bcMemoryObjectSize_NORMAL_DATA_BLOCK);
			}
		}
	}
	else
	{
		dwCopyAddress = (hdbspDataBlock->dwAddress + wOffset);
	}

	/// Limit the number of copied data words.
	wBufferSize = ( (bcMemoryObjectSize_NORMAL_DATA_BLOCK < wBufferSize) ? (U16BIT)bcMemoryObjectSize_NORMAL_DATA_BLOCK : wBufferSize );

	/// Cyclically copy data words from device memory into given data buffer.
	U16BIT wChunkSize; // The size (in words) of the copied portion of the buffer.
	U16BIT wBlockSizeRequiredForSingleCopy = (wOffset + wBufferSize); // The size that our data block should have had in order for the required copy to be performed in one piece.
	if (hdbspDataBlock->wActualSize >= wBlockSizeRequiredForSingleCopy)
	{
		// No cyclic wrap required: Whole given buffer may be filled at once.
		wChunkSize = wBufferSize;
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, dwCopyAddress, sitalDeviceMemorySection_Ram, wChunkSize, wapBuffer);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
	}
	else
	{
		// Cyclic wrap required: Fill given buffer in two chunks.
		// First copy all the tail of the data block.
		wChunkSize = (hdbspDataBlock->wActualSize - wOffset);
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, dwCopyAddress, sitalDeviceMemorySection_Ram, wChunkSize, wapBuffer);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}

		// Next copy from the beginning of the data block into the tail of the data buffer.
		dwCopyAddress = hdbspDataBlock->dwAddress;
		wapBuffer += wChunkSize;
		wChunkSize = (wBufferSize - wChunkSize);
		wBlockSizeRequiredForSingleCopy = wChunkSize;
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, dwCopyAddress, sitalDeviceMemorySection_Ram, wChunkSize, wapBuffer);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
	}

	/// Update the offset of the next accessed data word.
	hdbspDataBlock->dwNextAccessedDataWord = wBlockSizeRequiredForSingleCopy;

	/// If given data block is a double data block and given data block is pointed by a message that's transmitted by a XQF command:
	///		Restore the original condition of this XQF command.
	if ((bcMemoryObjectSize_DOUBLE_DATA_BLOCK == hdbspDataBlock->wActualSize) && (0U != hdbspDataBlock->dwOwnerMessageXqfCommandAddress))
	{
		U16BIT wXqfGoodMessageCommand; // A XQF command that's conditioned "good message".
		swResult = sitalBc_Command_GetWord (sitalOpcode_EXECUTE_AND_FLIP, sitalOpcodeCondition_GOOD_MESSAGE, &wXqfGoodMessageCommand);
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, hdbspDataBlock->dwOwnerMessageXqfCommandAddress, sitalDeviceMemorySection_Ram, 1U, &wXqfGoodMessageCommand);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
	}

	return (S16BIT)wBufferSize;
}


/// <summary>
/// Create for given BC device a new frame and calculate the overall number of included commands.
///
/// Note:
/// - Recursion isn't allowed: A frame may not include a call to a subroutine that execute itself either directly or indirectly (i.e., via other frames);
///   Yet, for the sake of simplicity and in order to let the user application more freedom in its frame creation sequence,
///   this function only rejects direct recursions: indirect recursions are identified and rejected only later on, when the user tries to run a frame.
/// - A frame that its later on explicit (=non-recursive) execution is intended, must be classified as major, not minor.
/// - Given frame time is interpreted as follows:
///   - If zero, it is considered as unspecified.
///   - Otherwise, if that's a:
///     - Major frame: Once this major frame is run, given time will be forced for all nested minor frames.
///     - Minor frame: Once this minor frame is executed from within some major frame, given time will take effect with this minor frame
///       if and only if the containing major frame does not force a frame time of its own.
/// - This function doesn't really allocate device memory for the new frame: That will be done only once the user app requests to run this frame.
///   When a major frame is run using function sitalBc_Start, the major frame is actually built in device memory, together with all its nested minor frames,
///   and for this purpose special framing commands are then added (see full information in the documentation for function sitalBc_Start).
///
/// Equivalent DDC definition: aceBCFrameCreate
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swFrameId (in)	A unique ID designating a frame (0-(sitalBcCounter_FRAMES-1))
/// @param swFrameType (in)	The type of the new frame (sitalBcFrameType_*)
/// @param swapCommandIds (in)	A pointer to an array of opcode IDs that make up the new frame (1-(sitalBcCounter_COMMANDS-<required-number-of-framing-commands>))
/// @param wCommandCount (in)	The number of command IDs recorded in the array that is pointed by swpCommandIds (1-sitalBcCounter_FRAME_COMMANDS)
/// @param wFrameTime (in)	The time (in units of 100 us) that the frame will take to complete
/// @param wFlags (in)	Frame configuration options (sitalBcFrameFlag_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_Frame_Create (	S16BIT swDevice,
									S16BIT swFrameId,
									U16BIT wFrameType,
									S16BIT* swapCommandIds,
									U16BIT wCommandCount,
									U16BIT wFrameTime,
									U16BIT wFlags)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
		//printf("error 4");

	}

	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (((S16BIT)0U > swFrameId) || ((S16BIT)sitalBcCounter_FRAMES <= swFrameId))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if ((0U > wFrameType) || (bcFrameType_BORDER <= wFrameType))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if ((0U >= wCommandCount) || (sitalBcCounter_FRAME_COMMANDS < wCommandCount))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if ((0U > wFlags) || (bcFrameFlag_BORDER <= wFlags))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	HostFrameStructure* hfspFrame; // A pointer to a host frame structure.
	hfspFrame = (HostFrameStructure*)&(dsspDeviceState->bsBcState.hfsaFrame[swFrameId]);
	if (FALSE == hfspFrame->bIsFreeForUse)
	{
		return sitalReturnCode_BC_OBJECT_ALREADY_EXISTS;
	}

	/// Loop over all given frame command IDs:
	///		If current command ID specifies a command that contains a software opcode:
	///			Deduce the hardware commands that are required to actually implement it.
	///		With each hardware command (either explicit or one that's implicitly deduced from a software command):
	///			Copy it into the newly created frame.
	///			If that's a message Tx command and high priority asynchronous messages are supported:
	///				Count it together with a following call to the high priority asynchronous messages Tx subroutine.
	///			Else:
	///				Count it as a single command.
	U16BIT wOverallHardwareCommandCount; // The overall number of hardware commands that compose given frame (see an explanation in the documentation for function sitalBc_Start).
	wOverallHardwareCommandCount = 0U;
	S16BIT* swpInputCommandId; // A pointer to the next analyzed input command ID.
	swpInputCommandId = swapCommandIds;
	S16BIT* swpSetCommandId; // A pointer to the next command ID to set.
	swpSetCommandId = hfspFrame->swaCommandId;
	for (S32BIT iCommandIndex=0; iCommandIndex<(S32BIT)wCommandCount; iCommandIndex++, swpInputCommandId++, swpSetCommandId++)
	{
		if (((S16BIT)0U > (*swpInputCommandId)) || ((S16BIT)sitalBcCounter_COMMANDS <= (*swpInputCommandId)))
		{
			return sitalReturnCode_UNDEFINED_COMMAND;
		}

		HostCommandStructure* hcspCommand; // A pointer to a host command structure.
		hcspCommand = (HostCommandStructure*)&(dsspDeviceState->bsBcState.hcsaCommand[*swpInputCommandId]);
		if (TRUE == hcspCommand->bIsFreeForUse)
		{
			return sitalReturnCode_UNDEFINED_COMMAND;
		}

		if ((sitalOpcode_CALL_SUBROUTINE == hcspCommand->wOpcode) && ((U32BIT)swFrameId == hcspCommand->dwParameter1))
		{
			return sitalReturnCode_NOT_SUPPORTED;
		}

		// Copy the command IDs to the new frame.
		(*swpSetCommandId) = (*swpInputCommandId);

		// Count the actually required commands.
		if (sitalOpcode_TIME_CONDITIONED_MESSAGE_TX == hcspCommand->wOpcode)
		{
			wOverallHardwareCommandCount += parsedOpcodeCount_TIME_CONDITIONED_MESSAGE_TX;
		}
		else
		{
			wOverallHardwareCommandCount++;
		}

		// Count the commands added to support high priority asynchronous messages, if required.
		if	(
				(sitalBcSetupOption_ASYNCHRONOUS_HIGH_PRIORITY_MODE == (sitalBcSetupOption_ASYNCHRONOUS_HIGH_PRIORITY_MODE & dsspDeviceState->bsBcState.dwOptions))
				&&
				(
					(sitalOpcode_TIME_CONDITIONED_MESSAGE_TX == hcspCommand->wOpcode)
					||
					(sitalOpcode_EXECUTE_MESSAGE == hcspCommand->wOpcode)
					||
					(sitalOpcode_EXECUTE_AND_FLIP == hcspCommand->wOpcode)
				)
			)
		{
			wOverallHardwareCommandCount += asynchronousMessaging_HIGH_PRIORITY_MESSAGE_TX_CALL_COMMAND_COUNT;
		}
	}

	/// Count the relevant framing commands based on given frame type.
	// (See full information in the documentation for function sitalBc_Start.)
	wOverallHardwareCommandCount += ( (sitalBcFrameType_MAJOR == wFrameType) ? addedFramingCommandsCount_MajorFrame_MAXIMUM_TOTAL : addedFramingCommandsCount_MinorFrame_MAXIMUM_TOTAL );

	/// Initialize a corresponding host structure for the new frame.
	// Device memory is actually allocated for a frame, and the frame is physically written into device memory only once the user requests to run this frame (or a frame within which this frame is nested).
	// The frame whose ID is i:
	// - Has a corresponding structure at host memory, i.e., the entry whose index is i within his device's frame array.
	// Note that the command IDs have been copied already to the new frame.
	hfspFrame->bIsFreeForUse = (BOOLEAN)FALSE;
	hfspFrame->wId = (U16BIT)swFrameId;
	hfspFrame->wDeviceMemorySize = (wOverallHardwareCommandCount * bcMemoryObjectSize_COMMAND);
	hfspFrame->wActualSize = 0U;
	hfspFrame->wCommandCount = wCommandCount;
	hfspFrame->wFrameType = wFrameType;
	hfspFrame->wFrameTime = wFrameTime;
	hfspFrame->wFlags = wFlags;

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Delete given frame which has been previously created for given BC device.
///
/// Note:
/// - A frame may not be deleted along frame run, though as such an operation won't for itself directly influence the ongoing frame run,
///   as this function only deletes the host memory representation of given frame, and device memory/operation isn't affected at all by it;
///   The reason for this restriction is that if the user is allowed to delete frames along frame run, he/she may delete the commands that
///   where included in the deleted frames, and in turn delete messages transmitted by these commands, and data blocks used by these messages,
///   what may disrupt the execution of the currently running frame.
/// - A frame may not be deleted if it is used by any existing frame.
///
/// Equivalent DDC definition: aceBCFrameDelete
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swFrameId (in)	A unique ID designating a frame (0-(sitalBcCounter_FRAMES-1))
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_Frame_Delete (S16BIT swDevice, S16BIT swFrameId)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
		//printf("error 5");

	}

	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (((S16BIT)0U > swFrameId) || ((S16BIT)sitalBcCounter_FRAMES <= swFrameId))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	HostFrameStructure* hfspFrame; // A pointer to a host frame structure.
	hfspFrame = &(dsspDeviceState->bsBcState.hfsaFrame[swFrameId]);
	if (TRUE == hfspFrame->bIsFreeForUse)
	{
		return sitalReturnCode_UNDEFINED_NODE;
	}

	// Verify that no frame exists that includes given frame (i.e., calls a subroutine that executes given frame).
	BOOLEAN bIsDeletedObjectStillInUse; // A flag that says whether given deleted object is currently in use by any existing object of relevant type.
	bIsDeletedObjectStillInUse = FALSE;
	for (U16BIT i=0U; ((i<sitalBcCounter_FRAMES) && (FALSE == bIsDeletedObjectStillInUse)); i++)
	{
		HostFrameStructure* hfspCurrentFrame; // A pointer to the currently dealt with frame.
		hfspCurrentFrame = &(dsspDeviceState->bsBcState.hfsaFrame[i]);
		if (FALSE == hfspCurrentFrame->bIsFreeForUse)
		{
			S16BIT* swpCurrentCommandId; // A pointer to the currently dealt with command ID.
			swpCurrentCommandId = hfspCurrentFrame->swaCommandId;
			for (U16BIT j=0U; ((j<hfspCurrentFrame->wCommandCount) && (FALSE == bIsDeletedObjectStillInUse)); j++, swpCurrentCommandId++)
			{
				HostCommandStructure* hcspCurrentCommand; // A pointer to the currently dealt with command.
				hcspCurrentCommand = &(dsspDeviceState->bsBcState.hcsaCommand[*swpCurrentCommandId]);
				if ((sitalOpcode_CALL_SUBROUTINE == hcspCurrentCommand->wOpcode) && ((U32BIT)swFrameId == hcspCurrentCommand->dwParameter1))
				{
					bIsDeletedObjectStillInUse = TRUE;
				}
			}
		}
	}
	if (TRUE == bIsDeletedObjectStillInUse)
	{
		return sitalReturnCode_NOT_SUPPORTED;
	}

	/// Delete given frame.
	dsspDeviceState->bsBcState.hfsaFrame[swFrameId].bIsFreeForUse = TRUE;

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Configure function sitalBc_Command_GetWord of the stld1553 library to insert from now on given distort to its generated commands.
///
/// Note:
/// - This function is only supplied for test purposes, and isn't intended for regular use!
///   Once called, it may cause the creation of faulty frames.
/// - Given distortion settings will affect any BC device initialized by the calling app.
///
/// @param wHardwareOpcode (in)	An hardware opcode whose commands should be distorted from now on (sitalOpcode_*)
/// @param wDistortionManner (in)	A requested manner of command distortion (sitalOpcodeDistortion_*)
/// @param wDistortionParameter (in)	An optionally required parameter as specified in the definition of given distortion manner
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_Command_DistortWord (U16BIT wHardwareOpcode, U16BIT wDistortionManner, U16BIT wDistortionParameter)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if ((0U > wHardwareOpcode) || (opcode_HARDWARE_BORDER <= wHardwareOpcode))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if ((0U > wDistortionManner) || (commandDistortion_BORDER <= wDistortionManner))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if ((sitalOpcodeDistortion_FlipBit == wDistortionManner) && ((0U > wDistortionParameter) || (15U < wDistortionParameter)))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Store requested command distortion configuration.
	s_wDistortedHardwareOpcode = ( (sitalOpcodeDistortion_None == wDistortionManner) ? (U16BIT)opcode_HARDWARE_BORDER : wHardwareOpcode );
	s_wDistortionManner = wDistortionManner;
	s_wDistortionParameter = wDistortionParameter;

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Generate a command word using given opcode and condition code.
/// Odd parity is used for the generation of the parity bit (MSb) of the command opcode word.
///
/// Note:
/// - Given hardware opcode may be either a regular opcode or one of Sital's unique hardware opcodes.
///   The latter ones are numbered by this library with unique artificial numbers, but must be converted to their true values when recorded in device memory.
///   As result, there are some opcode numbers that represent a pair of opcodes, that is both a regular and a Sital unique opcode.
///   The way for the device to know whether an opcode is a regular or a Sital unique one is to examine the mandatory bits.
///
/// @param wHardwareOpcode (in)	An hardware opcode (sitalOpcode_*)
/// @param wCondition (in)	A condition code (sitalOpcodeCondition_*)
/// @param wpCommandOpcode (out)	A pointer to a variable within which the generated command opcode is returned
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_Command_GetWord (U16BIT wHardwareOpcode, U16BIT wCondition, U16BIT* wpCommandOpcode)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if ((0U > wCondition) || (opcodeCondition_BORDER <= wCondition))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if ((0U > wHardwareOpcode) || (opcode_HARDWARE_BORDER <= wHardwareOpcode))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if (((U16BIT*)NULL) == wpCommandOpcode)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// If given hardware opcode is a regular opcode:
	///		Use the regular mandatory bit mask when constructing the command word.
	/// Else (it's one of Sital's unique hardware opcodes):
	///     If a only specific condition is permitted with given opcode:
	///         Force the requested condition.
	///		Convert given hardware opcode to its real value.
	///		Use Sital's unique mandatory bit mask when constructing the command word.
	U16BIT wMandatoryBitMask; // The mandatory bit mask that suits given hardware opcode.
	if (opcode_SITAL_HARDWARE_BASE > wHardwareOpcode)
	{
		wMandatoryBitMask = commandOpcode_MANDATORY_BITS;
	}
	else
	{
		if (sitalOpcode_FOCUS_ON_VARIABLE == wHardwareOpcode)
		{
			wCondition = sitalOpcodeCondition_ALWAYS;
		}
		else
			if (sitalOpcode_PUSH_VARIABLE == wHardwareOpcode)
			{
				wCondition = sitalOpcodeCondition_NEVER;
				wHardwareOpcode = sitalOpcode_FOCUS_ON_VARIABLE;
			}
			wHardwareOpcode -= opcode_SITAL_HARDWARE_BASE;
			wMandatoryBitMask = commandOpcode_SITAL_UNIQUE_MANDATORY_BITS;
	}

	/// Calculate the parameter-dependent parts of the command opcode.
	(*wpCommandOpcode) = ( (wHardwareOpcode << commandOpcode_OFFSET_OF_OPCODE_MASK) | (wCondition << commandOpcode_OFFSET_OF_CONDITION_MASK) );

	/// Calculate the mandatory portion of the command opcode.
	(*wpCommandOpcode) = ( ((~(U16BIT)commandOpcode_MANDATORY_BITS_MASK) & (*wpCommandOpcode)) | wMandatoryBitMask );

	/// Count the bits of the calculated command opcode that are raised.
	U16BIT wOnBitCount; // Counter of raised bits.
	wOnBitCount = 0U;
	U16BIT wHelper; // A helper variable.
	wHelper = (*wpCommandOpcode);
	while (0U != wHelper)
	{
		if (0x0001U == (0x0001U & wHelper))
		{
			wOnBitCount++;
		}
		wHelper = (wHelper >> 1U);
	}

	/// Properly set the odd parity MS bit.
	if (0U == (wOnBitCount % 2U))
	{
		(*wpCommandOpcode) |= commandOpcode_ODD_PARITY_MASK;
	}

	/// If commands of given hardware opcode should be distorted in any way:
	///		Distort created command according to the configured command distortion.
	if (s_wDistortedHardwareOpcode == wHardwareOpcode)
	{
		switch (s_wDistortionManner)
		{
		case sitalOpcodeDistortion_None:
			break;
		case sitalOpcodeDistortion_FlipBit:
			U16BIT wFlippedBitMask; // A mask where a single bit, the flipped bit, is raised.
			wFlippedBitMask = ((U16BIT)1U << s_wDistortionParameter);
			(*wpCommandOpcode) = (((~wFlippedBitMask) & (*wpCommandOpcode)) | ((~(wFlippedBitMask & (*wpCommandOpcode))) & wFlippedBitMask)); // Flips the desired bit in the resulting command word.
			break;
		case sitalOpcodeDistortion_SetCommand:
			(*wpCommandOpcode) = s_wDistortionParameter;
			break;
		default:
			return sitalReturnCode_INVALID_PARAMETER;
		}
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Create for given BC device a new command using given command descriptors.
/// The new command will be actually allocated device memory space and written in it only at the right moments along the course of the life of its frame.
///
/// Note:
/// - Given opcode may be either:
///   - Hardware (=regular/standard) opcodes.
///   - Software (=special/non-standard) opcodes: Opcodes that designate [frequently used] series of hardware opcodes.
///     Here's the list of the currently defined software opcodes and their translation into hardware opcodes:
///     - sitalOpcode_TIME_CONDITIONED_MESSAGE_TX (condition, parameter):
///       00: ... (The preceding part of the frame)
///       01: JMP if the given condition is not fulfilled to address 07
///       02: CFT with watchdog time plus message time
///       03: JMP if greater than to address 07
///       04: XEQ given message
///       05: FLG to clear the relevant GPF, so that given condition won't fulfill anymore (if depends on some GPF)
///       06: CAL the high priority asynchronous messages Tx subroutine (only if high priority asynchronous messages are supported)
///       07: ... (The rest of the frame)
/// - Here are parameter and other important specifications for opcodes for which any parameters are defined:
///   - Message-transmitter commands (execute message, execute-and-flip, and time conditioned message Tx):
///     - Parameter #1: The ID of the normal (i.e., not asynchronous) message to transmit.
///   - Jump:
///     - Parameter #1: The backward/forward offset (in commands) to jump in two's-complement representation (e.g., 0xFFFFU means jump one command backward).
///   - Call subroutine:
///     - Parameter #1: The ID of the minor (i.e., not major) frame to execute at this point.
///   - Return from subroutine:
///     - WARNING: This command should not be used within a major frame!
///   - Interrupt request:
///     - Parameter #1: Its 4 LSbits contain the index of the IRQ to issue (e.g., a binary 0100, or 0x4, means IRQ #2).
///   - Delay:
///     - Parameter #1: Time (in us) to delay.
///   - Compare to frame timer:
///     - Parameter #1: Time stamp (in 100us).
///   - Compare to message timer:
///     - Parameter #1: Time stamp (in us).
///   - Update GPF:
///     - Parameter #1:
///       - If bit #i of the 8 LSbits and none of the 8 MSbits is on, set GPF #i.
///       - If bit #i of the 8 MSbits and none of the 8 LSbits is on, clear GPF #i.
///       - If bit #i of both the 8 LSbits and of the 8 MSbits is on, toggle GPF #i.
///   - Load time tag counter:
///     - Parameter #1: Value to load (the resolution is determined by configuration register #2).
///   - Load frame time:
///     - Parameter #1: Time stamp (in 100us).
///   - Push value to the GPQ:
///     - WARNING:
///       This library reports frame run events by pushing pairs of suitable word values into the GPQ, as follows:
///       - Header word: A special values that designates that exact reported event (sitalGeneralPurposeQueueFlag_*).
///       - Data word: Some relevant data that further describes that reported event.
///       The library later reads these GPQ entries in order to see what happened.
///       Therefore, in order not to disturn this apparatus, the user must:
//        - Push word values into the GPQ in pairs, that is, using a pair of PUSH commands each time, and never a single PUSH command.
///       - In each such pair, tha first PUSH must write into the GPQ a value that differs from those above specified GPQ headers that are used by this library.
///     - Parameter #1: A value to push.
///   - Indirect push of value to the GPQ:
///     - Parameter #1: A device memory address to take the value to push from.
///   - Focus on variable:
///     - Parameter #1: The 4 LSbits contain the number of the variable to focus on.
///     - WARNING: Variables #8 and #9 are used by this library, and therefore should not be used!
///   - Push variable value to the GPQ:
///     - Parameter #1: The 4 LSbits contain the number of the desired variable.
///   - Add to the now focused variable:
///     - Parameter #1: A signed value to add, either negative or positive, in two's-complement representation.
///   - Load the now focused variable:
///     - Parameter #1: A value to load.
///   - Compare the now focused variable:
///     - Parameter #1: A value to compare.
///   - Wait for trigger WTG:
///     - Parameter #1: Wait for a rising edge in the external trigger (HW).
///		- For External Hardare usage note, please visit the 'Application notes' folder.
/// - In cases where this function does not reject commands with illegal parameter values, they'll be eventually rejected when their container frame
///   comes to execution.
///
/// Equivalent DDC definition: aceBCOpCodeCreate
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swCommandId (in)	A unique ID designating a command (0-(sitalBcCounter_COMMANDS-1))
/// @param wOpcode (in)	The opcode operated by the new command (sitalOpcode_*)
/// @param wCondition (in)	The condition that must be fulfilled in order for the command to be executed (sitalOpcodeCondition_*)
/// @param dwParameter1 (in)	A parameter that's possibly required by some opcodes (See the opcodes description table under 'Instructions' in the eBC's user manual)
/// @param dwParameter2 (in)	Another parameter that's possibly required by some opcodes (See the opcodes description table under 'Instructions' in the eBC's user manual)
/// @param dwReserved (in)	Reserved for future use
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_Command_Create (	S16BIT swDevice,
										S16BIT swCommandId,
										U16BIT wOpcode,
										U16BIT wCondition,
										U32BIT dwParameter1,
										U32BIT dwParameter2,
										U32BIT dwReserved)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (((S16BIT)0U > swCommandId) || ((S16BIT)sitalBcCounter_COMMANDS <= swCommandId))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if ((0U > wCondition) || (opcodeCondition_BORDER <= wCondition))
	{

		return sitalReturnCode_INVALID_PARAMETER;
	}

	HostCommandStructure* hcspCommand; // A pointer to a host command structure.
	hcspCommand = (HostCommandStructure*)&(dsspDeviceState->bsBcState.hcsaCommand[swCommandId]);
	if (FALSE == hcspCommand->bIsFreeForUse)
	{
		return sitalReturnCode_BC_OBJECT_ALREADY_EXISTS;
	}

	if (opcode_SOFTWARE_FLAG == (opcode_SOFTWARE_FLAG & hcspCommand->wOpcode))
	{
		if (sitalOpcode_TIME_CONDITIONED_MESSAGE_TX == wOpcode)
		{
			if (opcodeCondition_GPF_NUMBER_BORDER <= (opcodeCondition_GPF_NUMBER & wCondition))
			{

				return sitalReturnCode_INVALID_PARAMETER;
			}

			dwParameter2 = 0U;
		}
		else
		{
			return sitalReturnCode_INVALID_PARAMETER;
		}
	}
	else
	if ((0U > wOpcode) || (opcode_HARDWARE_BORDER <= wOpcode))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if ((sitalOpcode_TIME_CONDITIONED_MESSAGE_TX == wOpcode) || (sitalOpcode_EXECUTE_MESSAGE == wOpcode) || (sitalOpcode_EXECUTE_AND_FLIP == wOpcode))
	{
		if ((0U > dwParameter1) || (sitalBcCounter_MESSAGES <= dwParameter1))
		{
			return sitalReturnCode_INVALID_PARAMETER;
		}

		HostMessageStructure* hmspMessage; // A pointer to the host message structure of the message transmitted by given message-transmitter command.
		hmspMessage = (HostMessageStructure*)&(dsspDeviceState->bsBcState.hmsaMessage[dwParameter1]);
		if (TRUE == hmspMessage->bIsFreeForUse)
		{
			return sitalReturnCode_INVALID_PARAMETER;
		}

		if (TRUE == hmspMessage->bIsAsynchronousMessage)
		{
			return sitalReturnCode_ASYNCHRONOUS_MESSAGE_ERROR;
		}
	}
	else
	if (sitalOpcode_CALL_SUBROUTINE == wOpcode)
	{
		if ((0U > dwParameter1) || (sitalBcCounter_FRAMES <= dwParameter1))
		{
			return sitalReturnCode_INVALID_PARAMETER;
		}
	}

	/// Allocate and initialize a corresponding host structure for the new command.
	// Device memory is actually allocated for a command, and the command is physically written into device memory only once the user requests to run a frame within which it is included.
	// The command whose ID is i:
	// - Has a corresponding structure at host memory, i.e., the entry whose index is i within his device's data block array.
	hcspCommand->bIsFreeForUse = FALSE;
	hcspCommand->wId = (U16BIT)swCommandId;
	hcspCommand->wDeviceMemorySize = bcMemoryObjectSize_COMMAND;
	hcspCommand->wActualSize = bcMemoryObjectSize_COMMAND;
	hcspCommand->wOpcode = wOpcode;
	hcspCommand->wCondition = wCondition;
	hcspCommand->dwParameter1 = dwParameter1;
	hcspCommand->dwParameter2 = dwParameter2;

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Delete given command which has been previously created for given BC device
///
/// Note:
/// - A command may be principally deleted along frame run in order to be compatible with DDC's library;
///   Yet, delete isn't supported if this command is used by any existing frame, even though as such an operation won't for itself directly
///   influence the ongoing frame run, as this function only deletes the host memory representation of given command, and device memory/operation
///   isn't affected at all by it; Read about the reason for this in the documentation for function sitalBc_Frame_Delete.
///
/// Equivalent DDC definition: aceBCOpCodeDelete
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swCommandId (in)	A unique ID designating a command (0-(sitalBcCounter_COMMANDS-1))
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_Command_Delete (S16BIT swDevice, S16BIT swCommandId)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (((S16BIT)0U > swCommandId) || ((S16BIT)sitalBcCounter_COMMANDS <= swCommandId))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	HostCommandStructure* hcspCommand; // A pointer to a host command structure.
	hcspCommand = (HostCommandStructure*)&(dsspDeviceState->bsBcState.hcsaCommand[swCommandId]);
	if (TRUE == hcspCommand->bIsFreeForUse)
	{
		return sitalReturnCode_UNDEFINED_NODE;
	}

	// Verify that no frame exists that includes given command.
	BOOLEAN bIsDeletedObjectStillInUse; // A flag that says whether given deleted object is currently in use by any existing object of relevant type.
	bIsDeletedObjectStillInUse = FALSE;
	for (U16BIT i=0U; ((i<sitalBcCounter_FRAMES) && (FALSE == bIsDeletedObjectStillInUse)); i++)
	{
		HostFrameStructure* hfspCurrentFrame; // A pointer to the currently dealt with frame.
		hfspCurrentFrame = (HostFrameStructure*)&(dsspDeviceState->bsBcState.hfsaFrame[i]);
		if (FALSE == hfspCurrentFrame->bIsFreeForUse)
		{
			S16BIT* swpCurrentCommandId; // A pointer to the currently dealt with command ID.
			swpCurrentCommandId = hfspCurrentFrame->swaCommandId;
			for (U16BIT j=0U; ((j<hfspCurrentFrame->wCommandCount) && (FALSE == bIsDeletedObjectStillInUse)); j++, swpCurrentCommandId++)
			{
				if (swCommandId == (*swpCurrentCommandId))
				{
					bIsDeletedObjectStillInUse = TRUE;
				}
			}
		}
	}
	if (TRUE == bIsDeletedObjectStillInUse)
	{
		return sitalReturnCode_NOT_SUPPORTED;
	}

	/// Cancel given command.
	hcspCommand->bIsFreeForUse = TRUE;

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Create for given BC device a BC-to-RT message.
///
/// Note:
/// - See further information in the documentation for function sitalBc_Message_Create.
///
/// Equivalent DDC definition: aceBCMsgCreateBCtoRT
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swMessageId (in)	A unique ID designating a message (0-(sitalBcCounter_MESSAGES-1))
/// @param swDataBlockId (in)	A unique ID designating a data block (0-(sitalBcCounter_DATA_BLOCKS-1))
/// @param wReceiverRt (in)	Receiver RT (sitalRtAddress_0-sitalRtAddress_31)
/// @param wReceiverRtSubaddress (in)	Receiver RT's subaddress (sitalRtSubaddress_1-sitalRtSubaddress_30)
/// @param wWordCount (in)	Word count (1-32)
/// @param wGapTime (in)	Gap time (in units of 1us) between the beginning of the message to the beginning of the following message (>=0)
/// @param dwOptions (in)	Message options (An or-ed combination of sitalBcControlWord_* and sitalBcMessageOption_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_Message_CreateBcToRt (	S16BIT swDevice,
											S16BIT swMessageId,
											S16BIT swDataBlockId,
											U16BIT wReceiverRt,
											U16BIT wReceiverRtSubaddress,
											U16BIT wWordCount,
											U16BIT wGapTime,
											U32BIT dwOptions)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (dwOptions != (bcControlWord_ACTUAL_OPTIONS & dwOptions))
	{
		return sitalReturnCode_INVALID_MESSAGE_OPTIONS;
	}

	/// Use given message descriptors to code a suitable command word.
	U16BIT wCommandWord; // Command word.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalBcStld1553_Command_GetCode (&wCommandWord, wReceiverRt, sitalCommand_RX, wReceiverRtSubaddress, wWordCount);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Set the BC control word for message 1 (ignore special options which aren't part of the BC control word).
	U16BIT wBcControlWordForMessage1; // BC control word for message 1.
	wBcControlWordForMessage1 = (U16BIT)(bcControlWord_NON_SPECIAL_OPTIONS & dwOptions);

	/// Analyze given message options in order to create a proper message.
	if (0U != (sitalBcMessageOption_DUAL_MESSAGE & dwOptions))
	{
		// Dual message requested.
		// As the function prototype does not contain a separate data-block-ID argument for message 2, use the one supplied for both messages (the user will be able to modify this later on).
		return sitalBc_Message_Create (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord, 0U, wGapTime, swDataBlockId, wBcControlWordForMessage1, wCommandWord, 0U, wGapTime, sitalBcMessageOption_DUAL_MESSAGE);
	}
	else
	if (0U != (sitalBcMessageOption_STAY_ON_ALTERNATE_BUS & dwOptions))
	{
		// Message with retries requested: Use a proper dual message to achieve this effect.
		// Set the BC control word of message 2 same as of message 1, just make it use the alternate bus.
		wBcControlWordForMessage1 |= sitalBcControlWord_RETRY_ENABLED;
		U16BIT wBcControlWordForMessage2; // BC control word for message 2.
		wBcControlWordForMessage2 = (U16BIT)(((~bcControlWord_BUS_SELECTOR) & wBcControlWordForMessage1) | (bcControlWord_BUS_SELECTOR & (~(bcControlWord_BUS_SELECTOR & wBcControlWordForMessage1))));

		return sitalBc_Message_Create (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord, 0U, wGapTime, swDataBlockId, wBcControlWordForMessage2, wCommandWord, 0U, wGapTime, sitalBcMessageOption_STAY_ON_ALTERNATE_BUS);
	}
	else
	{
		// Regular message requested.
		return sitalBc_Message_Create (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord, 0U, wGapTime, 0, 0U, 0U, 0U, 0U, 0U);
	}
}


/// <summary>
/// Create for given BC device a RT-to-BC message.
///
/// Note:
/// - See further information in the documentation for function sitalBc_Message_Create.
///
/// Equivalent DDC definition: aceBCMsgCreateRTtoBC
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swMessageId (in)	A unique ID designating a message (0-(sitalBcCounter_MESSAGES-1))
/// @param swDataBlockId (in)	A unique ID designating a data block (0-(sitalBcCounter_DATA_BLOCKS-1))
/// @param wTransmitterRt (in)	Transmitter RT (sitalRtAddress_0-sitalRtAddress_31)
/// @param wTransmitterRtSubaddress (in)	Transmitter RT's subaddress (sitalRtSubaddress_1-sitalRtSubaddress_30)
/// @param wWordCount (in)	Word count (1-32)
/// @param wGapTime (in)	Gap time (in units of 1us) between the beginning of the message to the beginning of the following message (>=0)
/// @param dwOptions (in)	Message options (An or-ed combination of sitalBcControlWord_* and sitalBcMessageOption_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_Message_CreateRtToBc (	S16BIT swDevice,
											S16BIT swMessageId,
											S16BIT swDataBlockId,
											U16BIT wTransmitterRt,
											U16BIT wTransmitterRtSubaddress,
											U16BIT wWordCount,
											U16BIT wGapTime,
											U32BIT dwOptions)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (dwOptions != (bcControlWord_ACTUAL_OPTIONS & dwOptions))
	{
		return sitalReturnCode_INVALID_MESSAGE_OPTIONS;
	}

	/// Use given message descriptors to code a suitable command word.
	U16BIT wCommandWord; // Command word.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalBcStld1553_Command_GetCode (&wCommandWord, wTransmitterRt, sitalCommand_TX, wTransmitterRtSubaddress, wWordCount);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Set the BC control word for message 1 (ignore special options which aren't part of the BC control word).
	U16BIT wBcControlWordForMessage1; // BC control word for message 1.
	wBcControlWordForMessage1 = (U16BIT)(bcControlWord_NON_SPECIAL_OPTIONS & dwOptions);

	/// Analyze given message options in order to create a proper message.
	if (0U != (sitalBcMessageOption_DUAL_MESSAGE & dwOptions))
	{
		// Dual message requested.
		// As the function prototype does not contain a separate data-block-ID argument for message 2, use the one supplied for both messages (the user will be able to modify this later on).
		return sitalBc_Message_Create (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord, 0U, wGapTime, swDataBlockId, wBcControlWordForMessage1, wCommandWord, 0U, wGapTime, sitalBcMessageOption_DUAL_MESSAGE);
	}
	else
	if (0U != (sitalBcMessageOption_STAY_ON_ALTERNATE_BUS & dwOptions))
	{
		// Message with retries requested: Use a proper dual message to achieve this effect.
		// Set the BC control word of message 2 same as of message 1, just make it use the alternate bus.
		wBcControlWordForMessage1 |= sitalBcControlWord_RETRY_ENABLED;
		U16BIT wBcControlWordForMessage2; // BC control word for message 2.
		wBcControlWordForMessage2 = (U16BIT)(((~bcControlWord_BUS_SELECTOR) & wBcControlWordForMessage1) | (bcControlWord_BUS_SELECTOR & (~(bcControlWord_BUS_SELECTOR & wBcControlWordForMessage1))));

		return sitalBc_Message_Create (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord, 0U, wGapTime, swDataBlockId, wBcControlWordForMessage2, wCommandWord, 0U, wGapTime, sitalBcMessageOption_STAY_ON_ALTERNATE_BUS);
	}
	else
	{
		// Regular message requested.
		return sitalBc_Message_Create (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord, 0U, wGapTime, 0, 0U, 0U, 0U, 0U, 0U);
	}
}


/// <summary>
/// Create for given BC device a RT-to-RT message.
///
/// Note:
/// - See further information in the documentation for function sitalBc_Message_Create.
/// - A data block ID is required, though the BC does not send or receive data with this kind of message, as the BC still requires a data block to store within the monitored data.
///
/// Equivalent DDC definition: aceBCMsgCreateRTtoRT
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swMessageId (in)	A unique ID designating a message (0-(sitalBcCounter_MESSAGES-1))
/// @param swDataBlockId (in)	A unique ID designating a data block (0-(sitalBcCounter_DATA_BLOCKS-1))
/// @param wReceiverRt (in)	Receiver RT (sitalRtAddress_0-sitalRtAddress_31)
/// @param wReceiverRtSubaddress (in)	Receiver RT's subaddress (sitalRtSubaddress_1-sitalRtSubaddress_30)
/// @param wWordCount (in)	Word count (1-32)
/// @param wTransmitterRt (in)	Transmitter RT (sitalRtAddress_0-sitalRtAddress_31)
/// @param wTransmitterRtSubaddress (in)	Transmitter RT's subaddress (sitalRtSubaddress_1-sitalRtSubaddress_30)
/// @param wGapTime (in)	Gap time (in units of 1us) between the beginning of the message to the beginning of the following message (>=0)
/// @param dwOptions (in)	Message options (An or-ed combination of sitalBcControlWord_* and sitalBcMessageOption_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_Message_CreateRtToRt (	S16BIT swDevice,
											S16BIT swMessageId,
											S16BIT swDataBlockId,
											U16BIT wReceiverRt,
											U16BIT wReceiverRtSubaddress,
											U16BIT wWordCount,
											U16BIT wTransmitterRt,
											U16BIT wTransmitterRtSubaddress,
											U16BIT wGapTime,
											U32BIT dwOptions)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (dwOptions != (bcControlWord_ACTUAL_OPTIONS & dwOptions))
	{
		return sitalReturnCode_INVALID_MESSAGE_OPTIONS;
	}

	/// Use given message descriptors to code a suitable command word.
	S16BIT swResult; // Result of operation or function call.
	U16BIT wCommandWord1; // Command word 1.
	swResult = sitalBcStld1553_Command_GetCode (&wCommandWord1, wReceiverRt, sitalCommand_RX, wReceiverRtSubaddress, wWordCount);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	U16BIT wCommandWord2; // Command word 2.
	swResult = sitalBcStld1553_Command_GetCode (&wCommandWord2, wTransmitterRt, sitalCommand_TX, wTransmitterRtSubaddress, wWordCount);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Set the BC control word for message 1 (ignore special options which aren't part of the BC control word).
	U16BIT wBcControlWordForMessage1; // BC control word for message 1.
	wBcControlWordForMessage1 = (U16BIT)((bcControlWord_NON_SPECIAL_OPTIONS & dwOptions) | sitalBcControlWord_RT_TO_RT);

	/// Analyze given message options in order to create a proper message.
	if (0U != (sitalBcMessageOption_DUAL_MESSAGE & dwOptions))
	{
		// Dual message requested.
		// As the function prototype does not contain a separate data-block-ID argument for message 2, use the one supplied for both messages (the user will be able to modify this later on).
		return sitalBc_Message_Create (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord1, wCommandWord2, wGapTime, swDataBlockId, wBcControlWordForMessage1, wCommandWord1, wCommandWord2, wGapTime, sitalBcMessageOption_DUAL_MESSAGE);
	}
	else
	if (0U != (sitalBcMessageOption_STAY_ON_ALTERNATE_BUS & dwOptions))
	{
		// Message with retries requested: Use a proper dual message to achieve this effect.
		// Set the BC control word of message 2 same as of message 1, just make it use the alternate bus.
		wBcControlWordForMessage1 |= sitalBcControlWord_RETRY_ENABLED;
		U16BIT wBcControlWordForMessage2; // BC control word for message 2.
		wBcControlWordForMessage2 = (U16BIT)(((~bcControlWord_BUS_SELECTOR) & wBcControlWordForMessage1) | (bcControlWord_BUS_SELECTOR & (~(bcControlWord_BUS_SELECTOR & wBcControlWordForMessage1))));

		return sitalBc_Message_Create (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord1, wCommandWord2, wGapTime, swDataBlockId, wBcControlWordForMessage2, wCommandWord1, wCommandWord2, wGapTime, sitalBcMessageOption_STAY_ON_ALTERNATE_BUS);
	}
	else
	{
		// Regular message requested.
		return sitalBc_Message_Create (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord1, wCommandWord2, wGapTime, 0, 0U, 0U, 0U, 0U, 0U);
	}
}


/// <summary>
/// Create for given BC device a BC-to-RT-Mode or a RT-to-BC-Mode message, depending on given RT device-related message direction (sitalMessageDirection_RX or sitalMessageDirection_TX, respectively).
///
/// Note:
/// - See further information in the documentation for function sitalBc_Message_Create.
///
/// Equivalent DDC definition: aceBCMsgCreateMode
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swMessageId (in)	A unique ID designating a message (0-(sitalBcCounter_MESSAGES-1))
/// @param swDataBlockId (in)	A unique ID designating a data block (0-(sitalBcCounter_DATA_BLOCKS-1))
/// @param wRt (in)	Receiver/transmitter RT (sitalRtAddress_0-sitalRtAddress_31)
/// @param wMessageDirection (in)	RT-related message direction (sitalMessageDirection_RX or sitalMessageDirection_TX)
/// @param wModeCommand (in)	Mode command (1-32)
/// @param wGapTime (in)	Gap time (in units of 1us) between the beginning of the message to the beginning of the following message (>=0)
/// @param dwOptions (in)	Message options (An or-ed combination of sitalBcControlWord_* and sitalBcMessageOption_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_Message_CreateBcToOrFromRtMode (	S16BIT swDevice,
														S16BIT swMessageId,
														S16BIT swDataBlockId,
														U16BIT wRt,
														U16BIT wMessageDirection,
														U16BIT wModeCommand,
														U16BIT wGapTime,
														U32BIT dwOptions)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (dwOptions != (bcControlWord_ACTUAL_OPTIONS & dwOptions))
	{
		return sitalReturnCode_INVALID_MESSAGE_OPTIONS;
	}

	/// Use given message descriptors to code a suitable command word.
	U16BIT wCommandWord; // Command word.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalBcStld1553_Command_GetCode (&wCommandWord, wRt, wMessageDirection, sital1553_MODE_CODE1, wModeCommand);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Set the BC control word for message 1 (ignore special options which aren't part of the BC control word).
	U16BIT wBcControlWordForMessage1; // BC control word for message 1.
	wBcControlWordForMessage1 = (U16BIT)(sitalBcControlWord_MODE | (bcControlWord_NON_SPECIAL_OPTIONS & dwOptions));

	/// Analyze given message options in order to create a proper message.
	if (0U != (sitalBcMessageOption_DUAL_MESSAGE & dwOptions))
	{
		// Dual message requested.
		// As the function prototype does not contain a separate data-block-ID argument for message 2, use the one supplied for both messages (the user will be able to modify this later on).
		return sitalBc_Message_Create (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord, 0U, wGapTime, swDataBlockId, wBcControlWordForMessage1, wCommandWord, 0U, wGapTime, sitalBcMessageOption_DUAL_MESSAGE);
	}
	else
	if (0U != (sitalBcMessageOption_STAY_ON_ALTERNATE_BUS & dwOptions))
	{
		// Message with retries requested: Use a proper dual message to achieve this effect.
		// Set the BC control word of message 2 same as of message 1, just make it use the alternate bus.
		wBcControlWordForMessage1 |= sitalBcControlWord_RETRY_ENABLED;
		U16BIT wBcControlWordForMessage2; // BC control word for message 2.
		wBcControlWordForMessage2 = (U16BIT)(((~bcControlWord_BUS_SELECTOR) & wBcControlWordForMessage1) | (bcControlWord_BUS_SELECTOR & (~(bcControlWord_BUS_SELECTOR & wBcControlWordForMessage1))));

		return sitalBc_Message_Create (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord, 0U, wGapTime, swDataBlockId, wBcControlWordForMessage2, wCommandWord, 0U, wGapTime, sitalBcMessageOption_STAY_ON_ALTERNATE_BUS);
	}
	else
	{
		// Regular message requested.
		return sitalBc_Message_Create (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord, 0U, wGapTime, 0, 0U, 0U, 0U, 0U, 0U);
	}
}


/// <summary>
/// Create for given BC device a BC-to-Broadcast message.
///
/// Note:
/// - See further information in the documentation for function sitalBc_Message_Create.
///
/// Equivalent DDC definition: aceBCMsgCreateBcst
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swMessageId (in)	A unique ID designating a message (0-(sitalBcCounter_MESSAGES-1))
/// @param swDataBlockId (in)	A unique ID designating a data block (0-(sitalBcCounter_DATA_BLOCKS-1))
/// @param wReceiverRtSubaddress (in)	Receiver RT's subaddress (sitalRtSubaddress_1-sitalRtSubaddress_30)
/// @param wWordCount (in)	Word count (1-32)
/// @param wGapTime (in)	Gap time (in units of 1us) between the beginning of the message to the beginning of the following message (>=0)
/// @param dwOptions (in)	Message options (An or-ed combination of sitalBcControlWord_* and sitalBcMessageOption_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_Message_CreateBcToBroadcast (	S16BIT swDevice,
													S16BIT swMessageId,
													S16BIT swDataBlockId,
													U16BIT wReceiverRtSubaddress,
													U16BIT wWordCount,
													U16BIT wGapTime,
													U32BIT dwOptions)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (dwOptions != (bcControlWord_ACTUAL_OPTIONS & dwOptions))
	{
		return sitalReturnCode_INVALID_MESSAGE_OPTIONS;
	}

	/// Use given message descriptors to code a suitable command word.
	U16BIT wCommandWord; // Command word.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalBcStld1553_Command_GetCode (&wCommandWord, sital1553_BROADCAST, sitalCommand_RX, wReceiverRtSubaddress, wWordCount);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Set the BC control word for message 1 (ignore special options which aren't part of the BC control word).
	U16BIT wBcControlWordForMessage1; // BC control word for message 1.
	wBcControlWordForMessage1 = (U16BIT)(sitalBcControlWord_BROADCAST | (bcControlWord_NON_SPECIAL_OPTIONS & dwOptions));

	/// Analyze given message options in order to create a proper message.
	if (0U != (sitalBcMessageOption_DUAL_MESSAGE & dwOptions))
	{
		// Dual message requested.
		// As the function prototype does not contain a separate data-block-ID argument for message 2, use the one supplied for both messages (the user will be able to modify this later on).
		return sitalBc_Message_Create (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord, 0U, wGapTime, swDataBlockId, wBcControlWordForMessage1, wCommandWord, 0U, wGapTime, sitalBcMessageOption_DUAL_MESSAGE);
	}
	else
	if (0U != (sitalBcMessageOption_STAY_ON_ALTERNATE_BUS & dwOptions))
	{
		// Message with retries requested: Use a proper dual message to achieve this effect.
		// Set the BC control word of message 2 same as of message 1, just make it use the alternate bus.
		wBcControlWordForMessage1 |= sitalBcControlWord_RETRY_ENABLED;
		U16BIT wBcControlWordForMessage2; // BC control word for message 2.
		wBcControlWordForMessage2 = (U16BIT)(((~bcControlWord_BUS_SELECTOR) & wBcControlWordForMessage1) | (bcControlWord_BUS_SELECTOR & (~(bcControlWord_BUS_SELECTOR & wBcControlWordForMessage1))));

		return sitalBc_Message_Create (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord, 0U, wGapTime, swDataBlockId, wBcControlWordForMessage2, wCommandWord, 0U, wGapTime, sitalBcMessageOption_STAY_ON_ALTERNATE_BUS);
	}
	else
	{
		// Regular message requested.
		return sitalBc_Message_Create (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord, 0U, wGapTime, 0, 0U, 0U, 0U, 0U, 0U);
	}
}


/// <summary>
/// Create for given BC device a RT-to-Broadcast message.
///
/// Note:
/// - See further information in the documentation for function sitalBc_Message_Create.
///
/// Equivalent DDC definition: aceBCMsgCreateBcstRTtoRT
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swMessageId (in)	A unique ID designating a message (0-(sitalBcCounter_MESSAGES-1))
/// @param swDataBlockId (in)	A unique ID designating a data block (0-(sitalBcCounter_DATA_BLOCKS-1))
/// @param wReceiverRtSubaddress (in)	Receiver RT's subaddress (sitalRtSubaddress_1-sitalRtSubaddress_30)
/// @param wWordCount (in)	Word count (1-32)
/// @param wTransmitterRt (in)	Transmitter RT (sitalRtAddress_0-sitalRtAddress_31)
/// @param wTransmitterRtSubaddress (in)	Transmitter RT's subaddress (sitalRtSubaddress_1-sitalRtSubaddress_30)
/// @param wGapTime (in)	Gap time (in units of 1us) between the beginning of the message to the beginning of the following message (>=0)
/// @param dwOptions (in)	Message options (An or-ed combination of sitalBcControlWord_* and sitalBcMessageOption_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_Message_CreateRtToBroadcast (	S16BIT swDevice,
													S16BIT swMessageId,
													S16BIT swDataBlockId,
													U16BIT wReceiverRtSubaddress,
													U16BIT wWordCount,
													U16BIT wTransmitterRt,
													U16BIT wTransmitterRtSubaddress,
													U16BIT wGapTime,
													U32BIT dwOptions)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (dwOptions != (bcControlWord_ACTUAL_OPTIONS & dwOptions))
	{
		return sitalReturnCode_INVALID_MESSAGE_OPTIONS;
	}

	/// Use given message descriptors to code a suitable command word.
	S16BIT swResult; // Result of operation or function call.
	U16BIT wCommandWord1; // Command word 1.
	swResult = sitalBcStld1553_Command_GetCode (&wCommandWord1, sital1553_BROADCAST, sitalCommand_RX, wReceiverRtSubaddress, wWordCount);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	U16BIT wCommandWord2; // Command word 2.
	swResult = sitalBcStld1553_Command_GetCode (&wCommandWord2, wTransmitterRt, sitalCommand_TX, wTransmitterRtSubaddress, wWordCount);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Set the BC control word for message 1 (ignore special options which aren't part of the BC control word).
	U16BIT wBcControlWordForMessage1; // BC control word for message 1.
	wBcControlWordForMessage1 = (U16BIT)((bcControlWord_NON_SPECIAL_OPTIONS & dwOptions) | sitalBcControlWord_BROADCAST | sitalBcControlWord_RT_TO_RT);

	/// Analyze given message options in order to create a proper message.
	if (0U != (sitalBcMessageOption_DUAL_MESSAGE & dwOptions))
	{
		// Dual message requested.
		// As the function prototype does not contain a separate data-block-ID argument for message 2, use the one supplied for both messages (the user will be able to modify this later on).
		return sitalBc_Message_Create (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord1, wCommandWord2, wGapTime, swDataBlockId, wBcControlWordForMessage1, wCommandWord1, wCommandWord2, wGapTime, sitalBcMessageOption_DUAL_MESSAGE);
	}
	else
	if (0U != (sitalBcMessageOption_STAY_ON_ALTERNATE_BUS & dwOptions))
	{
		// Message with retries requested: Use a proper dual message to achieve this effect.
		// Set the BC control word of message 2 same as of message 1, just make it use the alternate bus.
		wBcControlWordForMessage1 |= sitalBcControlWord_RETRY_ENABLED;
		U16BIT wBcControlWordForMessage2; // BC control word for message 2.
		wBcControlWordForMessage2 = (U16BIT)(((~bcControlWord_BUS_SELECTOR) & wBcControlWordForMessage1) | (bcControlWord_BUS_SELECTOR & (~(bcControlWord_BUS_SELECTOR & wBcControlWordForMessage1))));

		return sitalBc_Message_Create (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord1, wCommandWord2, wGapTime, swDataBlockId, wBcControlWordForMessage2, wCommandWord1, wCommandWord2, wGapTime, sitalBcMessageOption_STAY_ON_ALTERNATE_BUS);
	}
	else
	{
		// Regular message requested.
		return sitalBc_Message_Create (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord1, wCommandWord2, wGapTime, 0, 0U, 0U, 0U, 0U, 0U);
	}
}


/// <summary>
/// Create for given BC device a BC-to-Broadcast-Mode or a Broadcast-to-BC-Mode message, depending on given RT device-related message direction (sitalMessageDirection_RX or sitalMessageDirection_TX, respectively).
///
/// Note:
/// - See further information in the documentation for function sitalBc_Message_Create.
///
/// Equivalent DDC definition: aceBCMsgCreateBcstMode
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swMessageId (in)	A unique ID designating a message (0-(sitalBcCounter_MESSAGES-1))
/// @param swDataBlockId (in)	A unique ID designating a data block (0-(sitalBcCounter_DATA_BLOCKS-1))
/// @param wMessageDirection (in)	RT-related message direction (sitalMessageDirection_RX or sitalMessageDirection_TX)
/// @param wModeCommand (in)	Mode command (1-32)
/// @param wGapTime (in)	Gap time (in units of 1us) between the beginning of the message to the beginning of the following message (>=0)
/// @param dwOptions (in)	Message options (An or-ed combination of sitalBcControlWord_* and sitalBcMessageOption_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_Message_CreateBcToOrFromBroadcastMode (	S16BIT swDevice,
																S16BIT swMessageId,
																S16BIT swDataBlockId,
																U16BIT wMessageDirection,
																U16BIT wModeCommand,
																U16BIT wGapTime,
																U32BIT dwOptions)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (dwOptions != (bcControlWord_ACTUAL_OPTIONS & dwOptions))
	{
		return sitalReturnCode_INVALID_MESSAGE_OPTIONS;
	}

	/// Use given message descriptors to code a suitable command word.
	S16BIT swResult; // Result of operation or function call.
	U16BIT wCommandWord1; // Command word 1.
	swResult = sitalBcStld1553_Command_GetCode (&wCommandWord1, sital1553_BROADCAST, wMessageDirection, sital1553_MODE_CODE1, wModeCommand);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Set the BC control word for message 1 (ignore special options which aren't part of the BC control word).
	U16BIT wBcControlWordForMessage1; // BC control word for message 1.
	wBcControlWordForMessage1 = (U16BIT)((bcControlWord_NON_SPECIAL_OPTIONS & dwOptions) | sitalBcControlWord_BROADCAST | sitalBcControlWord_MODE);

	/// Analyze given message options in order to create a proper message.
	if (0U != (sitalBcMessageOption_DUAL_MESSAGE & dwOptions))
	{
		// Dual message requested.
		// As the function prototype does not contain a separate data-block-ID argument for message 2, use the one supplied for both messages (the user will be able to modify this later on).
		return sitalBc_Message_Create (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord1, 0U, wGapTime, swDataBlockId, wBcControlWordForMessage1, wCommandWord1, 0U, wGapTime, sitalBcMessageOption_DUAL_MESSAGE);
	}
	else
	if (0U != (sitalBcMessageOption_STAY_ON_ALTERNATE_BUS & dwOptions))
	{
		// Message with retries requested: Use a proper dual message to achieve this effect.
		// Set the BC control word of message 2 same as of message 1, just make it use the alternate bus.
		wBcControlWordForMessage1 |= sitalBcControlWord_RETRY_ENABLED;
		U16BIT wBcControlWordForMessage2; // BC control word for message 2.
		wBcControlWordForMessage2 = (U16BIT)(((~bcControlWord_BUS_SELECTOR) & wBcControlWordForMessage1) | (bcControlWord_BUS_SELECTOR & (~(bcControlWord_BUS_SELECTOR & wBcControlWordForMessage1))));

		return sitalBc_Message_Create (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord1, 0U, wGapTime, swDataBlockId, wBcControlWordForMessage2, wCommandWord1, 0U, wGapTime, sitalBcMessageOption_STAY_ON_ALTERNATE_BUS);
	}
	else
	{
		// Regular message requested.
		return sitalBc_Message_Create (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord1, 0U, wGapTime, 0, 0U, 0U, 0U, 0U, 0U);
	}
}


/// <summary>
/// Create for given BC device a single/dual message for future use by some command, and write it at a dedicated place in device memory.
///
/// Note:
/// - A single message requires 16 data words of device memory.
/// - Its address/offset (in word) in device memory must be a number whose 5 LSBits are zeros.
/// - A dual message is actually a set of two messages that are alternately used by a XQF opcode.
///   In order to support such a use, their addresses/offsets (in word) in device memory must only differ in bit #4.
///   Therefore:
///   - The first message is located at an address/offset (in word) in device memory whose 5 LSBits are zeros
///   - The second message is located right at the end of the first message.
/// - A dual message is statically allocated for each message, never mind whether a normal, RT-to-RT, or dual message is actually required.
///   Such a message has enough device memory to define a dual RT-to-RT message, which is the longest message possible.
///   Doing so enables the modification of the message using functions sitalBc_Message_Modify* in any desired way, without having to reallocate device memory for it.
/// - A data block shouldn't be used with more than a single message, though this function does not prevent it.
///
/// Equivalent DDC definition: aceBCMsgCreate
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swMessageId (in)	A unique ID designating a message (0-(sitalBcCounter_MESSAGES-1))
/// @param swDataBlockIdForMessage1 (in)	A unique ID designating the data block of message 1 (0-(sitalBcCounter_DATA_BLOCKS-1))
/// @param wBcControlWordForMessage1 (in)	The BC control word of message 1 (An or-ed combination of sitalBcControlWord_*)
/// @param wCommandWord1ForMessage1 (in)	Command word 1 of message 1
/// @param wCommandWord2ForMessage1 (in)	Command word 2 of message 1
/// @param wGapTimeForMessage1 (in)	The gap of message 1 (>=0)
/// @param swDataBlockIdForMessage2 (in)	A unique ID designating the data block of message 2 (0-(sitalBcCounter_DATA_BLOCKS-1))
/// @param wBcControlWordForMessage2 (in)	The BC control word of message 2 (An or-ed combination of sitalBcControlWord_*)
/// @param wCommandWord1ForMessage2 (in)	Command word 1 of message 2
/// @param wCommandWord2ForMessage2 (in)	Command word 2 of message 2
/// @param wGapTimeForMessage2 (in)	The gap of message 2 (>=0)
/// @param dwOptions (in)	Message options (An or-ed combination of sitalBcControlWord_* and sitalBcMessageOption_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_Message_Create (	S16BIT swDevice,
										S16BIT swMessageId,
										S16BIT swDataBlockIdForMessage1,
										U16BIT wBcControlWordForMessage1,
										U16BIT wCommandWord1ForMessage1,
										U16BIT wCommandWord2ForMessage1,
										U16BIT wGapTimeForMessage1,
										S16BIT swDataBlockIdForMessage2,
										U16BIT wBcControlWordForMessage2,
										U16BIT wCommandWord1ForMessage2,
										U16BIT wCommandWord2ForMessage2,
										U16BIT wGapTimeForMessage2,
										U32BIT dwOptions)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (((S16BIT)0U > swMessageId) || ((S16BIT)sitalBcCounter_MESSAGES <= swMessageId))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if (((S16BIT)0U > swDataBlockIdForMessage1) || ((S16BIT)sitalBcCounter_DATA_BLOCKS <= swDataBlockIdForMessage1))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if ((0U != (sitalBcMessageOption_DUAL_MESSAGE & dwOptions)) && (0U != (sitalBcMessageOption_STAY_ON_ALTERNATE_BUS & dwOptions)))
	{
		return sitalReturnCode_INVALID_MESSAGE_OPTIONS;
	}

	HostMessageStructure* hmspMessage; // A pointer to a host message structure.
	hmspMessage = (HostMessageStructure*)&(dsspDeviceState->bsBcState.hmsaMessage[swMessageId]);
	if (FALSE == hmspMessage->bIsFreeForUse)
	{
		return sitalReturnCode_BC_OBJECT_ALREADY_EXISTS;
	}

	HostDataBlockStructure* hdbspDataBlock1; // A pointer to a host data block structure.
	hdbspDataBlock1 = (HostDataBlockStructure*)&(dsspDeviceState->bsBcState.hdbsaDataBlock[swDataBlockIdForMessage1]);
	if (TRUE == hdbspDataBlock1->bIsFreeForUse)
	{
		return sitalReturnCode_UNDEFINED_NODE;
	}

	if ((U16BIT)0U == ((U16BIT)sitalBcControlWord_MODE & wBcControlWordForMessage1))
	{
		// That's a regular message, the size of the data block must suit given command word.
		if (((U32BIT)((commandWord_WORD_COUNT_OR_MODE_CODE & wCommandWord1ForMessage1) >> commandWord_OFFSET_OF_WORD_COUNT_OR_MODE_CODE)) > hdbspDataBlock1->wActualSize)
		{
			return sitalReturnCode_BC_INVALID_DATA_BLOCK_SIZE;
		}
	}
	else
	{
		// That's a mode code message, the data block must contain at least one data word.
		if ((U16BIT)1U > hdbspDataBlock1->wActualSize)
		{
			return sitalReturnCode_BC_INVALID_DATA_BLOCK_SIZE;
		}
	}

	/// Determine the actual size of the new message.
	HostDataBlockStructure* hdbspDataBlock2; // A pointer to a host data block structure.
	hdbspDataBlock2 = ((HostDataBlockStructure*)NULL);
	if (0U != (sitalBcMessageOption_DUAL_MESSAGE & dwOptions))
	{
		// A new dual message is requested, also check the parameters of the second message.
		if (((S16BIT)0U > swDataBlockIdForMessage2) || ((S16BIT)sitalBcCounter_DATA_BLOCKS <= swDataBlockIdForMessage2))
		{
			return sitalReturnCode_INVALID_PARAMETER;
		}

		hdbspDataBlock2 = (HostDataBlockStructure*)&(dsspDeviceState->bsBcState.hdbsaDataBlock[swDataBlockIdForMessage2]);
		if (TRUE == hdbspDataBlock2->bIsFreeForUse)
		{
			return sitalReturnCode_UNDEFINED_NODE;
		}

		if ((U16BIT)0U == ((U16BIT)sitalBcControlWord_MODE & wBcControlWordForMessage2))
		{
			// That's a regular message, the size of the data block must suit given command word.
			if (((U32BIT)((commandWord_WORD_COUNT_OR_MODE_CODE & wCommandWord1ForMessage2) >> commandWord_OFFSET_OF_WORD_COUNT_OR_MODE_CODE)) > hdbspDataBlock2->wActualSize)
			{
				return sitalReturnCode_BC_INVALID_DATA_BLOCK_SIZE;
			}
		}
		else
		{
			// That's a mode code message, the data block must contain at least one data word.
			if (1U > hdbspDataBlock2->wActualSize)
			{
				return sitalReturnCode_BC_INVALID_DATA_BLOCK_SIZE;
			}
		}
	}

	/// Build given message, and determine its current actual size.
	S16BIT swResult; // Result of operation or function call.
	swResult = bc_Message_Write (swDevice, swMessageId, swDataBlockIdForMessage1, wBcControlWordForMessage1, wCommandWord1ForMessage1, wCommandWord2ForMessage1, wGapTimeForMessage1, swDataBlockIdForMessage2, wBcControlWordForMessage2, wCommandWord1ForMessage2, wCommandWord2ForMessage2, wGapTimeForMessage2, dwOptions, hmspMessage, hdbspDataBlock1, hdbspDataBlock2, TRUE);
	return swResult;
}


/// <summary>
/// Modify a BC-to-RT message that has been previously created for given BC device.
///
/// See further information in the documentation for function sitalBc_Message_Modify.
///
/// Equivalent DDC definition: aceBCMsgModifyBCtoRT
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swMessageId (in)	A unique ID designating a message (0-(sitalBcCounter_MESSAGES-1))
/// @param swDataBlockId (in)	A unique ID designating a data block (0-(sitalBcCounter_DATA_BLOCKS-1))
/// @param wReceiverRt (in)	Receiver RT (sitalRtAddress_0-sitalRtAddress_31)
/// @param wReceiverRtSubaddress (in)	Receiver RT's subaddress (sitalRtSubaddress_1-sitalRtSubaddress_30)
/// @param wWordCount (in)	Word count (1-32)
/// @param wGapTime (in)	Gap time (in units of 1us) between the beginning of the message to the beginning of the following message (>=0)
/// @param dwOptions (in)	Message options (An or-ed combination of sitalBcControlWord_* and sitalBcMessageOption_*)
/// @param wModificationFlags (in)	Message modification options (An or-ed combination of sitalBcMessageModifier_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_Message_ModifyBcToRt (	S16BIT swDevice,
											S16BIT swMessageId,
											S16BIT swDataBlockId,
											U16BIT wReceiverRt,
											U16BIT wReceiverRtSubaddress,
											U16BIT wWordCount,
											U16BIT wGapTime,
											U32BIT dwOptions,
											U16BIT wModificationFlags)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	// (Actually, most of the checks will be performed by the below called function sitalBc_Message_Create.)
	if (dwOptions != (bcControlWord_ACTUAL_OPTIONS & dwOptions))
	{
		return sitalReturnCode_INVALID_MESSAGE_OPTIONS;
	}

	/// Use given message descriptors to code a suitable command word.
	U16BIT wCommandWord; // Command word.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalBcStld1553_Command_GetCode (&wCommandWord, wReceiverRt, sitalCommand_RX, wReceiverRtSubaddress, wWordCount);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Set the BC control word for message 1 (ignore special options which aren't part of the BC control word).
	U16BIT wBcControlWordForMessage1; // BC control word for message 1.
	wBcControlWordForMessage1 = (U16BIT)(bcControlWord_NON_SPECIAL_OPTIONS & dwOptions);

	/// Analyze given message options in order to create a proper message.
	if (0U != (sitalBcMessageOption_DUAL_MESSAGE & dwOptions))
	{
		// Dual message requested.
		// As the function prototype does not contain a separate data-block-ID argument for message 2, use the one supplied for both messages (the user will be able to modify this later on).
		swResult = sitalBc_Message_Modify (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord, 0U, wGapTime, swDataBlockId, wBcControlWordForMessage1, wCommandWord, 0U, wGapTime, wModificationFlags);
	}
	else
	if (0U != (sitalBcMessageOption_STAY_ON_ALTERNATE_BUS & dwOptions))
	{
		// Message with retries requested: Use a proper dual message to achieve this effect.
		// Set the BC control word of message 2 same as of message 1, just make it use the alternate bus.
		wBcControlWordForMessage1 |= sitalBcControlWord_RETRY_ENABLED;
		U16BIT wBcControlWordForMessage2; // BC control word for message 2.
		wBcControlWordForMessage2 = (U16BIT)(((~bcControlWord_BUS_SELECTOR) & wBcControlWordForMessage1) | (bcControlWord_BUS_SELECTOR & (~(bcControlWord_BUS_SELECTOR & wBcControlWordForMessage1))));

		swResult = sitalBc_Message_Modify (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord, 0U, wGapTime, swDataBlockId, wBcControlWordForMessage2, wCommandWord, 0U, wGapTime, wModificationFlags);
	}
	else
	{
		// Regular message requested.
		swResult = sitalBc_Message_Modify (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord, 0U, wGapTime, 0, 0U, 0U, 0U, 0U, wModificationFlags);
	}

	return swResult;
}


/// <summary>
/// Modify a RT-to-BC message that has been previously created for given BC device.
///
/// See further information in the documentation for function sitalBc_Message_Modify.
///
/// Equivalent DDC definition: aceBCMsgModifyRTtoBC
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swMessageId (in)	A unique ID designating a message (0-(sitalBcCounter_MESSAGES-1))
/// @param swDataBlockId (in)	A unique ID designating a data block (0-(sitalBcCounter_DATA_BLOCKS-1))
/// @param wTransmitterRt (in)	Transmitter RT (sitalRtAddress_0-sitalRtAddress_31)
/// @param wTransmitterRtSubaddress (in)	Transmitter RT's subaddress (sitalRtSubaddress_1-sitalRtSubaddress_30)
/// @param wWordCount (in)	Word count (1-32)
/// @param wGapTime (in)	Gap time (in units of 1us) between the beginning of the message to the beginning of the following message (>=0)
/// @param dwOptions (in)	Message options (An or-ed combination of sitalBcControlWord_* and sitalBcMessageOption_*)
/// @param wModificationFlags (in)	Message modification options (An or-ed combination of sitalBcMessageModifier_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_Message_ModifyRtToBc (	S16BIT swDevice,
											S16BIT swMessageId,
											S16BIT swDataBlockId,
											U16BIT wTransmitterRt,
											U16BIT wTransmitterRtSubaddress,
											U16BIT wWordCount,
											U16BIT wGapTime,
											U32BIT dwOptions,
											U16BIT wModificationFlags)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (dwOptions != (bcControlWord_ACTUAL_OPTIONS & dwOptions))
	{
		return sitalReturnCode_INVALID_MESSAGE_OPTIONS;
	}

	/// Use given message descriptors to code a suitable command word.
	U16BIT wCommandWord; // Command word.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalBcStld1553_Command_GetCode (&wCommandWord, wTransmitterRt, sitalCommand_TX, wTransmitterRtSubaddress, wWordCount);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Set the BC control word for message 1 (ignore special options which aren't part of the BC control word).
	U16BIT wBcControlWordForMessage1; // BC control word for message 1.
	wBcControlWordForMessage1 = (U16BIT)(bcControlWord_NON_SPECIAL_OPTIONS & dwOptions);

	/// Analyze given message options in order to Modify an already created proper message.
	if (0U != (sitalBcMessageOption_DUAL_MESSAGE & dwOptions))
	{
		// Dual message requested.
		// As the function prototype does not contain a separate data-block-ID argument for message 2, use the one supplied for both messages (the user will be able to modify this later on).
		return sitalBc_Message_Modify (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord, 0U, wGapTime, swDataBlockId, wBcControlWordForMessage1, wCommandWord, 0U, wGapTime, wModificationFlags);
	}
	else
	if (0U != (sitalBcMessageOption_STAY_ON_ALTERNATE_BUS & dwOptions))
	{
		// Message with retries requested: Use a proper dual message to achieve this effect.
		// Set the BC control word of message 2 same as of message 1, just make it use the alternate bus.
		wBcControlWordForMessage1 |= sitalBcControlWord_RETRY_ENABLED;
		U16BIT wBcControlWordForMessage2; // BC control word for message 2.
		wBcControlWordForMessage2 = (U16BIT)(((~bcControlWord_BUS_SELECTOR) & wBcControlWordForMessage1) | (bcControlWord_BUS_SELECTOR & (~(bcControlWord_BUS_SELECTOR & wBcControlWordForMessage1))));

		return sitalBc_Message_Modify (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord, 0U, wGapTime, swDataBlockId, wBcControlWordForMessage2, wCommandWord, 0U, wGapTime, wModificationFlags);
	}
	else
	{
		// Regular message requested.
		return sitalBc_Message_Modify (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord, 0U, wGapTime, 0, 0U, 0U, 0U, 0U, wModificationFlags);
	}
}


/// <summary>
/// Modify a RT-to-RT message that has been previously created for given BC device.
///
/// See further information in the documentation for function sitalBc_Message_Modify.
///
/// Equivalent DDC definition: aceBCMsgModifyRTtoRT
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swMessageId (in)	A unique ID designating a message (0-(sitalBcCounter_MESSAGES-1))
/// @param swDataBlockId (in)	A unique ID designating a data block (0-(sitalBcCounter_DATA_BLOCKS-1))
/// @param wReceiverRt (in)	Receiver RT (sitalRtAddress_0-sitalRtAddress_31)
/// @param wReceiverRtSubaddress (in)	Receiver RT's subaddress (sitalRtSubaddress_1-sitalRtSubaddress_30)
/// @param wWordCount (in)	Word count (1-32)
/// @param wTransmitterRt (in)	Transmitter RT (sitalRtAddress_0-sitalRtAddress_31)
/// @param wTransmitterRtSubaddress (in)	Transmitter RT's subaddress (sitalRtSubaddress_1-sitalRtSubaddress_30)
/// @param wGapTime (in)	Gap time (in units of 1us) between the beginning of the message to the beginning of the following message (>=0)
/// @param dwOptions (in)	Message options (An or-ed combination of sitalBcControlWord_* and sitalBcMessageOption_*)
/// @param wModificationFlags (in)	Message modification options (An or-ed combination of sitalBcMessageModifier_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_Message_ModifyRtToRt (	S16BIT swDevice,
											S16BIT swMessageId,
											S16BIT swDataBlockId,
											U16BIT wReceiverRt,
											U16BIT wReceiverRtSubaddress,
											U16BIT wWordCount,
											U16BIT wTransmitterRt,
											U16BIT wTransmitterRtSubaddress,
											U16BIT wGapTime,
											U32BIT dwOptions,
											U16BIT wModificationFlags)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (dwOptions != (bcControlWord_ACTUAL_OPTIONS & dwOptions))
	{
		return sitalReturnCode_INVALID_MESSAGE_OPTIONS;
	}

	/// Use given message descriptors to code a suitable command word.
	S16BIT swResult; // Result of operation or function call.
	U16BIT wCommandWord1; // Command word 1.
	swResult = sitalBcStld1553_Command_GetCode (&wCommandWord1, wReceiverRt, sitalCommand_RX, wReceiverRtSubaddress, wWordCount);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	U16BIT wCommandWord2; // Command word 2.
	swResult = sitalBcStld1553_Command_GetCode (&wCommandWord2, wTransmitterRt, sitalCommand_TX, wTransmitterRtSubaddress, wWordCount);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Set the BC control word for message 1 (ignore special options which aren't part of the BC control word).
	U16BIT wBcControlWordForMessage1; // BC control word for message 1.
	wBcControlWordForMessage1 = (U16BIT)((bcControlWord_NON_SPECIAL_OPTIONS & dwOptions) | sitalBcControlWord_RT_TO_RT);

	/// Analyze given message options in order to Modify an already created proper message.
	if (0U != (sitalBcMessageOption_DUAL_MESSAGE & dwOptions))
	{
		// Dual message requested.
		// As the function prototype does not contain a separate data-block-ID argument for message 2, use the one supplied for both messages (the user will be able to modify this later on).
		return sitalBc_Message_Modify (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord1, wCommandWord2, wGapTime, swDataBlockId, wBcControlWordForMessage1, wCommandWord1, wCommandWord2, wGapTime, wModificationFlags);
	}
	else
	if (0U != (sitalBcMessageOption_STAY_ON_ALTERNATE_BUS & dwOptions))
	{
		// Message with retries requested: Use a proper dual message to achieve this effect.
		// Set the BC control word of message 2 same as of message 1, just make it use the alternate bus.
		wBcControlWordForMessage1 |= sitalBcControlWord_RETRY_ENABLED;
		U16BIT wBcControlWordForMessage2; // BC control word for message 2.
		wBcControlWordForMessage2 = (U16BIT)(((~bcControlWord_BUS_SELECTOR) & wBcControlWordForMessage1) | (bcControlWord_BUS_SELECTOR & (~(bcControlWord_BUS_SELECTOR & wBcControlWordForMessage1))));

		return sitalBc_Message_Modify (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord1, wCommandWord2, wGapTime, swDataBlockId, wBcControlWordForMessage2, wCommandWord1, wCommandWord2, wGapTime, wModificationFlags);
	}
	else
	{
		// Regular message requested.
		return sitalBc_Message_Modify (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord1, wCommandWord2, wGapTime, 0, 0U, 0U, 0U, 0U, wModificationFlags);
	}
}


/// <summary>
/// Modify a BC-to-RT-Mode or RT-to-BC message that has been previously created for given BC device, depending on given RT device-related message direction (sitalMessageDirection_RX or sitalMessageDirection_TX, respectively).
///
/// Equivalent DDC definition: aceBCMsgModifyMode
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swMessageId (in)	A unique ID designating a message (0-(sitalBcCounter_MESSAGES-1))
/// @param swDataBlockId (in)	A unique ID designating a data block (0-(sitalBcCounter_DATA_BLOCKS-1))
/// @param wRt (in)	Receiver/transmitter RT (sitalRtAddress_0-sitalRtAddress_31)
/// @param wMessageDirection (in)	RT-related message direction (sitalMessageDirection_RX or sitalMessageDirection_TX)
/// @param wModeCommand (in)	Mode command (1-32)
/// @param wGapTime (in)	Gap time (in units of 1us) between the beginning of the message to the beginning of the following message (>=0)
/// @param dwOptions (in)	Message options (An or-ed combination of sitalBcControlWord_* and sitalBcMessageOption_*)
/// @param wModificationFlags (in)	Message modification options (An or-ed combination of sitalBcMessageModifier_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_Message_ModifyBcToOrFromRtMode (	S16BIT swDevice,
														S16BIT swMessageId,
														S16BIT swDataBlockId,
														U16BIT wRt,
														U16BIT wMessageDirection,
														U16BIT wModeCommand,
														U16BIT wGapTime,
														U32BIT dwOptions,
														U16BIT wModificationFlags)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (dwOptions != (bcControlWord_ACTUAL_OPTIONS & dwOptions))
	{
		return sitalReturnCode_INVALID_MESSAGE_OPTIONS;
	}

	/// Use given message descriptors to code a suitable command word.
	U16BIT wCommandWord; // Command word.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalBcStld1553_Command_GetCode (&wCommandWord, wRt, wMessageDirection, sital1553_MODE_CODE1, wModeCommand);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Set the BC control word for message 1 (ignore special options which aren't part of the BC control word).
	U16BIT wBcControlWordForMessage1; // BC control word for message 1.
	wBcControlWordForMessage1 = (U16BIT)(sitalBcControlWord_MODE | (bcControlWord_NON_SPECIAL_OPTIONS & dwOptions));

	/// Analyze given message options in order to Modify an already created proper message.
	if (0U != (sitalBcMessageOption_DUAL_MESSAGE & dwOptions))
	{
		// Dual message requested.
		// As the function prototype does not contain a separate data-block-ID argument for message 2, use the one supplied for both messages (the user will be able to modify this later on).
		return sitalBc_Message_Modify (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord, 0U, wGapTime, swDataBlockId, wBcControlWordForMessage1, wCommandWord, 0U, wGapTime, wModificationFlags);
	}
	else
	if (0U != (sitalBcMessageOption_STAY_ON_ALTERNATE_BUS & dwOptions))
	{
		// Message with retries requested: Use a proper dual message to achieve this effect.
		// Set the BC control word of message 2 same as of message 1, just make it use the alternate bus.
		wBcControlWordForMessage1 |= sitalBcControlWord_RETRY_ENABLED;
		U16BIT wBcControlWordForMessage2; // BC control word for message 2.
		wBcControlWordForMessage2 = (U16BIT)(((~bcControlWord_BUS_SELECTOR) & wBcControlWordForMessage1) | (bcControlWord_BUS_SELECTOR & (~(bcControlWord_BUS_SELECTOR & wBcControlWordForMessage1))));

		return sitalBc_Message_Modify (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord, 0U, wGapTime, swDataBlockId, wBcControlWordForMessage2, wCommandWord, 0U, wGapTime, wModificationFlags);
	}
	else
	{
		// Regular message requested.
		return sitalBc_Message_Modify (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord, 0U, wGapTime, 0, 0U, 0U, 0U, 0U, wModificationFlags);
	}
}


/// <summary>
/// Modify a BC-to-Broadcast message that has been previously created for given BC device.
///
/// Equivalent DDC definition: aceBCMsgModifyBcst
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swMessageId (in)	A unique ID designating a message (0-(sitalBcCounter_MESSAGES-1))
/// @param swDataBlockId (in)	A unique ID designating a data block (0-(sitalBcCounter_DATA_BLOCKS-1))
/// @param wReceiverRtSubaddress (in)	Receiver RT's subaddress (sitalRtSubaddress_1-sitalRtSubaddress_30)
/// @param wWordCount (in)	Word count (1-32)
/// @param wGapTime (in)	Gap time (in units of 1us) between the beginning of the message to the beginning of the following message (>=0)
/// @param dwOptions (in)	Message options (An or-ed combination of sitalBcControlWord_* and sitalBcMessageOption_*)
/// @param wModificationFlags (in)	Message modification options (An or-ed combination of sitalBcMessageModifier_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_Message_ModifyBcToBroadcast (	S16BIT swDevice,
												  S16BIT swMessageId,
												  S16BIT swDataBlockId,
												  U16BIT wReceiverRtSubaddress,
												  U16BIT wWordCount,
												  U16BIT wGapTime,
												  U32BIT dwOptions,
												  U16BIT wModificationFlags)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (dwOptions != (bcControlWord_ACTUAL_OPTIONS & dwOptions))
	{
		return sitalReturnCode_INVALID_MESSAGE_OPTIONS;
	}

	/// Use given message descriptors to code a suitable command word.
	U16BIT wCommandWord; // Command word.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalBcStld1553_Command_GetCode (&wCommandWord, sital1553_BROADCAST, sitalCommand_RX, wReceiverRtSubaddress, wWordCount);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Set the BC control word for message 1 (ignore special options which aren't part of the BC control word).
	U16BIT wBcControlWordForMessage1; // BC control word for message 1.
	wBcControlWordForMessage1 = (U16BIT)(sitalBcControlWord_BROADCAST | (bcControlWord_NON_SPECIAL_OPTIONS & dwOptions));

	/// Analyze given message options in order to Modify an already created proper message.
	if (0U != (sitalBcMessageOption_DUAL_MESSAGE & dwOptions))
	{
		// Dual message requested.
		// As the function prototype does not contain a separate data-block-ID argument for message 2, use the one supplied for both messages (the user will be able to modify this later on).
		return sitalBc_Message_Modify (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord, 0U, wGapTime, swDataBlockId, wBcControlWordForMessage1, wCommandWord, 0U, wGapTime, wModificationFlags);
	}
	else
	if (0U != (sitalBcMessageOption_STAY_ON_ALTERNATE_BUS & dwOptions))
	{
		// Message with retries requested: Use a proper dual message to achieve this effect.
		// Set the BC control word of message 2 same as of message 1, just make it use the alternate bus.
		wBcControlWordForMessage1 |= sitalBcControlWord_RETRY_ENABLED;
		U16BIT wBcControlWordForMessage2; // BC control word for message 2.
		wBcControlWordForMessage2 = (U16BIT)(((~bcControlWord_BUS_SELECTOR) & wBcControlWordForMessage1) | (bcControlWord_BUS_SELECTOR & (~(bcControlWord_BUS_SELECTOR & wBcControlWordForMessage1))));

		return sitalBc_Message_Modify (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord, 0U, wGapTime, swDataBlockId, wBcControlWordForMessage2, wCommandWord, 0U, wGapTime, wModificationFlags);
	}
	else
	{
		// Regular message requested.
		return sitalBc_Message_Modify (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord, 0U, wGapTime, 0, 0U, 0U, 0U, 0U, wModificationFlags);
	}
}


/// <summary>
/// Modify a RT-to-Broadcast message that has been previously created for given BC device.
///
/// Equivalent DDC definition: aceBCMsgModifyBcstRTtoRT
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swMessageId (in)	A unique ID designating a message (0-(sitalBcCounter_MESSAGES-1))
/// @param swDataBlockId (in)	A unique ID designating a data block (0-(sitalBcCounter_DATA_BLOCKS-1))
/// @param wReceiverRtSubaddress (in)	Receiver RT's subaddress (sitalRtSubaddress_1-sitalRtSubaddress_30)
/// @param wWordCount (in)	Word count (1-32)
/// @param wTransmitterRt (in)	Transmitter RT (sitalRtAddress_0-sitalRtAddress_31)
/// @param wTransmitterRtSubaddress (in)	Transmitter RT's subaddress (sitalRtSubaddress_1-sitalRtSubaddress_30)
/// @param wGapTime (in)	Gap time (in units of 1us) between the beginning of the message to the beginning of the following message (>=0)
/// @param dwOptions (in)	Message options (An or-ed combination of sitalBcControlWord_* and sitalBcMessageOption_*)
/// @param wModificationFlags (in)	Message modification options (An or-ed combination of sitalBcMessageModifier_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_Message_ModifyRtToBroadcast (	S16BIT swDevice,
												  S16BIT swMessageId,
												  S16BIT swDataBlockId,
												  U16BIT wReceiverRtSubaddress,
												  U16BIT wWordCount,
												  U16BIT wTransmitterRt,
												  U16BIT wTransmitterRtSubaddress,
												  U16BIT wGapTime,
												  U32BIT dwOptions,
												  U16BIT wModificationFlags)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (dwOptions != (bcControlWord_ACTUAL_OPTIONS & dwOptions))
	{
		return sitalReturnCode_INVALID_MESSAGE_OPTIONS;
	}

	/// Use given message descriptors to code a suitable command word.
	S16BIT swResult; // Result of operation or function call.
	U16BIT wCommandWord1; // Command word 1.
	swResult = sitalBcStld1553_Command_GetCode (&wCommandWord1, sital1553_BROADCAST, sitalCommand_RX, wReceiverRtSubaddress, wWordCount);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	U16BIT wCommandWord2; // Command word 2.
	swResult = sitalBcStld1553_Command_GetCode (&wCommandWord2, wTransmitterRt, sitalCommand_TX, wTransmitterRtSubaddress, wWordCount);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Set the BC control word for message 1 (ignore special options which aren't part of the BC control word).
	U16BIT wBcControlWordForMessage1; // BC control word for message 1.
	wBcControlWordForMessage1 = (U16BIT)((bcControlWord_NON_SPECIAL_OPTIONS & dwOptions) | sitalBcControlWord_BROADCAST | sitalBcControlWord_RT_TO_RT);

	/// Analyze given message options in order to Modify an already created proper message.
	if (0U != (sitalBcMessageOption_DUAL_MESSAGE & dwOptions))
	{
		// Dual message requested.
		// As the function prototype does not contain a separate data-block-ID argument for message 2, use the one supplied for both messages (the user will be able to modify this later on).
		return sitalBc_Message_Modify (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord1, wCommandWord2, wGapTime, swDataBlockId, wBcControlWordForMessage1, wCommandWord1, wCommandWord2, wGapTime, wModificationFlags);
	}
	else
	if (0U != (sitalBcMessageOption_STAY_ON_ALTERNATE_BUS & dwOptions))
	{
		// Message with retries requested: Use a proper dual message to achieve this effect.
		// Set the BC control word of message 2 same as of message 1, just make it use the alternate bus.
		wBcControlWordForMessage1 |= sitalBcControlWord_RETRY_ENABLED;
		U16BIT wBcControlWordForMessage2; // BC control word for message 2.
		wBcControlWordForMessage2 = (U16BIT)(((~bcControlWord_BUS_SELECTOR) & wBcControlWordForMessage1) | (bcControlWord_BUS_SELECTOR & (~(bcControlWord_BUS_SELECTOR & wBcControlWordForMessage1))));

		return sitalBc_Message_Modify (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord1, wCommandWord2, wGapTime, swDataBlockId, wBcControlWordForMessage2, wCommandWord1, wCommandWord2, wGapTime, wModificationFlags);
	}
	else
	{
		// Regular message requested.
		return sitalBc_Message_Modify (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord1, wCommandWord2, wGapTime, 0, 0U, 0U, 0U, 0U, wModificationFlags);
	}
}


/// <summary>
/// Modify a BC-to-Broadcast-Mode or Broadcast-to-BC-Mode message that has been previously created for given BC device, depending on given RT device-related message direction (sitalMessageDirection_RX or sitalMessageDirection_TX, respectively).
///
/// Equivalent DDC definition: aceBCMsgModifyBcstMode
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swMessageId (in)	A unique ID designating a message (0-(sitalBcCounter_MESSAGES-1))
/// @param swDataBlockId (in)	A unique ID designating a data block (0-(sitalBcCounter_DATA_BLOCKS-1))
/// @param wMessageDirection (in)	RT-related message direction (sitalMessageDirection_RX or sitalMessageDirection_TX)
/// @param wModeCommand (in)	Mode command (1-32)
/// @param wGapTime (in)	Gap time (in units of 1us) between the beginning of the message to the beginning of the following message (>=0)
/// @param dwOptions (in)	Message options (An or-ed combination of sitalBcControlWord_* and sitalBcMessageOption_*)
/// @param wModificationFlags (in)	Message modification options (An or-ed combination of sitalBcMessageModifier_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_Message_ModifyBcToOrFromBroadcastMode (	S16BIT swDevice,
																S16BIT swMessageId,
																S16BIT swDataBlockId,
																U16BIT wMessageDirection,
																U16BIT wModeCommand,
																U16BIT wGapTime,
																U32BIT dwOptions,
																U16BIT wModificationFlags)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (dwOptions != (bcControlWord_ACTUAL_OPTIONS & dwOptions))
	{
		return sitalReturnCode_INVALID_MESSAGE_OPTIONS;
	}

	/// Use given message descriptors to code a suitable command word.
	S16BIT swResult; // Result of operation or function call.
	U16BIT wCommandWord1; // Command word 1.
	swResult = sitalBcStld1553_Command_GetCode (&wCommandWord1, sital1553_BROADCAST, wMessageDirection, sital1553_MODE_CODE1, wModeCommand);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Set the BC control word for message 1 (ignore special options which aren't part of the BC control word).
	U16BIT wBcControlWordForMessage1; // BC control word for message 1.
	wBcControlWordForMessage1 = (U16BIT)((bcControlWord_NON_SPECIAL_OPTIONS & dwOptions) | sitalBcControlWord_BROADCAST | sitalBcControlWord_MODE);

	/// Analyze given message options in order to Modify an already created proper message.
	if (0U != (sitalBcMessageOption_DUAL_MESSAGE & dwOptions))
	{
		// Dual message requested.
		// As the function prototype does not contain a separate data-block-ID argument for message 2, use the one supplied for both messages (the user will be able to modify this later on).
		return sitalBc_Message_Modify (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord1, 0U, wGapTime, swDataBlockId, wBcControlWordForMessage1, wCommandWord1, 0U, wGapTime, wModificationFlags);
	}
	else
	if (0U != (sitalBcMessageOption_STAY_ON_ALTERNATE_BUS & dwOptions))
	{
		// Message with retries requested: Use a proper dual message to achieve this effect.
		// Set the BC control word of message 2 same as of message 1, just make it use the alternate bus.
		wBcControlWordForMessage1 |= sitalBcControlWord_RETRY_ENABLED;
		U16BIT wBcControlWordForMessage2; // BC control word for message 2.
		wBcControlWordForMessage2 = (U16BIT)(((~bcControlWord_BUS_SELECTOR) & wBcControlWordForMessage1) | (bcControlWord_BUS_SELECTOR & (~(bcControlWord_BUS_SELECTOR & wBcControlWordForMessage1))));

		return sitalBc_Message_Modify (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord1, 0U, wGapTime, swDataBlockId, wBcControlWordForMessage2, wCommandWord1, 0U, wGapTime, wModificationFlags);
	}
	else
	{
		// Regular message requested.
		return sitalBc_Message_Modify (swDevice, swMessageId, swDataBlockId, wBcControlWordForMessage1, wCommandWord1, 0U, wGapTime, 0, 0U, 0U, 0U, 0U, wModificationFlags);
	}
}


/// <summary>
/// Modify a message that has been previously created for given BC device.
///
/// See further information in the documentation for function sitalBc_Message_Create.
///
/// Equivalent DDC definition: aceBCMsgModify
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swMessageId (in)	A unique ID designating a message (0-(sitalBcCounter_MESSAGES-1))
/// @param swDataBlockIdForMessage1 (in)	A unique ID designating the data block of message 1 (0-(sitalBcCounter_DATA_BLOCKS-1))
/// @param wBcControlWordForMessage1 (in)	The BC control word of message 1 (An or-ed combination of sitalBcControlWord_*)
/// @param wCommandWord1ForMessage1 (in)	Command word 1 of message 1
/// @param wCommandWord2ForMessage1 (in)	Command word 2 of message 1
/// @param wGapTimeForMessage1 (in)	The gap of message 1 (>=0)
/// @param swDataBlockIdForMessage2 (in)	A unique ID designating the data block of message 2 (0-(sitalBcCounter_DATA_BLOCKS-1))
/// @param wBcControlWordForMessage2 (in)	The BC control word of message 2 (An or-ed combination of sitalBcControlWord_*)
/// @param wCommandWord1ForMessage2 (in)	Command word 1 of message 2
/// @param wCommandWord2ForMessage2 (in)	Command word 2 of message 2
/// @param wGapTimeForMessage2 (in)	The gap of message 2 (>=0)
/// @param wModificationFlags (in)	Message modification options (An or-ed combination of sitalBcMessageModifier_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_Message_Modify (	S16BIT swDevice,
										S16BIT swMessageId,
										S16BIT swDataBlockIdForMessage1,
										U16BIT wBcControlWordForMessage1,
										U16BIT wCommandWord1ForMessage1,
										U16BIT wCommandWord2ForMessage1,
										U16BIT wGapTimeForMessage1,
										S16BIT swDataBlockIdForMessage2,
										U16BIT wBcControlWordForMessage2,
										U16BIT wCommandWord1ForMessage2,
										U16BIT wCommandWord2ForMessage2,
										U16BIT wGapTimeForMessage2,
										U16BIT wModificationFlags)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	/// With non modified message parameters, obtain the original parameters of the message.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (((S16BIT)0U > swMessageId) || ((S16BIT)sitalBcCounter_MESSAGES <= swMessageId))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	HostMessageStructure* hmspMessage; // A pointer to a host message structure.
	hmspMessage = (HostMessageStructure*)&(dsspDeviceState->bsBcState.hmsaMessage[swMessageId]);
	if (TRUE == hmspMessage->bIsFreeForUse)
	{
		return sitalReturnCode_UNDEFINED_MESSAGE_BLOCK;
	}

	if (0U == wModificationFlags)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	BOOLEAN bIsDualMessage; // A flag that says if a dual message is requested.
	bIsDualMessage = (BOOLEAN)((U32BIT)0U != ((U32BIT)sitalBcMessageOption_DUAL_MESSAGE & hmspMessage->dwOptions));
	if	(
			((U16BIT)0U != ((U16BIT)sitalBcMessageModifier_MESSAGE2_DATA_BLOCK & wModificationFlags)) ||
			((U16BIT)0U != ((U16BIT)sitalBcMessageModifier_MESSAGE2_BC_CONTROL & wModificationFlags)) ||
			((U16BIT)0U != ((U16BIT)sitalBcMessageModifier_MESSAGE2_COMMAND1 & wModificationFlags)) ||
			((U16BIT)0U != ((U16BIT)sitalBcMessageModifier_MESSAGE2_COMMAND2 & wModificationFlags)) ||
			((U16BIT)0U != ((U16BIT)sitalBcMessageModifier_MESSAGE2_GAPTIME & wModificationFlags))
		)
	{
		if ((BOOLEAN)FALSE == bIsDualMessage)
		{
			return sitalReturnCode_BC_INVALID_DATA_BLOCK_SIZE;
		}
	}

	HostDataBlockStructure* hdbspDataBlock1; // A pointer to a host data block structure.
	if ((U16BIT)0U == ((U16BIT)sitalBcMessageModifier_MESSAGE1_DATA_BLOCK & wModificationFlags))
	{
		swDataBlockIdForMessage1 = hmspMessage->swDataBlockIdForMessage1;
		hdbspDataBlock1 = (HostDataBlockStructure*)&(dsspDeviceState->bsBcState.hdbsaDataBlock[swDataBlockIdForMessage1]);
	}
	else
	{
		if (((S16BIT)0U > swDataBlockIdForMessage1) || ((S16BIT)sitalBcCounter_DATA_BLOCKS <= swDataBlockIdForMessage1))
		{
			return sitalReturnCode_INVALID_PARAMETER;
		}

		hdbspDataBlock1 = (HostDataBlockStructure*)&(dsspDeviceState->bsBcState.hdbsaDataBlock[swDataBlockIdForMessage1]);
		if (TRUE == hdbspDataBlock1->bIsFreeForUse)
		{
			return sitalReturnCode_UNDEFINED_DATA_BLOCK;
		}
	}

	HostDataBlockStructure* hdbspDataBlock2; // A pointer to a host data block structure.
	hdbspDataBlock2 = ((HostDataBlockStructure*)NULL);
	if ((U16BIT)0U == ((U16BIT)sitalBcMessageModifier_MESSAGE2_DATA_BLOCK & wModificationFlags))
	{
		if (TRUE == bIsDualMessage)
		{
			swDataBlockIdForMessage2 = hmspMessage->swDataBlockIdForMessage2;
			hdbspDataBlock2 = (HostDataBlockStructure*)&(dsspDeviceState->bsBcState.hdbsaDataBlock[swDataBlockIdForMessage2]);
		}
	}
	else
	{
		if (((S16BIT)0U > swDataBlockIdForMessage2) || ((S16BIT)sitalBcCounter_DATA_BLOCKS <= swDataBlockIdForMessage2))
		{
			return sitalReturnCode_INVALID_PARAMETER;
		}

		hdbspDataBlock2 = (HostDataBlockStructure*)&(dsspDeviceState->bsBcState.hdbsaDataBlock[swDataBlockIdForMessage2]);
		if (TRUE == hdbspDataBlock2->bIsFreeForUse)
		{
			return sitalReturnCode_UNDEFINED_DATA_BLOCK;
		}
	}

	if ((U16BIT)0U == ((U16BIT)sitalBcMessageModifier_MESSAGE1_BC_CONTROL & wModificationFlags))
	{
		wBcControlWordForMessage1 = hmspMessage->wBcControlWordForMessage1;
	}
	else
	{
		if ((U16BIT)0U == ((U16BIT)sitalBcControlWord_MODE & hmspMessage->wBcControlWordForMessage1))
		{
			// That's a regular message, the size of the data block must suit given command word.
			if (((U32BIT)((commandWord_WORD_COUNT_OR_MODE_CODE & wCommandWord1ForMessage1) >> commandWord_OFFSET_OF_WORD_COUNT_OR_MODE_CODE)) > hdbspDataBlock1->wActualSize)
			{
				return sitalReturnCode_BC_INVALID_DATA_BLOCK_SIZE;
			}
		}
		else
		{
			// That's a mode code message, the data block must contain at least one data word.
			if (1 > hdbspDataBlock1->wActualSize)
			{
				return sitalReturnCode_BC_INVALID_DATA_BLOCK_SIZE;
			}
		}
	}

	if ((U16BIT)0U == ((U16BIT)sitalBcMessageModifier_MESSAGE2_BC_CONTROL & wModificationFlags))
	{
		wBcControlWordForMessage2 = hmspMessage->wBcControlWordForMessage2;
	}
	else
	{
		if ((U16BIT)0U == ((U16BIT)sitalBcControlWord_MODE & hmspMessage->wBcControlWordForMessage2))
		{
			// That's a regular message, the size of the data block must suit given command word.
			if (((U32BIT)((commandWord_WORD_COUNT_OR_MODE_CODE & wCommandWord1ForMessage2) >> commandWord_OFFSET_OF_WORD_COUNT_OR_MODE_CODE)) > hdbspDataBlock2->wActualSize)
			{
				return sitalReturnCode_BC_INVALID_DATA_BLOCK_SIZE;
			}
		}
		else
		{
			// That's a mode code message, the data block must contain at least one data word.
			if (1U > hdbspDataBlock2->wActualSize)
			{
				return sitalReturnCode_BC_INVALID_DATA_BLOCK_SIZE;
			}
		}
	}

	if ((U16BIT)0U == ((U16BIT)sitalBcMessageModifier_MESSAGE1_COMMAND1 & wModificationFlags))
	{
		wCommandWord1ForMessage1 = hmspMessage->wCommandWord1ForMessage1;
	}

	if ((U16BIT)0U == ((U16BIT)sitalBcMessageModifier_MESSAGE1_COMMAND2 & wModificationFlags))
	{
		wCommandWord2ForMessage1 = hmspMessage->wCommandWord2ForMessage1;
	}

	if ((U16BIT)0U == ((U16BIT)sitalBcMessageModifier_MESSAGE2_COMMAND1 & wModificationFlags))
	{
		wCommandWord1ForMessage2 = hmspMessage->wCommandWord1ForMessage2;
	}

	if ((U16BIT)0U == ((U16BIT)sitalBcMessageModifier_MESSAGE2_COMMAND2 & wModificationFlags))
	{
		wCommandWord2ForMessage2 = hmspMessage->wCommandWord2ForMessage2;
	}

	if ((U16BIT)0U == ((U16BIT)sitalBcMessageModifier_MESSAGE1_GAPTIME & wModificationFlags))
	{
		wGapTimeForMessage1 = hmspMessage->wGapTimeForMessage1;
	}

	if ((U16BIT)0U == ((U16BIT)sitalBcMessageModifier_MESSAGE2_GAPTIME & wModificationFlags))
	{
		wGapTimeForMessage2 = hmspMessage->wGapTimeForMessage2;
	}

	// At this point an updated set of message parameters is ready.
	/// Update given message, and determine its current actual size.
	// Note that as function sitalBc_Message_Create always allocates device memory for the maximum possible message, the size of a message may be later on modified without any further allocation.
	S16BIT swResult; // Result of operation or function call.
	swResult = bc_Message_Write (swDevice, swMessageId, swDataBlockIdForMessage1, wBcControlWordForMessage1, wCommandWord1ForMessage1, wCommandWord2ForMessage1, wGapTimeForMessage1, swDataBlockIdForMessage2, wBcControlWordForMessage2, wCommandWord1ForMessage2, wCommandWord2ForMessage2, wGapTimeForMessage2, hmspMessage->dwOptions, hmspMessage, hdbspDataBlock1, hdbspDataBlock2, FALSE);
	return swResult;
}


/// <summary>
/// Delete given message which has been previously created for given BC device.
///
/// Note:
/// - A regular message may be principally deleted along frame run in order to be compatible with DDC's library;
///   Yet, delete isn't supported if this message is the message transmitted by any existing message-transmitter command,
///   so that a situation in which a regular command orders the transmission of an already deleted message is prohibited.
/// - An asynchronous message may be principally deleted along frame run in order to be compatible with DDC's library;
///   Moreover, this must be allowed in order to let the user change the group of asynchronous messages along time while running a frame;
///   Yet, if the user does so right after requesting the Tx of asynchronous message[s], then overrides the device memory
///   that has been originally allocated for the deleted message,- all of this before the device had a chance to transmit this message,
///   it may cause unexpected results.
///
/// Equivalent DDC definition: aceBCMsgDelete
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_Message_Delete (S16BIT swDevice, S16BIT swMessageId)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (((S16BIT)0U > swMessageId) || ((S16BIT)sitalBcCounter_MESSAGES <= swMessageId))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	HostMessageStructure* hmspMessage; // A pointer to a host message structure.
	hmspMessage = &(dsspDeviceState->bsBcState.hmsaMessage[swMessageId]);
	if (TRUE == hmspMessage->bIsFreeForUse)
	{
		return sitalReturnCode_UNDEFINED_MESSAGE_BLOCK;
	}

	// Verify that no command exists that transmits given message.
	// Message-transmitter commands either contain the hardware opcodes XEQ and XQF or the software opcode time conditioned message Tx, and with these commands
	// the convention used by this library is that function sitalBc_Command_Create receives the ID of their transmitted message as their first parameter.
	BOOLEAN bIsDeletedObjectStillInUse; // A flag that says whether given deleted object is currently in use by any existing object of relevant type.
	bIsDeletedObjectStillInUse = FALSE;
	for (U16BIT i=0U; ((i<sitalBcCounter_COMMANDS) && (FALSE == bIsDeletedObjectStillInUse)); i++)
	{
		HostCommandStructure* hcspCurrentCommand; // A pointer to the currently dealt with command.
		hcspCurrentCommand = &(dsspDeviceState->bsBcState.hcsaCommand[i]);
		if	(
				(FALSE == hcspCurrentCommand->bIsFreeForUse) &&
				((sitalOpcode_TIME_CONDITIONED_MESSAGE_TX == hcspCurrentCommand->wOpcode) || (sitalOpcode_EXECUTE_MESSAGE == hcspCurrentCommand->wOpcode) || (sitalOpcode_EXECUTE_AND_FLIP == hcspCurrentCommand->wOpcode)) &&
				((U32BIT)swMessageId == hcspCurrentCommand->dwParameter1)
			)
		{
			bIsDeletedObjectStillInUse = TRUE;
		}
	}
	if (TRUE == bIsDeletedObjectStillInUse)
	{
		return sitalReturnCode_NOT_SUPPORTED;
	}

	/// Free the device memory that has been allocated for given data block.
	S16BIT swResult; // Result of operation or function call.
	swResult = Device_Memory_TopSection_FreeRegion (&(dsspDeviceState->hdmmsDeviceMemoryMap), hmspMessage->dwAddress, (hmspMessage->dwAddress + hmspMessage->wDeviceMemorySize - 1U));

	/// Delete given message.
	hmspMessage->bIsFreeForUse = TRUE;

	if (TRUE == hmspMessage->bIsAsynchronousMessage)
	{
		dsspDeviceState->bsBcState.wAsynchronousMessagesCount--;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Read given message of given BC device in its raw state into given buffer, and then purge given message if so requested.
///
/// Note:
/// - This function assumes that given buffer is at least sitalBcMaximum_MESSAGE_SIZE words long.
/// - Given buffer is first zeroed, and then filled as follows:
///   - The target message block is copied into it.
///   - The data stack pointer is replaced with a word whose:
///     - MSByte contains the count of data words for the message that was read.
///     - LSByte contains the type of the message that was read (sitalMessageType_*).
///   - The data words are stored right after the longest possible message block, that is, starting at offset sitalBcMaximum_ACTUAL_MESSAGE_BLOCK.
///     In case of a mode code message with data, this data word is returned as the first (actually the single) data word.
/// - Message data is copied under assumption that the expected number of data words has been actually received, what the caller may verify by checking the block status.
/// - In case a host buffer is assigned to a device, then right after any new message is recorded in this host buffer, that message is purged from the stack.
///   In other words, the usage of a host buffer and the usage of sital*_Message_Get* functions is basically mutually exclussive.
///
/// Equivalent DDC definition: aceBCGetMsgFromIDRaw
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swMessageId (in)	A unique ID designating a message (0-(sitalBcCounter_MESSAGES-1))
/// @param wapBuffer (out)	A pointer to a buffer into which given message is copied
/// @param wIsPurgeRequired (in)	A flag that says whether should zero the end of message bit of the block status word within the message block of given message
/// @return 1	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_Message_GetByIdRaw (	S16BIT swDevice,
											S16BIT swMessageId,
											U16BIT* wapBuffer,
											U16BIT wIsPurgeRequired)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (((S16BIT)0U > swMessageId) || ((S16BIT)sitalBcCounter_MESSAGES <= swMessageId))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	HostMessageStructure* hmspMessage; // A pointer to a host message structure.
	hmspMessage = (HostMessageStructure*)&(dsspDeviceState->bsBcState.hmsaMessage[swMessageId]);
	if (TRUE == hmspMessage->bIsFreeForUse)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if (((U16BIT*)NULL) == wapBuffer)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Copy given message in its raw state into given buffer.
	/// If purge requested:
	///		Purge given message.
	return bc_Message_GetByIdRaw (swDevice, swMessageId, wapBuffer, wIsPurgeRequired);
}


/// <summary>
/// Decode given message of given BC device into given structure.
///
/// Note:
/// - This function does not really require the logical number of the relevant device, which isn't removed only in order to stay compatible with DDC.
///   (DDC use this parameter to verify the given device is a BC at state READY or RUN, which is a non really required restriction.)
/// - This function assumes that given buffer is at least sitalBcMaximum_MESSAGE_SIZE words long.
/// - This function assumes that given buffer has been previously filled by function sitalBc_Message_GetByIdRaw.
///   See the documentation for this function for information on the contents of its returned buffer.
/// - In case given buffer contains a mode code message with data, this data word is returned as the first (actually the single) data word of the decoded message.
///
/// Equivalent DDC definition: aceBCDecodeRawMsg
/// @param swDevice (in)	Logical number of device (0-31, unused)
/// @param wapBuffer (in)	A pointer to a buffer in which a raw message is stored
/// @param dmspDecodedMessage (out)	A pointer to a structure into which a message is decoded
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_Message_DecodeRaw (S16BIT swDevice, U16BIT* wapBuffer, sitalDecodedMessageStructure* dmspDecodedMessage)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((sitalDecodedMessageStructure*)NULL) == dmspDecodedMessage)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if (((U16BIT*)NULL) == wapBuffer)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Extricate the type of given message and its number of data words.
	// Within given raw message block the data block address field has been overridden with a combined word value whose:
	// - LSByte contains the type of given message.
	// - MSByte contains the count of data words of given message.
	U16BIT wMessageType; // The type of given message.
	wMessageType = ((U16BIT)0xFFU & wapBuffer[bcMessageBlock_OFFSET_OF_DATA_BLOCK_ADDRESS]);
	U16BIT wDataWordCount; // The principally expected number of data words with messages of same type as given message.
	wDataWordCount = ((U16BIT)0x7FU & (wapBuffer[bcMessageBlock_OFFSET_OF_DATA_BLOCK_ADDRESS] >> 8U));
	if (0U == wDataWordCount)
	{
		wDataWordCount = 32U;
	}

	/// Initialize given message structure.
	memset (dmspDecodedMessage, 0, sizeof(sitalDecodedMessageStructure));

	/// Decode message information that's common to all message types from given raw message into given message structure.
	dmspDecodedMessage->wBcControlWord	= wapBuffer[bcMessageBlock_OFFSET_OF_BC_CONTROL_WORD];
	dmspDecodedMessage->wCommandWord1 = wapBuffer[bcMessageBlock_OFFSET_OF_COMMAND_1];
	dmspDecodedMessage->bIsCommandWord1Relevant = TRUE;
	dmspDecodedMessage->wType = wMessageType;
	dmspDecodedMessage->wBcGapTime	= wapBuffer[bcMessageBlock_OFFSET_OF_GAP_TO_NEXT_MESSAGE];
	dmspDecodedMessage->wTimeTag = wapBuffer[bcMessageBlock_OFFSET_OF_TIME_TAG];
	dmspDecodedMessage->wBlockStatus = wapBuffer[bcMessageBlock_OFFSET_OF_BLOCK_STATUS];
	dmspDecodedMessage->wBcLoopbackWord1 = wapBuffer[bcMessageBlock_OFFSET_OF_LOOPBACK_WORD];
	dmspDecodedMessage->bIsBcLoopbackWord1Relevant = TRUE;

	/// If given message is of a type where there is a second command word:
	///		Copy second command word from given raw message into given message structure.
	/// Copy received status words from given raw message into given message structure.
	/// Copy received message data words from given raw message into given message structure.
	switch (wMessageType)
	{
	case sitalMessageType_BC_TO_RT:
		// With RT-to-RT messages there is a second command word.
		if (sitalBcBlockStatusWord_NO_RESPONSE != (sitalBcBlockStatusWord_NO_RESPONSE & dmspDecodedMessage->wBlockStatus))
		{
			dmspDecodedMessage->wStatus1 = wapBuffer[bcMessageBlock_OFFSET_OF_RT_STATUS_WORD_1];
			dmspDecodedMessage->bIsStatus1Relevant = TRUE;
		}

		// With this type of message the BC is expected to send data (not a RT), so assume successful data Tx.
		dmspDecodedMessage->wDataWordCount = wDataWordCount;

		break;

	case sitalMessageType_RT_TO_BC:
		// With this type of message response must be received on time, or otherwise results are entirely ignored.
		if (sitalBcBlockStatusWord_NO_RESPONSE != (sitalBcBlockStatusWord_NO_RESPONSE & dmspDecodedMessage->wBlockStatus))
		{
			dmspDecodedMessage->wStatus1 = wapBuffer[bcMessageBlock_OFFSET_OF_RT_STATUS_WORD_1];
			dmspDecodedMessage->bIsStatus1Relevant = TRUE;

			if (sitalBcBlockStatusWord_GOOD_DATA_BLOCK_RECEIVED == (sitalBcBlockStatusWord_GOOD_DATA_BLOCK_RECEIVED & dmspDecodedMessage->wBlockStatus))
			{
				dmspDecodedMessage->wDataWordCount = wDataWordCount;
			}
		}

		break;

	case sitalMessageType_RT_TO_RT:
		// With RT-to-RT messages there is a second command word.
		dmspDecodedMessage->wCommandWord2 = wapBuffer[bcMessageBlock_OFFSET_OF_COMMAND_2];
		dmspDecodedMessage->bIsCommandWord2Relevant = TRUE;

		// With this type of message data must be successfully received, or otherwise results are entirely ignored.
		if (sitalBcBlockStatusWord_GOOD_DATA_BLOCK_RECEIVED == (sitalBcBlockStatusWord_GOOD_DATA_BLOCK_RECEIVED & dmspDecodedMessage->wBlockStatus))
		{
			// With regular (=non-broadcast) RT-to-RT messages the first status is the transmitter status.
			dmspDecodedMessage->wStatus1 = wapBuffer[bcMessageBlock_OFFSET_OF_RT_STATUS_WORD_1];
			dmspDecodedMessage->bIsStatus1Relevant = TRUE;
			dmspDecodedMessage->wDataWordCount = wDataWordCount;

			// With this type of message response must be received on time, or otherwise receiver-side results are entirely ignored.
			if (sitalBcBlockStatusWord_NO_RESPONSE != (sitalBcBlockStatusWord_NO_RESPONSE & dmspDecodedMessage->wBlockStatus))
			{
				// With regular (=non-broadcast) RT-to-RT messages the second status is the receiver status.
				dmspDecodedMessage->wStatus2 = wapBuffer[bcMessageBlock_OFFSET_OF_RT_STATUS_WORD_2];
				dmspDecodedMessage->bIsStatus2Relevant = TRUE;
			}
		}

		break;

	case sitalMessageType_MODE_NO_DATA:
		// With this type of message response must be received on time, or otherwise results are entirely ignored.
		if (sitalBcBlockStatusWord_NO_RESPONSE != (sitalBcBlockStatusWord_NO_RESPONSE & dmspDecodedMessage->wBlockStatus))
		{
			dmspDecodedMessage->wStatus1 = wapBuffer[bcMessageBlock_OFFSET_OF_RT_STATUS_WORD_1];
			dmspDecodedMessage->bIsStatus1Relevant = TRUE;
		}

		break;

	case sitalMessageType_MODE_DATA_RX:
		// With this type of message response must be received on time, or otherwise receiver-side results are entirely ignored.
		if (sitalBcBlockStatusWord_NO_RESPONSE != (sitalBcBlockStatusWord_NO_RESPONSE & dmspDecodedMessage->wBlockStatus))
		{
			dmspDecodedMessage->wStatus1 = wapBuffer[bcMessageBlock_OFFSET_OF_RT_STATUS_WORD_1];
			dmspDecodedMessage->bIsStatus1Relevant = TRUE;
		}

		// With this type of message the BC is expected to send data (not a RT), so assume successful data Tx.
		dmspDecodedMessage->wDataWordCount = wDataWordCount;
		break;

	case sitalMessageType_MODE_DATA_TX:
		// With this type of message data must be successfully received, or otherwise results are entirely ignored.
		if (sitalBcBlockStatusWord_GOOD_DATA_BLOCK_RECEIVED == (sitalBcBlockStatusWord_GOOD_DATA_BLOCK_RECEIVED & dmspDecodedMessage->wBlockStatus))
		{
			// With this type of message response must be received on time, or otherwise results are entirely ignored.
			if (sitalBcBlockStatusWord_NO_RESPONSE != (sitalBcBlockStatusWord_NO_RESPONSE & dmspDecodedMessage->wBlockStatus))
			{
				dmspDecodedMessage->wStatus1 = wapBuffer[bcMessageBlock_OFFSET_OF_RT_STATUS_WORD_1];
				dmspDecodedMessage->bIsStatus1Relevant = TRUE;
				if (sitalBcBlockStatusWord_GOOD_DATA_BLOCK_RECEIVED == (sitalBcBlockStatusWord_GOOD_DATA_BLOCK_RECEIVED & dmspDecodedMessage->wBlockStatus))
				{
					dmspDecodedMessage->wDataWordCount = wDataWordCount;
				}
			}
		}

		break;

	case sitalMessageType_BROADCAST_RT_TO_RT:
		// With RT-to-RT messages there is a second command word.
		dmspDecodedMessage->wCommandWord2 = wapBuffer[bcMessageBlock_OFFSET_OF_COMMAND_2];
		dmspDecodedMessage->bIsCommandWord2Relevant = TRUE;

		// With this type of message data must be successfully received, or otherwise results are entirely ignored.
		if (sitalBcBlockStatusWord_GOOD_DATA_BLOCK_RECEIVED == (sitalBcBlockStatusWord_GOOD_DATA_BLOCK_RECEIVED & dmspDecodedMessage->wBlockStatus))
		{
			dmspDecodedMessage->wStatus1 = wapBuffer[bcMessageBlock_OFFSET_OF_RT_STATUS_WORD_1];
			dmspDecodedMessage->bIsStatus1Relevant = TRUE;
			dmspDecodedMessage->wDataWordCount = wDataWordCount;
		}

		break;

	case sitalMessageType_BROADCAST:
	case sitalMessageType_BROADCAST_MODE_DATA:
		// With this type of message the BC is expected to send data (not a RT), so assume successful data Tx.
		dmspDecodedMessage->wDataWordCount = wDataWordCount;

		break;

	default:
		// Given raw message has no second command word, and includes no statuses.
		break;
	}

	/// Copy the actual data words.
	memcpy (((void*)(dmspDecodedMessage->waData)), ((void*)(&(wapBuffer[sitalBcMaximum_ACTUAL_MESSAGE_BLOCK]))), ((size_t)(dmspDecodedMessage->wDataWordCount << 1U)));

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Read given message of given BC device, decode it into given structure, and then purge given message if so requested.
///
/// Note:
/// - In case of a mode code message with data, this data word is returned as the first (actually the single) data word.
/// - In case a host buffer is assigned to a device, then right after any new message is recorded in this host buffer, that message is purged from the stack.
///   In other words, the usage of a host buffer and the usage of sital*_Message_Get* functions is basically mutually exclussive.
///
/// Equivalent DDC definition: aceBCGetMsgFromIDDecoded
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swMessageId (in)	A unique ID designating a message (0-(sitalBcCounter_MESSAGES-1))
/// @param dmspDecodedMessage (out)	A pointer to a structure into which a message is decoded
/// @param wIsPurgeRequired (in)	A flag that says whether should zero the end of message bit of the block status word within the message block of given message
/// @return 1	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_Message_GetByIdDecoded (	S16BIT swDevice,
												S16BIT swMessageId,
												sitalDecodedMessageStructure* dmspDecodedMessage,
												U16BIT wIsPurgeRequired)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (((S16BIT)0U > swMessageId) || ((S16BIT)sitalBcCounter_MESSAGES <= swMessageId))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	HostMessageStructure* hmspMessage; // A pointer to a host message structure.
	hmspMessage = (HostMessageStructure*)&(dsspDeviceState->bsBcState.hmsaMessage[swMessageId]);
	if (TRUE == hmspMessage->bIsFreeForUse)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if (((sitalDecodedMessageStructure*)NULL) == dmspDecodedMessage)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Get given message in its raw state.
	/// If purge requested:
	///		Purge given message.
	U16BIT waBuffer[sitalBcMaximum_MESSAGE_SIZE]; // A temporary buffer to store within a message in its raw state.
	S16BIT swResult; // Result of operation or function call.
	swResult = bc_Message_GetByIdRaw (swDevice, swMessageId, waBuffer, wIsPurgeRequired);
	if (1 != swResult)
	{
		return swResult;
	}

	swResult = sitalBc_Message_DecodeRaw (swDevice, waBuffer, dmspDecodedMessage);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	return 1;
}


/// <summary>
/// Configure given BC device to enable/disable the message gap time field for all messages.
///
/// Equivalent DDC definition: aceBCMsgGapTimerEnable
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param bIsMessageGapTimeFieldEnabled (in)	 A flag that says whether the message gap time field should be enabled for all messages (or, otherwise, disabled)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_ConfigureMessageGapTimeFieldPolicy (S16BIT swDevice, U16BIT bIsMessageGapTimeFieldEnabled)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	///	If the device isn't currently running:
	///		Update the configuration register #1 image.
	///	Else:
	///		Update the configuration register #1.
	S16BIT swResult; // Result of operation or function call.
	U16BIT wRegisterValue; // The current value of a target register, or the value to set for a target register.
	wRegisterValue = (U16BIT)( ((U16BIT)FALSE == bIsMessageGapTimeFieldEnabled) ? registerMask_ALL_BITS_OFF : registerMask_ALL_BITS_ON );
	if (sitalDeviceState_READY == dsspDeviceState->wCurrentState)
	{
		swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_1, (U16BIT)sitalConfigurationRegister1_BC_MESSAGE_GAP_TIME_FIELD_ENABLED, (U16BIT)wRegisterValue);
	}
	else
	{
		S16BIT swResult; // Result of operation or function call.
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, sitalRegisterAddress_CONFIGURATION_1, sitalDeviceMemorySection_Registers, sitalConfigurationRegister1_BC_MESSAGE_GAP_TIME_FIELD_ENABLED, &wRegisterValue);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Set given effect with the state of given GFP condition of given BC device.
///
/// Equivalent DDC definition: aceBCSetGPFState
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wGpfNumber (in)	 General-purpose-flag-related condition code (sitalBcGpf_GPF*)
/// @param wEffect (in)	 Requested effect (sitalBcGpfEffect_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_Gpf_SetState (S16BIT swDevice, U16BIT wGpfNumber, U16BIT wEffect)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_RUN != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((0U >= wGpfNumber) || (opcodeGpf_GPF_NUMBER_BORDER <= wGpfNumber))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if ((0U > wEffect) || (bcGpfEffect_BORDER <= wEffect))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Properly update the GPF register.
	return bc_Gpf_SetState (swDevice, wGpfNumber, wEffect);
}


/// <summary>
/// Read the BC Condition Code register of given BC device and obtain the current state of given condition.
///
/// Note:
/// - The current state of given condition is the value currently stored in its respective bit[s] in the BC condition code register.
///
/// Equivalent DDC definition: aceBCGetConditionCode
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wCondition (in)	 Condition code (sitalBcConditionCode_*)
/// @param wpCurrentState (out)	A pointer to a variable within which current state, off (0) or on (1), is returned
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_GetConditionState (S16BIT swDevice, U16BIT wCondition, U16BIT* wpCurrentState)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_RUN != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((0U > wCondition) || (opcodeCondition_GET_STATE_BORDER <= wCondition))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if (((U16BIT*)NULL) == wpCurrentState)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	U16BIT wRegisterValue; // The current value of a target register, or the value to set for a target register.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, sitalRegisterAddress_CONFIGURATION_1, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	if (sitalConfigurationRegister1_BC_BUSY != (sitalConfigurationRegister1_BC_BUSY & wRegisterValue))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	/// Read the current value of the condition code register.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, sitalRegisterAddress_BC_CONDITION_CODE, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}


	// The value of the condition code register is as follows:
	// - Bit 15: Always on while the BC is running, and otherwise off.
	// - Bits 8-14: Reflect different aspects of the results of the processing and transmission of the last message by given BC device.
	// - Bits 0-7: GPF bits.
	// These bits are attributed to respective conditions in a way that they directly determine the current state of these conditions.
	static const U16BIT s_waConditionCodeMask[] =
											{
												(U16BIT)bcConditionCode_GFP_EQUAL_FLAG,
												(U16BIT)bcConditionCode_GPF_LESS_THAN_FLAG,
												(U16BIT)bcConditionCode_GPF2,
												(U16BIT)bcConditionCode_GPF3,
												(U16BIT)bcConditionCode_GPF4,
												(U16BIT)bcConditionCode_GPF5,
												(U16BIT)bcConditionCode_GPF6,
												(U16BIT)bcConditionCode_GPF7,
												(U16BIT)bcConditionCode_NO_RESPONSE,
												(U16BIT)bcConditionCode_FORMAT_ERROR,
												(U16BIT)bcConditionCode_GOOD_DATA_BLOCK_TRANSFER,
												(U16BIT)bcConditionCode_MASKED_STATUS,
												(U16BIT)bcConditionCode_BAD_MESSAGE,
												(U16BIT)bcConditionCode_RETRY_COUNT,
												(U16BIT)0, // Just placeholder, should not actually be used.
												(U16BIT)bcConditionCode_ALWAYS
											};
	(*wpCurrentState) = ((s_waConditionCodeMask[wCondition] & wRegisterValue) >> wCondition);

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Read the next unread entry from the GPQ of given BC device.
///
/// Note:
/// - This function only returns GPQ entries that were filled by BC commands that have been explicitly inserted to the running frame by the user.
///   In other words, those GPQ entries that are regularly filled by BC commands that have been inserted to the running frame by this library (i.e.,
///   framing commands, see the documentation for function sitalBc_Start) aren't returned by this function.
/// - Yet, this function also reads GPQ entries that were filled by framing commands, internally stores them, and removes them from the GPQ.
///
/// Equivalent DDC definition: aceBCGPQRead
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param gespGpqEntry (out)	A pointer to the GPQ entry structure to fill with the now-read GPQ entry
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return sitalReturnCode_ReadGpqEntry_NO_NEW_ONES	No entries were read
/// @return sitalReturnCode_ReadGpqEntry_READ_NEW_ENTRY	One entry was read
/// @return sitalReturnCode_ReadGpqEntry_READ_NEW_ENTRY_AND_DETECTED_OVERRUN	One entry was read, and one other or more were lost
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_Gpq_Read (S16BIT swDevice, sitalGpqEntryStructure* gespGpqEntry)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (((sitalGpqEntryStructure*)NULL) == gespGpqEntry)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	return bc_Gpq_Read (swDevice, gespGpqEntry, TRUE);
}


/// <summary>
/// Return the current number of available entries in the GPQ of given BC device.
///
/// Note:
/// - This function only considers GPQ entries that were filled by BC commands that have been explicitly inserted to the running frame by the user.
///   In other words, those GPQ entries that are regularly filled by BC commands that have been inserted to the running frame by this library (i.e.,
///   framing commands, see the documentation for function sitalBc_Start) aren't taken in account by this function.
///
/// Equivalent DDC definition: aceBCGPQGetCount
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// @return Non-negative integer	Count of available GPQ entries
/// </summary>
S16BIT _DECL sitalBc_Gpq_GetEntriesCount (S16BIT swDevice)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	HostGeneralPurposeQueueStructure* hgpqspGeneralPurposeQueue; // A pointer to the host GPQ structure.
	hgpqspGeneralPurposeQueue = (HostGeneralPurposeQueueStructure*)&(dsspDeviceState->bsBcState.hgpqsUserGpqContents);

	/// Calculate the number of available GPQ entries.
	if (hgpqspGeneralPurposeQueue->wIndexOfNextFilledGpqEntry > hgpqspGeneralPurposeQueue->wIndexOfNextReadGpqEntry)
	{
		return (S16BIT)((hgpqspGeneralPurposeQueue->wIndexOfNextFilledGpqEntry - hgpqspGeneralPurposeQueue->wIndexOfNextReadGpqEntry) / (U16BIT)bcMemoryObjectSize_GPQ_ENTRY);
	}
	else
	if (hgpqspGeneralPurposeQueue->wIndexOfNextFilledGpqEntry < hgpqspGeneralPurposeQueue->wIndexOfNextReadGpqEntry)
	{
		return (S16BIT)(((U16BIT)sitalBcCounter_GPQ_ENTRIES - hgpqspGeneralPurposeQueue->wIndexOfNextReadGpqEntry + hgpqspGeneralPurposeQueue->wIndexOfNextFilledGpqEntry) / (U16BIT)bcMemoryObjectSize_GPQ_ENTRY);
	}

	return 0;
}


/// <summary>
/// Handle the new entries of the GPQ of given BC device.
/// The way each GPQ entry is handled depends on its contents, and may include making some internal updates, calling the user application's ISR, and recording the latest minor frame that was transmitted by given BC device in its host buffer, if one is available.
///
/// Note:
/// - As can be seen in the documentation for function sitalBc_Start, the scheme used by this library when programming a target BC device with minor frames includes the issue of the following interrupts:
///   - IRQ-3: At end of the active part of each minor frame, if only so configured for this minor frame (see the possible values for parameter wFlags of function sitalBc_Frame_Create).
///   - IRQ-2: At successful end of the passive part (that follows the active part) of each minor frame, if only high-priority asynchronous messages are supported and host buffer has been assigned with the target device.
///   Whenever any of these interrupts occurs, as well as in case of time tag rollover interrupts, this function gets automatically called.
/// - Though not recommended, a user application may also call this function, an resort option with systems where interrupts aren't supported.
///
/// Equivalent DDC definition: aceBCFrmToHBuf
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
S16BIT _DECL sitalBc_Gpq_HandleNewEntries (S16BIT swDevice)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

#ifndef stld1553Library_SINGLE_USER_EXISTS
	// The execution of the following code must be synchronized in order to avoid its execution by a second caller thread before the first caller had a chance to set flag hmspMessage->bIsAnAlreadyRecordedAsynchronousMessage to TRUE.
	if ((int)0U != ((InterProcessSemaphore*)s_ipspSemaphore)->Catch (1U))
	{
		return sitalReturnCode_SYNCHRONIZATION_FAIL;
	}
#endif // stld1553Library_SINGLE_USER_EXISTS

	/// Loop over all available new GPQ entries:
	///		Get the next new GPQ entry.
	///		If the current new entry flags the end of a minor frame and a host buffer has been assigned with given device:
	///			Record the messages of that minor frame in the host buffer of given device.
	///		If the current new entry flags a watchdog timeout and an asynchronous messages ISR has been assigned with given device:
	///			Call the asynchronous messages ISR that has been assigned with given device supplying it the relevant information.
	///		Remove the already handled GPQ entry.
	sitalGpqEntryStructure gesGpqEntry; // A BC GPQ entry.
	S16BIT swResult; // Result of operation or function call.
	int iResult; // Result of operation or function call.
	while (TRUE)
	{
		swResult = bc_Gpq_Read (swDevice, &gesGpqEntry, FALSE);
		if ((S16BIT)0U >= swResult)
		{
#ifndef stld1553Library_SINGLE_USER_EXISTS
			iResult = ((InterProcessSemaphore*)s_ipspSemaphore)->Release ();
#endif // stld1553Library_SINGLE_USER_EXISTS
			return swResult;
		}

		switch (gesGpqEntry.wHeader)
		{
		case sitalGeneralPurposeQueueFlag_END_OF_MAJOR_FRAME:
			break;
		case sitalGeneralPurposeQueueFlag_END_OF_MINOR_FRAME:
			if (0U != dsspDeviceState->bsBcState.hbsHostBuffer.dwHostBufferSize)
			{
				// Note that in this case the GPQ entry contains the minor-frame-ID in its data word.
				// Still, in order to protect from a corruption of the GPQ, this minor-frame-ID must be checked.
				if ((0U <= gesGpqEntry.wData) && (sitalBcCounter_FRAMES > gesGpqEntry.wData))
				{
					HostFrameStructure* hfspFrame; // A pointer to a host frame structure.
					hfspFrame = (HostFrameStructure*)&(dsspDeviceState->bsBcState.hfsaFrame[gesGpqEntry.wData]);
					if ( (FALSE == hfspFrame->bIsFreeForUse) && (sitalBcFrameType_MINOR == hfspFrame->wFrameType) )
					{
						swResult = bc_HostBuffer_RecordTransmittedMinorFrame (swDevice, gesGpqEntry.wData);
					}
				}
				// Here GPQ corruption and function failure are ignored, as the rest of the available new GPQ entries must be handled even in case the update of the host buffer failed.
			}
			break;
		case sitalGeneralPurposeQueueFlag_WATCHDOG_TIMEOUT:
			if (((ASYNCHRONOUS_MESSAGE_ISR_FUNCTION)NULL) != dsspDeviceState->funcpAsynchronousMessagesIsr)
			{
				// Note that in this case the GPQ entry contains the minor-frame-ID in its data word.
				// Assigned callback is called even in case of a bad minor-frame-ID, so that the user application will be able to identify a corruption of the GPQ.
				dsspDeviceState->funcpAsynchronousMessagesIsr (swDevice, gesGpqEntry.wData);
			}
			break;
		default:
			// Irrelevant: All possible cases were already handled.
			break;
		}

		///	Remove the entry that has been just read from the source host GPQ.
		HostGeneralPurposeQueueStructure* hgpqspHostGpq; // A pointer to a target host GPQs.
		hgpqspHostGpq = (HostGeneralPurposeQueueStructure*)&(dsspDeviceState->bsBcState.hgpqsLibraryGpqContents);
		if (hgpqspHostGpq->wIndexOfNextReadGpqEntry != hgpqspHostGpq->wIndexOfNextFilledGpqEntry)
		{
			hgpqspHostGpq->wIndexOfNextReadGpqEntry += 1U;
			if (sitalBcCounter_GPQ_ENTRIES == hgpqspHostGpq->wIndexOfNextReadGpqEntry)
			{
				hgpqspHostGpq->wIndexOfNextReadGpqEntry = 0U;
			}
		}
	}

#ifndef stld1553Library_SINGLE_USER_EXISTS
	if ((int)0U != ((InterProcessSemaphore*)s_ipspSemaphore)->Release ())
	{
		return sitalReturnCode_SYNCHRONIZATION_FAIL;
	}
#endif // stld1553Library_SINGLE_USER_EXISTS

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Return performance information about the general purpose queue of given BC device.
///
/// Equivalent DDC definition: aceBCGetGPQMetric
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param gosspGpqOperationalStatistics (out)	A pointer to the general purpose queue operational statistics structure into which the required operational statistics are written
/// @param bIsResetOfHighestRecordedPercentageRequired (in)	A flag that says whether the record of the highest percentage reached by now should be reset
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_Gpq_GetOperationalStatistics (S16BIT swDevice, sitalGpqOperationalStatisticsStructure* gosspGpqOperationalStatistics, U16BIT bIsResetOfHighestRecordedPercentageRequired)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (((sitalGpqOperationalStatisticsStructure*)NULL) == gosspGpqOperationalStatistics)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if (FALSE == dsspDeviceState->bIsOperationalStatisticsCollected)
	{
		return sitalReturnCode_OPERATIONAL_STATISTICS_NOT_ENABLED;
	}

	gosspGpqOperationalStatistics->dwLostMessageCount = dsspDeviceState->bsBcState.gpqssGpqState.wLostGpqEntryCount;
	gosspGpqOperationalStatistics->wFullnessPercentage = dsspDeviceState->bsBcState.gpqssGpqState.wFullnessPercentage;
	gosspGpqOperationalStatistics->wMaximumFullnessPercentage = dsspDeviceState->bsBcState.gpqssGpqState.wMaximumFullnessPercentage;

	if (TRUE == bIsResetOfHighestRecordedPercentageRequired)
	{
		gosspGpqOperationalStatistics->wMaximumFullnessPercentage = 0U;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Create for given BC device:
/// - A double data block of given ID, and fill its allocated device memory with the contents of given buffer.
/// - An asynchronous message of type BC-to-RT that uses that data block.
///
/// Note:
/// - An asynchronous message is asynchronously transmitted at low priority in result of calling function sitalBc_AsynchronousMessage_SendAtLowPriority.
/// - An asynchronous message is asynchronously transmitted at high priority in result of calling function sitalBc_AsynchronousMessage_SendAtHighPriority.
/// - Unlike a normal message, an asynchronous message may not be transmitted by user-defined commands;
///   This is prohibited by function sitalBc_Command_Create.
///
/// Equivalent DDC definition: aceBCAsyncMsgCreateBCtoRT
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swMessageId (in)	A unique ID designating a message (0-(sitalBcCounter_MESSAGES-1))
/// @param swDataBlockId (in)	A unique ID designating a data block (0-(sitalBcCounter_DATA_BLOCKS-1))
/// @param wReceiverRt (in)	Receiver RT (sitalRtAddress_0-sitalRtAddress_31)
/// @param wReceiverRtSubaddress (in)	Receiver RT's subaddress (sitalRtSubaddress_1-sitalRtSubaddress_30)
/// @param wWordCount (in)	Word count (1-32)
/// @param wGapTime (in)	Gap time (in units of 1us) between the beginning of the message to the beginning of the following message (>=0)
/// @param dwOptions (in)	Message options (An or-ed combination of sitalBcControlWord_* and sitalBcMessageOption_*)
/// @param wapBuffer (in)	A pointer to an array of data words to be copied into the new data block
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_AsynchronousMessage_CreateBcToRt (	S16BIT swDevice,
														S16BIT swMessageId,
														S16BIT swDataBlockId,
														U16BIT wReceiverRt,
														U16BIT wReceiverRtSubaddress,
														U16BIT wWordCount,
														U16BIT wGapTime,
														U32BIT dwOptions,
														U16BIT* wapBuffer)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (0U == (sitalBcSetupOption_ASYNCHRONOUS_BOTH_PRIORITY_MODES & dsspDeviceState->bsBcState.dwOptions))
	{
		return sitalReturnCode_SUITABLE_ASYNCHRONOUS_MODE_UNDEFINED;
	}

	if (sitalBcMaximum_ASYNCHRONOUS_MESSAGES <= dsspDeviceState->bsBcState.wAsynchronousMessagesCount)
	{
		return sitalReturnCode_ASYNCHRONOUS_MESSAGE_ERROR;
	}

	/// Create a new data block of double size to be used by the newly created asynchronous message.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalBc_DataBlock_Create (swDevice, swDataBlockId, sitalBcDataBlockSizeOption_DOUBLE, wapBuffer, bcMemoryObjectSize_DOUBLE_DATA_BLOCK);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	// A basic demand with both high & low asynchronous messages is that they should be transmitted only once.
	// - The technique used by this library achieve this is as follows:
	//   - Each asynchronous message is created by this function (see right below) as a dual message:
	//     - Both messages in this dual message are simply the message that the user has defined
	//     - The BC control word of the first of the two messages in this dual message is set to be a normal BC control word
	//     - The BC control word of the second of the two messages in this dual message is set to designate "offline self test"
	//       (a "offline self test" message is a message that isn't really transmitted to the bus, but rather only internally in loopback mode)
	//   - Later on, when the user calls the appropriate functions in request to transmit high/low asynchronous messages,
	//     this library creates a corresponding XQF command per asynchronous message.
	//   - When such a XQF command is finally executed by the BC device, this causes the following sequence:
	//     - The BC tries to transmit the first message, and if the transmission successfully completes, a flip to the second message takes place
	//     - When this second message finally reaches execution later on, it isn't really transmitted (only in loopback mode),
	//       so that Tx fails, and another flip (back to the first message) never occurs, so no further actual transmission is performed by the BC with this dual message

	/// Create a dual message in which both constituent sub messages contain the described message.
	swResult = sitalBc_Message_CreateBcToRt (swDevice, swMessageId, swDataBlockId, wReceiverRt, wReceiverRtSubaddress, wWordCount, wGapTime, (dwOptions | sitalBcMessageOption_DUAL_MESSAGE));
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Change the BC control word of the second message in the just created dual message to designate "offline self test".
	HostMessageStructure* hmspMessage; // A pointer to a host message structure.
	hmspMessage = &(dsspDeviceState->bsBcState.hmsaMessage[swMessageId]);
	U16BIT wOfflineSelfTest; // An "offline self test" BC control word.
	wOfflineSelfTest = (sitalBcControlWord_BUS_A | sitalBcControlWord_LOOPBACK_TEST_PERFORMED);
	U32BIT dwAddressOfOfflineSelfTestMessage; // The address of the [BC control word of the] second message in our dual message.
	dwAddressOfOfflineSelfTestMessage = (hmspMessage->dwAddress + bcMemoryObjectSize_LARGE_MESSAGE + bcMessageBlock_OFFSET_OF_BC_CONTROL_WORD);
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, dwAddressOfOfflineSelfTestMessage, sitalDeviceMemorySection_Ram, 1U, &wOfflineSelfTest);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Change the command field of the second message in the just created dual message to designate "skip message".
	// (See an explanation in the documentation for function sitalBc_AsynchronousMessage_SendAtHighPriority.)
	U16BIT wSkipMessage; // A "skip message" message command word.
	wSkipMessage = (U16BIT)bcMessageBlock_Command1_SKIP_MESSAGE;
	U32BIT dwCommandAddressOfSkippedMessage; // The address of the command word of the second message in our dual message.
	dwCommandAddressOfSkippedMessage = (hmspMessage->dwAddress + bcMemoryObjectSize_LARGE_MESSAGE + bcMessageBlock_OFFSET_OF_COMMAND_1);
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, dwCommandAddressOfSkippedMessage, sitalDeviceMemorySection_Ram, 1U, &wSkipMessage);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Flag the new message as asynchronous.
	hmspMessage->bIsAsynchronousMessage = TRUE;
	hmspMessage->bIsAssignedForLowPriorityAsynchronousTx = FALSE;
	hmspMessage->bIsAnAlreadyTransmittedAsynchronousMessage = FALSE;
	hmspMessage->bIsAnAlreadyRecordedAsynchronousMessage = FALSE;

	/// Update the count of asynchronous messages.
	dsspDeviceState->bsBcState.wAsynchronousMessagesCount++;

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Create for given BC device an asynchronous message of type RT-to-BC.
///
/// Note:
/// - An asynchronous message is asynchronously transmitted at low priority in result of calling function sitalBc_AsynchronousMessage_SendAtLowPriority.
/// - An asynchronous message is asynchronously transmitted at high priority in result of calling function sitalBc_AsynchronousMessage_SendAtHighPriority.
/// - Unlike a normal message, an asynchronous message may not be transmitted by user-defined commands;
///   This is prohibited by function sitalBc_Command_Create.
///
/// Equivalent DDC definition: aceBCAsyncMsgCreateRTtoBC
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swMessageId (in)	A unique ID designating a message (0-(sitalBcCounter_MESSAGES-1))
/// @param swDataBlockId (in)	A unique ID designating a data block (0-(sitalBcCounter_DATA_BLOCKS-1))
/// @param wTransmitterRt (in)	Transmitter RT (sitalRtAddress_0-sitalRtAddress_31)
/// @param wTransmitterRtSubaddress (in)	Transmitter RT's subaddress (sitalRtSubaddress_1-sitalRtSubaddress_30)
/// @param wWordCount (in)	Word count (1-32)
/// @param wGapTime (in)	Gap time (in units of 1us) between the beginning of the message to the beginning of the following message (>=0)
/// @param dwOptions (in)	Message options (An or-ed combination of sitalBcControlWord_* and sitalBcMessageOption_*)
/// @param wapBuffer (in)	A pointer to an array of data words to be copied into the new data block
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_AsynchronousMessage_CreateRtToBc (	S16BIT swDevice,
														S16BIT swMessageId,
														S16BIT swDataBlockId,
														U16BIT wTransmitterRt,
														U16BIT wTransmitterRtSubaddress,
														U16BIT wWordCount,
														U16BIT wGapTime,
														U32BIT dwOptions,
														U16BIT* wapBuffer)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (0U == (sitalBcSetupOption_ASYNCHRONOUS_BOTH_PRIORITY_MODES & dsspDeviceState->bsBcState.dwOptions))
	{
		return sitalReturnCode_SUITABLE_ASYNCHRONOUS_MODE_UNDEFINED;
	}

	if (sitalBcMaximum_ASYNCHRONOUS_MESSAGES <= dsspDeviceState->bsBcState.wAsynchronousMessagesCount)
	{
		return sitalReturnCode_ASYNCHRONOUS_MESSAGE_ERROR;
	}

	/// Create a new data block of double size to be used by the newly created asynchronous message.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalBc_DataBlock_Create (swDevice, swDataBlockId, sitalBcDataBlockSizeOption_DOUBLE, wapBuffer, bcMemoryObjectSize_DOUBLE_DATA_BLOCK);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	// A basic demand with both high & low asynchronous messages is that they should be transmitted only once.
	// - The technique used by this library achieve this is as follows:
	//   - Each asynchronous message is created by this function (see right below) as a dual message:
	//     - Both messages in this dual message are simply the message that the user has defined
	//     - The BC control word of the first of the two messages in this dual message is set to be a normal BC control word
	//     - The BC control word of the second of the two messages in this dual message is set to designate "offline self test"
	//       (a "offline self test" message is a message that isn't really transmitted to the bus, but rather only internally in loopback mode)
	//   - Later on, when the user calls the appropriate functions in request to transmit high/low asynchronous messages,
	//     this library creates a corresponding XQF command per asynchronous message.
	//   - When such a XQF command is finally executed by the BC device, this causes the following sequence:
	//     - The BC tries to transmit the first message, and if the transmission successfully completes, a flip to the second message takes place
	//     - When this second message finally reaches execution later on, it isn't really transmitted (only in loopback mode),
	//       so that Tx fails, and another flip (back to the first message) never occurs, so no further actual transmission is performed by the BC with this dual message

	/// Create a dual message in which both constituent sub messages contain the described message.
	swResult = sitalBc_Message_CreateRtToBc (swDevice, swMessageId, swDataBlockId, wTransmitterRt, wTransmitterRtSubaddress, wWordCount, wGapTime, (dwOptions | sitalBcMessageOption_DUAL_MESSAGE));
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Change the BC control word of the second message in the just created dual message to designate "offline self test".
	HostMessageStructure* hmspMessage; // A pointer to a host message structure.
	hmspMessage = &(dsspDeviceState->bsBcState.hmsaMessage[swMessageId]);
	U16BIT wOfflineSelfTest; // An "offline self test" BC control word.
	wOfflineSelfTest = (sitalBcControlWord_BUS_A | sitalBcControlWord_LOOPBACK_TEST_PERFORMED);
	U32BIT dwAddressOfOfflineSelfTestMessage; // The address of the [BC control word of the] second message in our dual message.
	dwAddressOfOfflineSelfTestMessage = (hmspMessage->dwAddress + bcMemoryObjectSize_LARGE_MESSAGE + bcMessageBlock_OFFSET_OF_BC_CONTROL_WORD);
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, dwAddressOfOfflineSelfTestMessage, sitalDeviceMemorySection_Ram, 1U, &wOfflineSelfTest);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Change the command field of the second message in the just created dual message to designate "skip message".
	// (See an explanation in the documentation for function sitalBc_AsynchronousMessage_SendAtHighPriority.)
	U16BIT wSkipMessage; // A "skip message" message command word.
	wSkipMessage = (U16BIT)bcMessageBlock_Command1_SKIP_MESSAGE;
	U32BIT dwCommandAddressOfSkippedMessage; // The address of the command word of the second message in our dual message.
	dwCommandAddressOfSkippedMessage = (hmspMessage->dwAddress + bcMemoryObjectSize_LARGE_MESSAGE + bcMessageBlock_OFFSET_OF_COMMAND_1);
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, dwCommandAddressOfSkippedMessage, sitalDeviceMemorySection_Ram, 1U, &wSkipMessage);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Flag the new message as asynchronous.
	hmspMessage->bIsAsynchronousMessage = TRUE;
	hmspMessage->bIsAssignedForLowPriorityAsynchronousTx = FALSE;
	hmspMessage->bIsAnAlreadyTransmittedAsynchronousMessage = FALSE;
	hmspMessage->bIsAnAlreadyRecordedAsynchronousMessage = FALSE;

	/// Update the count of asynchronous messages.
	dsspDeviceState->bsBcState.wAsynchronousMessagesCount++;

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Create for given BC device an asynchronous message of type RT-to-RT.
///
/// Note:
/// - An asynchronous message is asynchronously transmitted at low priority in result of calling function sitalBc_AsynchronousMessage_SendAtLowPriority.
/// - An asynchronous message is asynchronously transmitted at high priority in result of calling function sitalBc_AsynchronousMessage_SendAtHighPriority.
/// - Unlike a normal message, an asynchronous message may not be transmitted by user-defined commands;
///   This is prohibited by function sitalBc_Command_Create.
///
/// Equivalent DDC definition: aceBCAsyncMsgCreateRTtoRT
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swMessageId (in)	A unique ID designating a message (0-(sitalBcCounter_MESSAGES-1))
/// @param swDataBlockId (in)	A unique ID designating a data block (0-(sitalBcCounter_DATA_BLOCKS-1))
/// @param wReceiverRt (in)	Receiver RT (sitalRtAddress_0-sitalRtAddress_31)
/// @param wReceiverRtSubaddress (in)	Receiver RT's subaddress (sitalRtSubaddress_1-sitalRtSubaddress_30)
/// @param wWordCount (in)	Word count (1-32)
/// @param wTransmitterRt (in)	Transmitter RT (sitalRtAddress_0-sitalRtAddress_31)
/// @param wTransmitterRtSubaddress (in)	Transmitter RT's subaddress (sitalRtSubaddress_1-sitalRtSubaddress_30)
/// @param wGapTime (in)	Gap time (in units of 1us) between the beginning of the message to the beginning of the following message (>=0)
/// @param dwOptions (in)	Message options (An or-ed combination of sitalBcControlWord_* and sitalBcMessageOption_*)
/// @param wapBuffer (in)	A pointer to an array of data words to be copied into the new data block
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_AsynchronousMessage_CreateRtToRt (	S16BIT swDevice,
														S16BIT swMessageId,
														S16BIT swDataBlockId,
														U16BIT wReceiverRt,
														U16BIT wReceiverRtSubaddress,
														U16BIT wWordCount,
														U16BIT wTransmitterRt,
														U16BIT wTransmitterRtSubaddress,
														U16BIT wGapTime,
														U32BIT dwOptions,
														U16BIT* wapBuffer)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (0U == (sitalBcSetupOption_ASYNCHRONOUS_BOTH_PRIORITY_MODES & dsspDeviceState->bsBcState.dwOptions))
	{
		return sitalReturnCode_SUITABLE_ASYNCHRONOUS_MODE_UNDEFINED;
	}

	if (sitalBcMaximum_ASYNCHRONOUS_MESSAGES <= dsspDeviceState->bsBcState.wAsynchronousMessagesCount)
	{
		return sitalReturnCode_ASYNCHRONOUS_MESSAGE_ERROR;
	}

	/// Create a new data block of double size to be used by the newly created asynchronous message.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalBc_DataBlock_Create (swDevice, swDataBlockId, sitalBcDataBlockSizeOption_DOUBLE, wapBuffer, bcMemoryObjectSize_DOUBLE_DATA_BLOCK);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	// A basic demand with both high & low asynchronous messages is that they should be transmitted only once.
	// - The technique used by this library achieve this is as follows:
	//   - Each asynchronous message is created by this function (see right below) as a dual message:
	//     - Both messages in this dual message are simply the message that the user has defined
	//     - The BC control word of the first of the two messages in this dual message is set to be a normal BC control word
	//     - The BC control word of the second of the two messages in this dual message is set to designate "offline self test"
	//       (a "offline self test" message is a message that isn't really transmitted to the bus, but rather only internally in loopback mode)
	//   - Later on, when the user calls the appropriate functions in request to transmit high/low asynchronous messages,
	//     this library creates a corresponding XQF command per asynchronous message.
	//   - When such a XQF command is finally executed by the BC device, this causes the following sequence:
	//     - The BC tries to transmit the first message, and if the transmission successfully completes, a flip to the second message takes place
	//     - When this second message finally reaches execution later on, it isn't really transmitted (only in loopback mode),
	//       so that Tx fails, and another flip (back to the first message) never occurs, so no further actual transmission is performed by the BC with this dual message

	/// Create a dual message in which both constituent sub messages contain the described message.
	swResult = sitalBc_Message_CreateRtToRt (swDevice, swMessageId, swDataBlockId, wReceiverRt, wReceiverRtSubaddress, wWordCount, wTransmitterRt, wTransmitterRtSubaddress, wGapTime, (dwOptions | sitalBcMessageOption_DUAL_MESSAGE));
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Change the BC control word of the second message in the just created dual message to designate "offline self test".
	HostMessageStructure* hmspMessage; // A pointer to a host message structure.
	hmspMessage = &(dsspDeviceState->bsBcState.hmsaMessage[swMessageId]);
	U16BIT wOfflineSelfTest; // An "offline self test" BC control word.
	wOfflineSelfTest = (sitalBcControlWord_BUS_A | sitalBcControlWord_LOOPBACK_TEST_PERFORMED);
	U32BIT dwAddressOfOfflineSelfTestMessage; // The address of the [BC control word of the] second message in our dual message.
	dwAddressOfOfflineSelfTestMessage = (hmspMessage->dwAddress + bcMemoryObjectSize_LARGE_MESSAGE + bcMessageBlock_OFFSET_OF_BC_CONTROL_WORD);
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, dwAddressOfOfflineSelfTestMessage, sitalDeviceMemorySection_Ram, 1U, &wOfflineSelfTest);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Change the command field of the second message in the just created dual message to designate "skip message".
	// (See an explanation in the documentation for function sitalBc_AsynchronousMessage_SendAtHighPriority.)
	U16BIT wSkipMessage; // A "skip message" message command word.
	wSkipMessage = (U16BIT)bcMessageBlock_Command1_SKIP_MESSAGE;
	U32BIT dwCommandAddressOfSkippedMessage; // The address of the command word of the second message in our dual message.
	dwCommandAddressOfSkippedMessage = (hmspMessage->dwAddress + bcMemoryObjectSize_LARGE_MESSAGE + bcMessageBlock_OFFSET_OF_COMMAND_1);
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, dwCommandAddressOfSkippedMessage, sitalDeviceMemorySection_Ram, 1U, &wSkipMessage);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Flag the new message as asynchronous.
	hmspMessage->bIsAsynchronousMessage = TRUE;
	hmspMessage->bIsAssignedForLowPriorityAsynchronousTx = FALSE;
	hmspMessage->bIsAnAlreadyTransmittedAsynchronousMessage = FALSE;
	hmspMessage->bIsAnAlreadyRecordedAsynchronousMessage = FALSE;

	/// Update the count of asynchronous messages.
	dsspDeviceState->bsBcState.wAsynchronousMessagesCount++;

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Create for given BC device an asynchronous message of type BC-to-RT-Mode or RT-to-BC-Mode, depending on given RT device-related message direction (sitalMessageDirection_RX or sitalMessageDirection_TX, respectively).
///
/// Note:
/// - An asynchronous message is asynchronously transmitted at low priority in result of calling function sitalBc_AsynchronousMessage_SendAtLowPriority.
/// - An asynchronous message is asynchronously transmitted at high priority in result of calling function sitalBc_AsynchronousMessage_SendAtHighPriority.
/// - Unlike a normal message, an asynchronous message may not be transmitted by user-defined commands;
///   This is prohibited by function sitalBc_Command_Create.
///
/// Equivalent DDC definition: aceBCAsyncMsgCreateMode
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swMessageId (in)	A unique ID designating a message (0-(sitalBcCounter_MESSAGES-1))
/// @param swDataBlockId (in)	A unique ID designating a data block (0-(sitalBcCounter_DATA_BLOCKS-1))
/// @param wRt (in)	Receiver/transmitter RT (sitalRtAddress_0-sitalRtAddress_31)
/// @param wMessageDirection (in)	RT-related message direction (sitalMessageDirection_RX or sitalMessageDirection_TX)
/// @param wModeCommand (in)	Mode command (1-32)
/// @param wGapTime (in)	Gap time (in units of 1us) between the beginning of the message to the beginning of the following message (>=0)
/// @param dwOptions (in)	Message options (An or-ed combination of sitalBcControlWord_* and sitalBcMessageOption_*)
/// @param wapBuffer (in)	A pointer to an array of data words to be copied into the new data block
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_AsynchronousMessage_CreateBcToOrFromRtMode (	S16BIT swDevice,
																	S16BIT swMessageId,
																	S16BIT swDataBlockId,
																	U16BIT wRt,
																	U16BIT wMessageDirection,
																	U16BIT wModeCommand,
																	U16BIT wGapTime,
																	U32BIT dwOptions,
																	U16BIT* wapBuffer)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (0U == (sitalBcSetupOption_ASYNCHRONOUS_BOTH_PRIORITY_MODES & dsspDeviceState->bsBcState.dwOptions))
	{
		return sitalReturnCode_SUITABLE_ASYNCHRONOUS_MODE_UNDEFINED;
	}

	if (sitalBcMaximum_ASYNCHRONOUS_MESSAGES <= dsspDeviceState->bsBcState.wAsynchronousMessagesCount)
	{
		return sitalReturnCode_ASYNCHRONOUS_MESSAGE_ERROR;
	}

	/// Create a new data block of double size to be used by the newly created asynchronous message.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalBc_DataBlock_Create (swDevice, swDataBlockId, sitalBcDataBlockSizeOption_DOUBLE, wapBuffer, bcMemoryObjectSize_DOUBLE_DATA_BLOCK);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	// A basic demand with both high & low asynchronous messages is that they should be transmitted only once.
	// - The technique used by this library achieve this is as follows:
	//   - Each asynchronous message is created by this function (see right below) as a dual message:
	//     - Both messages in this dual message are simply the message that the user has defined
	//     - The BC control word of the first of the two messages in this dual message is set to be a normal BC control word
	//     - The BC control word of the second of the two messages in this dual message is set to designate "offline self test"
	//       (a "offline self test" message is a message that isn't really transmitted to the bus, but rather only internally in loopback mode)
	//   - Later on, when the user calls the appropriate functions in request to transmit high/low asynchronous messages,
	//     this library creates a corresponding XQF command per asynchronous message.
	//   - When such a XQF command is finally executed by the BC device, this causes the following sequence:
	//     - The BC tries to transmit the first message, and if the transmission successfully completes, a flip to the second message takes place
	//     - When this second message finally reaches execution later on, it isn't really transmitted (only in loopback mode),
	//       so that Tx fails, and another flip (back to the first message) never occurs, so no further actual transmission is performed by the BC with this dual message

	/// Create a dual message in which both constituent sub messages contain the described message.
	swResult = sitalBc_Message_CreateBcToOrFromRtMode (swDevice, swMessageId, swDataBlockId, wRt, wMessageDirection, wModeCommand, wGapTime, (dwOptions | sitalBcMessageOption_DUAL_MESSAGE));
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Change the BC control word of the second message in the just created dual message to designate "offline self test".
	HostMessageStructure* hmspMessage; // A pointer to a host message structure.
	hmspMessage = &(dsspDeviceState->bsBcState.hmsaMessage[swMessageId]);
	U16BIT wOfflineSelfTest; // An "offline self test" BC control word.
	wOfflineSelfTest = (sitalBcControlWord_BUS_A | sitalBcControlWord_LOOPBACK_TEST_PERFORMED);
	U32BIT dwAddressOfOfflineSelfTestMessage; // The address of the [BC control word of the] second message in our dual message.
	dwAddressOfOfflineSelfTestMessage = (hmspMessage->dwAddress + bcMemoryObjectSize_LARGE_MESSAGE + bcMessageBlock_OFFSET_OF_BC_CONTROL_WORD);
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, dwAddressOfOfflineSelfTestMessage, sitalDeviceMemorySection_Ram, 1U, &wOfflineSelfTest);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Change the command field of the second message in the just created dual message to designate "skip message".
	// (See an explanation in the documentation for function sitalBc_AsynchronousMessage_SendAtHighPriority.)
	U16BIT wSkipMessage; // A "skip message" message command word.
	wSkipMessage = (U16BIT)bcMessageBlock_Command1_SKIP_MESSAGE;
	U32BIT dwCommandAddressOfSkippedMessage; // The address of the command word of the second message in our dual message.
	dwCommandAddressOfSkippedMessage = (hmspMessage->dwAddress + bcMemoryObjectSize_LARGE_MESSAGE + bcMessageBlock_OFFSET_OF_COMMAND_1);
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, dwCommandAddressOfSkippedMessage, sitalDeviceMemorySection_Ram, 1U, &wSkipMessage);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Flag the new message as asynchronous.
	hmspMessage->bIsAsynchronousMessage = TRUE;
	hmspMessage->bIsAssignedForLowPriorityAsynchronousTx = FALSE;
	hmspMessage->bIsAnAlreadyTransmittedAsynchronousMessage = FALSE;
	hmspMessage->bIsAnAlreadyRecordedAsynchronousMessage = FALSE;

	/// Update the count of asynchronous messages.
	dsspDeviceState->bsBcState.wAsynchronousMessagesCount++;

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Create for given BC device an asynchronous message of type BC-to-Broadcast.
///
/// Note:
/// - An asynchronous message is asynchronously transmitted at low priority in result of calling function sitalBc_AsynchronousMessage_SendAtLowPriority.
/// - An asynchronous message is asynchronously transmitted at high priority in result of calling function sitalBc_AsynchronousMessage_SendAtHighPriority.
/// - Unlike a normal message, an asynchronous message may not be transmitted by user-defined commands;
///   This is prohibited by function sitalBc_Command_Create.
///
/// Equivalent DDC definition: aceBCAsyncMsgCreateBcst
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swMessageId (in)	A unique ID designating a message (0-(sitalBcCounter_MESSAGES-1))
/// @param swDataBlockId (in)	A unique ID designating a data block (0-(sitalBcCounter_DATA_BLOCKS-1))
/// @param wReceiverRtSubaddress (in)	Receiver RT's subaddress (sitalRtSubaddress_1-sitalRtSubaddress_30)
/// @param wWordCount (in)	Word count (1-32)
/// @param wGapTime (in)	Gap time (in units of 1us) between the beginning of the message to the beginning of the following message (>=0)
/// @param dwOptions (in)	Message options (An or-ed combination of sitalBcControlWord_* and sitalBcMessageOption_*)
/// @param wapBuffer (in)	A pointer to an array of data words to be copied into the new data block
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_AsynchronousMessage_CreateBcToBroadcast (	S16BIT swDevice,
																S16BIT swMessageId,
																S16BIT swDataBlockId,
																U16BIT wReceiverRtSubaddress,
																U16BIT wWordCount,
																U16BIT wGapTime,
																U32BIT dwOptions,
																U16BIT* wapBuffer)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (0U == (sitalBcSetupOption_ASYNCHRONOUS_BOTH_PRIORITY_MODES & dsspDeviceState->bsBcState.dwOptions))
	{
		return sitalReturnCode_SUITABLE_ASYNCHRONOUS_MODE_UNDEFINED;
	}

	if (sitalBcMaximum_ASYNCHRONOUS_MESSAGES <= dsspDeviceState->bsBcState.wAsynchronousMessagesCount)
	{
		return sitalReturnCode_ASYNCHRONOUS_MESSAGE_ERROR;
	}

	/// Create a new data block of double size to be used by the newly created asynchronous message.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalBc_DataBlock_Create (swDevice, swDataBlockId, sitalBcDataBlockSizeOption_DOUBLE, wapBuffer, bcMemoryObjectSize_DOUBLE_DATA_BLOCK);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	// A basic demand with both high & low asynchronous messages is that they should be transmitted only once.
	// - The technique used by this library achieve this is as follows:
	//   - Each asynchronous message is created by this function (see right below) as a dual message:
	//     - Both messages in this dual message are simply the message that the user has defined
	//     - The BC control word of the first of the two messages in this dual message is set to be a normal BC control word
	//     - The BC control word of the second of the two messages in this dual message is set to designate "offline self test"
	//       (a "offline self test" message is a message that isn't really transmitted to the bus, but rather only internally in loopback mode)
	//   - Later on, when the user calls the appropriate functions in request to transmit high/low asynchronous messages,
	//     this library creates a corresponding XQF command per asynchronous message.
	//   - When such a XQF command is finally executed by the BC device, this causes the following sequence:
	//     - The BC tries to transmit the first message, and if the transmission successfully completes, a flip to the second message takes place
	//     - When this second message finally reaches execution later on, it isn't really transmitted (only in loopback mode),
	//       so that Tx fails, and another flip (back to the first message) never occurs, so no further actual transmission is performed by the BC with this dual message

	/// Create a dual message in which both constituent sub messages contain the described message.
	swResult = sitalBc_Message_CreateBcToBroadcast (swDevice, swMessageId, swDataBlockId, wReceiverRtSubaddress, wWordCount, wGapTime, (dwOptions | sitalBcMessageOption_DUAL_MESSAGE));
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Change the BC control word of the second message in the just created dual message to designate "offline self test".
	HostMessageStructure* hmspMessage; // A pointer to a host message structure.
	hmspMessage = &(dsspDeviceState->bsBcState.hmsaMessage[swMessageId]);
	U16BIT wOfflineSelfTest; // An "offline self test" BC control word.
	wOfflineSelfTest = (sitalBcControlWord_BUS_A | sitalBcControlWord_LOOPBACK_TEST_PERFORMED);
	U32BIT dwAddressOfOfflineSelfTestMessage; // The address of the [BC control word of the] second message in our dual message.
	dwAddressOfOfflineSelfTestMessage = (hmspMessage->dwAddress + bcMemoryObjectSize_LARGE_MESSAGE + bcMessageBlock_OFFSET_OF_BC_CONTROL_WORD);
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, dwAddressOfOfflineSelfTestMessage, sitalDeviceMemorySection_Ram, 1U, &wOfflineSelfTest);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Change the command field of the second message in the just created dual message to designate "skip message".
	// (See an explanation in the documentation for function sitalBc_AsynchronousMessage_SendAtHighPriority.)
	U16BIT wSkipMessage; // A "skip message" message command word.
	wSkipMessage = (U16BIT)bcMessageBlock_Command1_SKIP_MESSAGE;
	U32BIT dwCommandAddressOfSkippedMessage; // The address of the command word of the second message in our dual message.
	dwCommandAddressOfSkippedMessage = (hmspMessage->dwAddress + bcMemoryObjectSize_LARGE_MESSAGE + bcMessageBlock_OFFSET_OF_COMMAND_1);
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, dwCommandAddressOfSkippedMessage, sitalDeviceMemorySection_Ram, 1U, &wSkipMessage);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Flag the new message as asynchronous.
	hmspMessage->bIsAsynchronousMessage = TRUE;
	hmspMessage->bIsAssignedForLowPriorityAsynchronousTx = FALSE;
	hmspMessage->bIsAnAlreadyTransmittedAsynchronousMessage = FALSE;
	hmspMessage->bIsAnAlreadyRecordedAsynchronousMessage = FALSE;

	/// Update the count of asynchronous messages.
	dsspDeviceState->bsBcState.wAsynchronousMessagesCount++;

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Create for given BC device an asynchronous message of type RT-to-Broadcast.
///
/// Note:
/// - An asynchronous message is asynchronously transmitted at low priority in result of calling function sitalBc_AsynchronousMessage_SendAtLowPriority.
/// - An asynchronous message is asynchronously transmitted at high priority in result of calling function sitalBc_AsynchronousMessage_SendAtHighPriority.
/// - Unlike a normal message, an asynchronous message may not be transmitted by user-defined commands;
///   This is prohibited by function sitalBc_Command_Create.
///
/// Equivalent DDC definition: aceBCAsyncMsgCreateBcstRTtoRT
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swMessageId (in)	A unique ID designating a message (0-(sitalBcCounter_MESSAGES-1))
/// @param swDataBlockId (in)	A unique ID designating a data block (0-(sitalBcCounter_DATA_BLOCKS-1))
/// @param wReceiverRtSubaddress (in)	Receiver RT's subaddress (sitalRtSubaddress_1-sitalRtSubaddress_30)
/// @param wWordCount (in)	Word count (1-32)
/// @param wTransmitterRt (in)	Transmitter RT (sitalRtAddress_0-sitalRtAddress_31)
/// @param wTransmitterRtSubaddress (in)	Transmitter RT's subaddress (sitalRtSubaddress_1-sitalRtSubaddress_30)
/// @param wGapTime (in)	Gap time (in units of 1us) between the beginning of the message to the beginning of the following message (>=0)
/// @param dwOptions (in)	Message options (An or-ed combination of sitalBcControlWord_* and sitalBcMessageOption_*)
/// @param wapBuffer (in)	A pointer to an array of data words to be copied into the new data block
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_AsynchronousMessage_CreateRtToBroadcast (	S16BIT swDevice,
																S16BIT swMessageId,
																S16BIT swDataBlockId,
																U16BIT wReceiverRtSubaddress,
																U16BIT wWordCount,
																U16BIT wTransmitterRt,
																U16BIT wTransmitterRtSubaddress,
																U16BIT wGapTime,
																U32BIT dwOptions,
																U16BIT* wapBuffer)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (0U == (sitalBcSetupOption_ASYNCHRONOUS_BOTH_PRIORITY_MODES & dsspDeviceState->bsBcState.dwOptions))
	{
		return sitalReturnCode_SUITABLE_ASYNCHRONOUS_MODE_UNDEFINED;
	}

	if (sitalBcMaximum_ASYNCHRONOUS_MESSAGES <= dsspDeviceState->bsBcState.wAsynchronousMessagesCount)
	{
		return sitalReturnCode_ASYNCHRONOUS_MESSAGE_ERROR;
	}

	/// Create a new data block of double size to be used by the newly created asynchronous message.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalBc_DataBlock_Create (swDevice, swDataBlockId, sitalBcDataBlockSizeOption_DOUBLE, wapBuffer, bcMemoryObjectSize_DOUBLE_DATA_BLOCK);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	// A basic demand with both high & low asynchronous messages is that they should be transmitted only once.
	// - The technique used by this library achieve this is as follows:
	//   - Each asynchronous message is created by this function (see right below) as a dual message:
	//     - Both messages in this dual message are simply the message that the user has defined
	//     - The BC control word of the first of the two messages in this dual message is set to be a normal BC control word
	//     - The BC control word of the second of the two messages in this dual message is set to designate "offline self test"
	//       (a "offline self test" message is a message that isn't really transmitted to the bus, but rather only internally in loopback mode)
	//   - Later on, when the user calls the appropriate functions in request to transmit high/low asynchronous messages,
	//     this library creates a corresponding XQF command per asynchronous message.
	//   - When such a XQF command is finally executed by the BC device, this causes the following sequence:
	//     - The BC tries to transmit the first message, and if the transmission successfully completes, a flip to the second message takes place
	//     - When this second message finally reaches execution later on, it isn't really transmitted (only in loopback mode),
	//       so that Tx fails, and another flip (back to the first message) never occurs, so no further actual transmission is performed by the BC with this dual message

	/// Create a dual message in which both constituent sub messages contain the described message.
	swResult = sitalBc_Message_CreateRtToBroadcast (swDevice, swMessageId, swDataBlockId, wReceiverRtSubaddress, wWordCount, wTransmitterRt, wTransmitterRtSubaddress, wGapTime, (dwOptions | sitalBcMessageOption_DUAL_MESSAGE));
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Change the BC control word of the second message in the just created dual message to designate "offline self test".
	HostMessageStructure* hmspMessage; // A pointer to a host message structure.
	hmspMessage = &(dsspDeviceState->bsBcState.hmsaMessage[swMessageId]);
	U16BIT wOfflineSelfTest; // An "offline self test" BC control word.
	wOfflineSelfTest = (sitalBcControlWord_BUS_A | sitalBcControlWord_LOOPBACK_TEST_PERFORMED);
	U32BIT dwAddressOfOfflineSelfTestMessage; // The address of the [BC control word of the] second message in our dual message.
	dwAddressOfOfflineSelfTestMessage = (hmspMessage->dwAddress + bcMemoryObjectSize_LARGE_MESSAGE + bcMessageBlock_OFFSET_OF_BC_CONTROL_WORD);
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, dwAddressOfOfflineSelfTestMessage, sitalDeviceMemorySection_Ram, 1U, &wOfflineSelfTest);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Change the command field of the second message in the just created dual message to designate "skip message".
	// (See an explanation in the documentation for function sitalBc_AsynchronousMessage_SendAtHighPriority.)
	U16BIT wSkipMessage; // A "skip message" message command word.
	wSkipMessage = (U16BIT)bcMessageBlock_Command1_SKIP_MESSAGE;
	U32BIT dwCommandAddressOfSkippedMessage; // The address of the command word of the second message in our dual message.
	dwCommandAddressOfSkippedMessage = (hmspMessage->dwAddress + bcMemoryObjectSize_LARGE_MESSAGE + bcMessageBlock_OFFSET_OF_COMMAND_1);
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, dwCommandAddressOfSkippedMessage, sitalDeviceMemorySection_Ram, 1U, &wSkipMessage);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Flag the new message as asynchronous.
	hmspMessage->bIsAsynchronousMessage = TRUE;
	hmspMessage->bIsAssignedForLowPriorityAsynchronousTx = FALSE;
	hmspMessage->bIsAnAlreadyTransmittedAsynchronousMessage = FALSE;
	hmspMessage->bIsAnAlreadyRecordedAsynchronousMessage = FALSE;

	/// Update the count of asynchronous messages.
	dsspDeviceState->bsBcState.wAsynchronousMessagesCount++;

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Create for given BC device an asynchronous message of type BC-to-Broadcast-Mode or Broadcast-to-BC-Mode, depending on given RT device-related message direction (sitalMessageDirection_RX or sitalMessageDirection_TX, respectively).
///
/// Note:
/// - An asynchronous message is asynchronously transmitted at low priority in result of calling function sitalBc_AsynchronousMessage_SendAtLowPriority.
/// - An asynchronous message is asynchronously transmitted at high priority in result of calling function sitalBc_AsynchronousMessage_SendAtHighPriority.
/// - Unlike a normal message, an asynchronous message may not be transmitted by user-defined commands;
///   This is prohibited by function sitalBc_Command_Create.
///
/// Equivalent DDC definition: aceBCAsyncMsgCreateBcstMode
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swMessageId (in)	A unique ID designating a message (0-(sitalBcCounter_MESSAGES-1))
/// @param swDataBlockId (in)	A unique ID designating a data block (0-(sitalBcCounter_DATA_BLOCKS-1))
/// @param wMessageDirection (in)	RT-related message direction (sitalMessageDirection_RX or sitalMessageDirection_TX)
/// @param wModeCommand (in)	Mode command (1-32)
/// @param wGapTime (in)	Gap time (in units of 1us) between the beginning of the message to the beginning of the following message (>=0)
/// @param dwOptions (in)	Message options (An or-ed combination of sitalBcControlWord_* and sitalBcMessageOption_*)
/// @param wapBuffer (in)	A pointer to an array of data words to be copied into the new data block
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_AsynchronousMessage_CreateBcToOrFromBroadcastMode (	S16BIT swDevice,
																			S16BIT swMessageId,
																			S16BIT swDataBlockId,
																			U16BIT wMessageDirection,
																			U16BIT wModeCommand,
																			U16BIT wGapTime,
																			U32BIT dwOptions,
																			U16BIT* wapBuffer)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (0U == (sitalBcSetupOption_ASYNCHRONOUS_BOTH_PRIORITY_MODES & dsspDeviceState->bsBcState.dwOptions))
	{
		return sitalReturnCode_SUITABLE_ASYNCHRONOUS_MODE_UNDEFINED;
	}

	if (sitalBcMaximum_ASYNCHRONOUS_MESSAGES <= dsspDeviceState->bsBcState.wAsynchronousMessagesCount)
	{
		return sitalReturnCode_ASYNCHRONOUS_MESSAGE_ERROR;
	}

	/// Create a new data block of double size to be used by the newly created asynchronous message.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalBc_DataBlock_Create (swDevice, swDataBlockId, sitalBcDataBlockSizeOption_DOUBLE, wapBuffer, bcMemoryObjectSize_DOUBLE_DATA_BLOCK);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	// A basic demand with both high & low asynchronous messages is that they should be transmitted only once.
	// - The technique used by this library achieve this is as follows:
	//   - Each asynchronous message is created by this function (see right below) as a dual message:
	//     - Both messages in this dual message are simply the message that the user has defined
	//     - The BC control word of the first of the two messages in this dual message is set to be a normal BC control word
	//     - The BC control word of the second of the two messages in this dual message is set to designate "offline self test"
	//       (a "offline self test" message is a message that isn't really transmitted to the bus, but rather only internally in loopback mode)
	//   - Later on, when the user calls the appropriate functions in request to transmit high/low asynchronous messages,
	//     this library creates a corresponding XQF command per asynchronous message.
	//   - When such a XQF command is finally executed by the BC device, this causes the following sequence:
	//     - The BC tries to transmit the first message, and if the transmission successfully completes, a flip to the second message takes place
	//     - When this second message finally reaches execution later on, it isn't really transmitted (only in loopback mode),
	//       so that Tx fails, and another flip (back to the first message) never occurs, so no further actual transmission is performed by the BC with this dual message

	/// Create a dual message in which both constituent sub messages contain the described message.
	swResult = sitalBc_Message_CreateBcToOrFromBroadcastMode (swDevice, swMessageId, swDataBlockId, wMessageDirection, wModeCommand, wGapTime, (dwOptions | sitalBcMessageOption_DUAL_MESSAGE));
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Change the BC control word of the second message in the just created dual message to designate "offline self test".
	HostMessageStructure* hmspMessage; // A pointer to a host message structure.
	hmspMessage = &(dsspDeviceState->bsBcState.hmsaMessage[swMessageId]);
	U16BIT wOfflineSelfTest; // An "offline self test" BC control word.
	wOfflineSelfTest = (sitalBcControlWord_BUS_A | sitalBcControlWord_LOOPBACK_TEST_PERFORMED);
	U32BIT dwAddressOfOfflineSelfTestMessage; // The address of the [BC control word of the] second message in our dual message.
	dwAddressOfOfflineSelfTestMessage = (hmspMessage->dwAddress + bcMemoryObjectSize_LARGE_MESSAGE + bcMessageBlock_OFFSET_OF_BC_CONTROL_WORD);
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, dwAddressOfOfflineSelfTestMessage, sitalDeviceMemorySection_Ram, 1U, &wOfflineSelfTest);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Change the command field of the second message in the just created dual message to designate "skip message".
	// (See an explanation in the documentation for function sitalBc_AsynchronousMessage_SendAtHighPriority.)
	U16BIT wSkipMessage; // A "skip message" message command word.
	wSkipMessage = (U16BIT)bcMessageBlock_Command1_SKIP_MESSAGE;
	U32BIT dwCommandAddressOfSkippedMessage; // The address of the command word of the second message in our dual message.
	dwCommandAddressOfSkippedMessage = (hmspMessage->dwAddress + bcMemoryObjectSize_LARGE_MESSAGE + bcMessageBlock_OFFSET_OF_COMMAND_1);
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, dwCommandAddressOfSkippedMessage, sitalDeviceMemorySection_Ram, 1U, &wSkipMessage);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Flag the new message as asynchronous.
	hmspMessage->bIsAsynchronousMessage = TRUE;
	hmspMessage->bIsAssignedForLowPriorityAsynchronousTx = FALSE;
	hmspMessage->bIsAnAlreadyTransmittedAsynchronousMessage = FALSE;
	hmspMessage->bIsAnAlreadyRecordedAsynchronousMessage = FALSE;

	/// Update the count of asynchronous messages.
	dsspDeviceState->bsBcState.wAsynchronousMessagesCount++;

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Fix for given BC device the subroutine that asynchronously transmits messages at low priority, so that it will transmit all the currently defined
/// asynchronous messages.
/// Then raise the proper general purpose flag, GPF-7, so that this subroutine will be actually called along the currently ongoing frame run.
///
/// Note:
/// - For an asynchronous message to be transmitted by this function it must be a dual message in which the second message's message block command
///   field is 0xFFFFU; This is the kind of messages automatically created by the sitalBc_AsynchronousMessage_Create* functions.
///   This kind of messages, once successfully transmitted using a XQF opcode that's conditioned with "good message" (which is the command used
///   by the high priority asynchronous message Tx subroutine), makes the device flip the message address to this dual message's second message,
///   where the 0xFFFFU makes the device avoid further Tx trials and message flips.
/// - Once an asynchronous message is defined, it may be transmitted at high priority again and again as many times as the user requires, but it won't
///   be transmitted more than once at low priority. Moreover, if an asynchronous message has already been transmitted at high priority, it won't be
///   retransmitted at low priority even once. In order to force its retransmission in such a case, the message must be deleted and recreated.
/// - Calling the subroutines that perform the high & low priority asynchronous message Tx (including their initial stubs) is conditioned by GPF-6 &
///   GPF-7, respectively, being on. In order to maintain this mechanism intact, user applications should never use GPF-6 and GPF-7.
/// - The count of asynchronous messages that still weren't assigned for Tx, being set for the variable pointed by wpRemainingMessageCount, is actually
///   always zero. Accordingly, the returned count of asynchronous messages assigned for Tx in the new low priority asynchronous message Tx subroutine
///   is actually the total number of currently defined asynchronous messages that still weren't asynchronously transmitted at either high or low
///   priority. In contrary to the corresponding library of DDC, all those asynchronous message that weren't yet transmitted are set for Tx by the
///   low priority asynchronous message Tx microcode subroutine that's built by this function, never mind how much free passive time is available at the end of
///   the currently executed minor frames. This policy is possible due to the fact that this library leaves the decision of whether to transmit more
///   low priority asynchronous messages or not to the device itself, which will continue Tx only as long as there's enough time for more messages,
///   and only with messages small enough to fit the time left.
/// - This function does not really require the time factor parameter, which isn't removed only in order to stay compatible with DDC.
/// - This function does not wait for the low priority asynchronous message Tx to complete;
///   Instead, the user may re-call this function again and again, possibly with a small delay in between the calls, until informed that there are no
///   more low priority asynchronous messages to transmit.
/// - The low priority asynchronous message Tx subroutine is made of a series of command quartets, one for each of the asynchronous messages that
///   weren't transmitted yet, where each of these quartets contains the following commands:
///   - A command to compare the frame timer to 2 ms.
///   - A jump command to-the-end-of-this-subroutine if-less-than
///   - An execute-and-flip command of-the-next-asynchronous-message if-good-message
///   - A command to call the high priority asynchronous message Tx subroutine conditioned by GPF-6 being raised.
///   Finally, a return command is added, in order to return control to the currently executing minor frame.
/// - The transmission of low priority asynchronous messages is supported by this library only while running a major frame that forces a common frame time
///   over all its minor frames. This enables it to concentrate the transmission commands for all the asynchronous messages in a single common routine and
///   this way save device memory space. What's more, this policy leaves the decision of which asynchronous messages to transmit at the end of each minor
///   frame for the device, which may then dynamically and accurately decide about it, taking in account the actual time it took to transmit the messages
///   of each frame in the current occasion.
///
///		NB - 9.1.2017 - 
///		Added a non-DDC compatible API enhancement which signals the hardware to transmit the low priority async messages only once, on good and bad messages
///
/// Equivalent DDC definition: aceBCSendAsyncMsgLP
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wpRemainingMessageCount (out)	A pointer to a variable in which the count of asynchronous messages that still weren't assigned for Tx is returned
/// @param wTimeFactor (in) A time factor (Unused)
/// @return Positive integer	The number of asynchronous messages assigned for Tx in the new low priority asynchronous message Tx subroutine
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_AsynchronousMessage_SendAtLowPriority_ExecuteOnce (S16BIT swDevice, U16BIT* wpRemainingMessageCount, U16BIT wTimeFactor)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_RUN != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (sitalBcSetupOption_ASYNCHRONOUS_LOW_PRIORITY_MODE != (sitalBcSetupOption_ASYNCHRONOUS_LOW_PRIORITY_MODE & dsspDeviceState->bsBcState.dwOptions))
	{
		return sitalReturnCode_SUITABLE_ASYNCHRONOUS_MODE_UNDEFINED;
	}

	// This function may be called only along frame run.
	// The following condition must therefore fulfill.
	Assert_NonOsDependent(((HostFrameStructure*)NULL) != dsspDeviceState->bsBcState.hfspRunningMajorFrame);

	if (0U == dsspDeviceState->bsBcState.hfspRunningMajorFrame->wFrameTime)
	{
		return sitalReturnCode_NO_FRAME_TIME_SET_FOR_MAJOR_FRAME;
	}

	/// Lower GPF-7 to prevent given device from entering the low priority asynchronous message Tx subroutine along its update.
	// Note that GPF-7 is used to protect from a situation in which the subroutine is updated at device memory at the same time when the device is
	// executing it. This protection is required in:
	// - The cases where the current subroutine is rewritten at the same place i.e., not written at a newly allocated space of device memory).
	// - The process of checking the existing low priority asynchronous message Tx subroutine in order to find out which messages haven't already been
	//   transmitted. These messages will be then assigned for Tx in the newly created subroutine, so it is required that once their Tx state is read,
	//   the device won't [re]try to transmit them anymore.
	S16BIT swResult; // Result of operation or function call.
	swResult = bc_Gpf_SetState (swDevice, sitalBcConditionCode_GPF7, sitalBcGpfEffect_CLEAR);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Wait enough time for the instruction pointer register to indicate that given device isn't currently executing the old subroutine.
	Sleep_NonOsDependent(1U + (dsspDeviceState->bsBcState.wTotalTxTimeOfLowAsynchronousTxSubroutine / 1000U));
	U16BIT wRegisterValue; // The current value of a target register, or the value to set for a target register.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, sitalRegisterAddress_BC_INSTRUCTION_LIST_POINTER, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	if ((dsspDeviceState->bsBcState.dwAddressOfHighAsynchronousTxSubroutine <= wRegisterValue) && (dsspDeviceState->bsBcState.dwLastAddressOfHighAsynchronousTxSubroutine >= wRegisterValue))
	{
		return sitalReturnCode_ASYNCHRONOUS_SUBROUTINE_BUSY;
	}

	if (((U16BIT*)NULL) == wpRemainingMessageCount)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Set the count of asynchronous messages that still weren't assigned for Tx.
	// (See remark above in the documentation for this function.)
	(*wpRemainingMessageCount) = 0U;

	/// Loop over all the messages of given device:
	///		With each currently defined asynchronous message which was already assigned for Tx in the low priority asynchronous message Tx subroutine and whose Tx wasn't yet identified:
	///			Read the address parameter of the corresponding XQF command in the low priority asynchronous message Tx subroutine.
	///			If it shows that a flip already occurred (i.e., message has been successfully transmitted):
	///				Flag this message as asynchronously transmitted.
	///		Flag the message as one that was not yet assigned for Tx in the low priority asynchronous message Tx subroutine.
	// As the existing low priority asynchronous message Tx subroutine is now canceled, no message is considered assigned for Tx until a new subroutine is created.
	HostMessageStructure* hmspMessage; // A pointer to a host message structure.
	hmspMessage = dsspDeviceState->bsBcState.hmsaMessage;
	U16BIT wMessageId; // A message ID.
	for (wMessageId=0U; wMessageId<sitalBcCounter_MESSAGES; wMessageId++, hmspMessage++)
	{
		if	(
				(FALSE == hmspMessage->bIsFreeForUse)
				&&
				(TRUE == hmspMessage->bIsAsynchronousMessage)
				&&
				(TRUE == hmspMessage->bIsAssignedForLowPriorityAsynchronousTx)
				&&
				(FALSE == hmspMessage->bIsAnAlreadyTransmittedAsynchronousMessage)
			)
		{
			U16BIT wCurrentAddressInTxCommand; // The address stored in device memory for the XQF command of the current message in the low priority asynchronous message Tx subroutine.
			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, hmspMessage->dwAddress + bcMessageBlock_OFFSET_OF_BLOCK_STATUS /*hmspMessage->dwAddressOfTransmitterCommandParameter*/, sitalDeviceMemorySection_Ram, 1U, &wCurrentAddressInTxCommand);
			if (sitalReturnCode_SUCCESS != swResult)
			{
				return swResult;
			}
			if ((wCurrentAddressInTxCommand & 0x8000) == 0x8000)
			{
				hmspMessage->bIsAnAlreadyTransmittedAsynchronousMessage = TRUE;
			}
		}
		hmspMessage->bIsAssignedForLowPriorityAsynchronousTx = FALSE;
	}

	/// Loop over all the messages of given device:
	///		If current message is a currently defined not-yet-transmitted asynchronous dual message whose command1 is set to "skip message":
	///			Count this message in the total number of messages that are assigned for inclusion in the new low priority asynchronous message Tx subroutine.
	///			Assign this message for inclusion in the low priority asynchronous message Tx subroutine.
	///			Add the Tx time of this message to the overall message Tx time of the newly created low priority asynchronous message Tx subroutine.
	///		Else:
	///			Sign this message as not assigned for inclusion in the low priority asynchronous message Tx subroutine.
	U16BIT wCountOfLowPriorityMessagesAssignedForTx; // The number of asynchronous messages assigned for Tx in the new low priority asynchronous message Tx subroutine.
	wCountOfLowPriorityMessagesAssignedForTx = 0U;
	dsspDeviceState->bsBcState.wTotalTxTimeOfLowAsynchronousTxSubroutine = 0U;
	hmspMessage = dsspDeviceState->bsBcState.hmsaMessage;
	for (wMessageId=0; wMessageId<sitalBcCounter_MESSAGES; wMessageId++, hmspMessage++)
	{
		if ((FALSE == hmspMessage->bIsFreeForUse) && (TRUE == hmspMessage->bIsAsynchronousMessage) && (bcMemoryObjectSize_DUAL_MESSAGE == hmspMessage->wActualSize) && (FALSE == hmspMessage->bIsAnAlreadyTransmittedAsynchronousMessage))
		{
			U32BIT dwCommandAddressOfSkippedMessage; // The address of the command word of the second message in our dual message.
			dwCommandAddressOfSkippedMessage = (hmspMessage->dwAddress + bcMemoryObjectSize_LARGE_MESSAGE + bcMessageBlock_OFFSET_OF_COMMAND_1);
			U16BIT wCommandOfSecondMessage; // The command word of the second message in given dual message, which must be a "skip message" message command (see the documentation for this function).
			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, dwCommandAddressOfSkippedMessage, sitalDeviceMemorySection_Ram, 1U, &wCommandOfSecondMessage);
			if ((sitalReturnCode_SUCCESS == swResult) && (bcMessageBlock_Command1_SKIP_MESSAGE == wCommandOfSecondMessage))
			{
				wCountOfLowPriorityMessagesAssignedForTx++;
				hmspMessage->bIsAssignedForLowPriorityAsynchronousTx = TRUE;
				dsspDeviceState->bsBcState.wTotalTxTimeOfLowAsynchronousTxSubroutine += hmspMessage->wMessageTxTime;
			}
		}
	}

	// 9.1.2017 - NB - 
	// update the wpRemainingMessageCount with the number of messages in the loop below.
	(*wpRemainingMessageCount) = wCountOfLowPriorityMessagesAssignedForTx;

	if (0U == wCountOfLowPriorityMessagesAssignedForTx)
	{
		return sitalReturnCode_ASYNCHRONOUS_LIST_IS_EMPTY;
	}

	/// Calculate the size (in words) of the new low priority asynchronous message Tx subroutine.
	/// If the size of the device memory currently allocated for the low priority asynchronous message Tx subroutine isn't enough for the new subroutine:
	///		Allocate a new suitable region in the bottom section of device memory.
	///		Record the new region's starting address, ending address, and size.
	///		Loop over all the commands in the currently executed major frame that call the low priority asynchronous messages Tx subroutine:
	///			Update the called address to point the device memory region that was just allocated.
	/// Else:
	///		Record the new region's ending address.
	U16BIT wSizeOfNewLowAsynchronousTxSubroutine; // The size (in words) of the new low priority asynchronous message Tx subroutine.
	wSizeOfNewLowAsynchronousTxSubroutine = (((wCountOfLowPriorityMessagesAssignedForTx * (U16BIT)asynchronousMessaging_COMMAND_COUNT_PER_LOW_PRIORITY_MESSAGE) + (U16BIT)1U) * (U16BIT)bcMemoryObjectSize_COMMAND);
	if (dsspDeviceState->bsBcState.wSizeOfLowAsynchronousTxSubroutine < wSizeOfNewLowAsynchronousTxSubroutine)
	{
		U32BIT dwAllocationSize; // The size (in words) of the device memory allocation.
		dwAllocationSize = wSizeOfNewLowAsynchronousTxSubroutine;
		BOOLEAN bIsAllocationSuccessfullyAccomplished; // A flag that says whether the allocation actually succeeded.
		U32BIT dwAllocationBaseAddress; // The address in device memory where a suitable segment of memory has been allocated for the newly created object.
		swResult = Device_Memory_BottomSection_AllocateContinuity (&(dsspDeviceState->hdmmsDeviceMemoryMap), &dwAllocationSize, 5, &bIsAllocationSuccessfullyAccomplished, &dwAllocationBaseAddress);
		if ( (sitalReturnCode_SUCCESS != swResult) || (FALSE == bIsAllocationSuccessfullyAccomplished) )
		{
			return sitalReturnCode_ALLOCATION_FAIL;
		}

		dsspDeviceState->bsBcState.dwAddressOfLowAsynchronousTxSubroutine = dwAllocationBaseAddress;
		dsspDeviceState->bsBcState.dwLastAddressOfLowAsynchronousTxSubroutine = (dwAllocationBaseAddress + (U32BIT)wSizeOfNewLowAsynchronousTxSubroutine - (U32BIT)1U);
		dsspDeviceState->bsBcState.wSizeOfLowAsynchronousTxSubroutine = (U16BIT)dwAllocationSize;

		U32BIT* dwpCurrentLowAsynchronousTxSubroutineCallAddress; // A pointer to the current entry in the array that stores the device memory addresses where the address of the low priority asynchronous messages Tx subroutine is recorded as parameter of call commands.
		dwpCurrentLowAsynchronousTxSubroutineCallAddress = dsspDeviceState->bsBcState.dwaLowAsynchronousTxSubroutineCallAddress;
		U16BIT wIoContents; // The variable into which the contents of a device word is read, or the variable whose contents are written to device.
		wIoContents = (U16BIT)dsspDeviceState->bsBcState.dwAddressOfLowAsynchronousTxSubroutine;
		for (U16BIT iNestedMinorFrameIndex=0U; iNestedMinorFrameIndex<dsspDeviceState->bsBcState.wNestedMinorFrameCount; iNestedMinorFrameIndex++, dwpCurrentLowAsynchronousTxSubroutineCallAddress++)
		{
			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, (*dwpCurrentLowAsynchronousTxSubroutineCallAddress), sitalDeviceMemorySection_Ram, 1U, &wIoContents);
			if (sitalReturnCode_SUCCESS != swResult)
			{
				return swResult;
			}
		}

		// Note that the region of device memory where the old low priority asynchronous messages Tx subroutine has been written isn't freed: there's no way to free a particular allocation in the bottom section of device memory.
	}
	else
	{
		// There's no need to allocate new memory: the region of device memory where the current low priority asynchronous messages Tx subroutine is written is enough to contain the new one.
		dsspDeviceState->bsBcState.dwLastAddressOfLowAsynchronousTxSubroutine = (dsspDeviceState->bsBcState.dwAddressOfLowAsynchronousTxSubroutine + wSizeOfNewLowAsynchronousTxSubroutine - 1U);
	}

	/// Calculate the device memory address of the return command of the newly created low priority asynchronous messages Tx subroutine.
	U32BIT dwReturnCommandAddress; // The device memory address of the return command of the newly created low priority asynchronous messages Tx subroutine.
	dwReturnCommandAddress = (dsspDeviceState->bsBcState.dwLastAddressOfLowAsynchronousTxSubroutine - 1U);

	/// Initialize a helper buffer.
	// A helper buffer of static size is used to decrease the number of device memory write operations, as dynamic allocations are totally avoided by this library.
	// This buffer must be large enough to contain the scheme of the low priority asynchronous message Tx subroutine described above in the documentation for this function.
	U16BIT waHelperBuffer[((sitalBcMaximum_ASYNCHRONOUS_MESSAGES * asynchronousMessaging_COMMAND_COUNT_PER_LOW_PRIORITY_MESSAGE) + 1U) * bcMemoryObjectSize_COMMAND]; // Helper host buffer that prepares a writing to device.
	memset (waHelperBuffer, 0, sizeof(waHelperBuffer));

	/// Calculate the time stamp when no more asynchronous messages may be transmitted.
	// Note: Below calculation assumes that the currently executing major frame determines a common frame time for all its included minor frames (see further information in the documentation for this function).
	U16BIT wMinorFrameTime; // The Tx time principally assigned for given minor frame.
	wMinorFrameTime = dsspDeviceState->bsBcState.hfspRunningMajorFrame->wFrameTime;
	U16BIT wActualMinorFrameTime; // The Tx time actually assigned for given minor frame.
	wActualMinorFrameTime = ( ((U16BIT)0U == dsspDeviceState->bsBcState.wWatchDogTimeout) ? (U16BIT)0xFFFFU : (dsspDeviceState->bsBcState.wWatchDogTimeout + wMinorFrameTime) );
	U16BIT wEndTimeStamp; // The time stamp when the frame (including the following low priority asynchronous messages, if required) must end.
	wEndTimeStamp = (wActualMinorFrameTime - wMinorFrameTime);
	U16BIT wAsynchronousMessageTxThresholdStamp; // The time stamp when no more asynchronous messages may be transmitted.
	wAsynchronousMessageTxThresholdStamp = (wEndTimeStamp + (U16BIT)20U); // 2 ms.

	/// Loop over all the messages of given device:
	///		With each message that's currently assigned for low priority asynchronous Tx:
	///			Write in the helper buffer a time checker command that checks whether there's enough time to transmit this message.
	///			Write in the helper buffer a jump command to the end of the subroutine conditioned "if greater than".
	///			Write in the helper buffer an execute-and-flip command for current message conditioned "if good message".
	///			Write in the helper buffer a command to call the high priority asynchronous message Tx subroutine conditioned "GPF-6 raised".
	///			Record for this message the device memory address where the address of this message was written as the address parameter of the corresponding transmitter command.
	U16BIT wWordCount; // The counter of words that were already written to the helper buffer.
	wWordCount = 0U;
	U16BIT* wpCurrentWrittenWord; // A pointer to the word in the helper buffer where to write next.
	wpCurrentWrittenWord = waHelperBuffer;
	U32BIT dwCurrentAddressOfTransmitterCommandParameter; // The device memory address where the address of current message is written as the address parameter of the corresponding transmitter command.
	dwCurrentAddressOfTransmitterCommandParameter = (dsspDeviceState->bsBcState.dwAddressOfLowAsynchronousTxSubroutine + (U32BIT)5); // The offset of 5 words includes: CFT, parameter, JMP, parameter, XQF.
	hmspMessage = dsspDeviceState->bsBcState.hmsaMessage;
	for (wMessageId=0; wMessageId<sitalBcCounter_MESSAGES; wMessageId++, hmspMessage++, dwCurrentAddressOfTransmitterCommandParameter+=(asynchronousMessaging_COMMAND_COUNT_PER_LOW_PRIORITY_MESSAGE*bcMemoryObjectSize_COMMAND))
	{
		if (TRUE == hmspMessage->bIsAssignedForLowPriorityAsynchronousTx)
		{
			swResult = sitalBc_Command_GetWord (sitalOpcode_COMPARE_TO_FRAME_TIMER, sitalOpcodeCondition_ALWAYS, wpCurrentWrittenWord);
			wpCurrentWrittenWord++;
			(*wpCurrentWrittenWord) = wAsynchronousMessageTxThresholdStamp;
			wpCurrentWrittenWord++;
			wWordCount += bcMemoryObjectSize_COMMAND;

			swResult = sitalBc_Command_GetWord (sitalOpcode_JUMP, sitalOpcodeCondition_GREATER_THAN, wpCurrentWrittenWord);
			wpCurrentWrittenWord++;
			(*wpCurrentWrittenWord) = (U16BIT)dwReturnCommandAddress;
			wpCurrentWrittenWord++;
			wWordCount += bcMemoryObjectSize_COMMAND;

			swResult = sitalBc_Command_GetWord (sitalOpcode_EXECUTE_AND_FLIP, sitalOpcodeCondition_GOOD_MESSAGE, wpCurrentWrittenWord);
			wpCurrentWrittenWord++;
			(*wpCurrentWrittenWord) = ((U16BIT)(hmspMessage->dwAddress));
			wpCurrentWrittenWord++;
			wWordCount += bcMemoryObjectSize_COMMAND;

			swResult = sitalBc_Command_GetWord (sitalOpcode_CALL_SUBROUTINE, sitalOpcodeCondition_GP6_1, wpCurrentWrittenWord);
			wpCurrentWrittenWord++;
			(*wpCurrentWrittenWord) = ((U16BIT)(dsspDeviceState->bsBcState.dwAddressOfHighAsynchronousTxSubroutine));
			wpCurrentWrittenWord++;
			wWordCount += bcMemoryObjectSize_COMMAND;

			hmspMessage->dwAddressOfTransmitterCommandParameter = dwCurrentAddressOfTransmitterCommandParameter;
		}
	}

	/// Write in the helper buffer an ending return command.
	swResult = sitalBc_Command_GetWord (sitalOpcode_RETURN_FROM_SUBROUTINE, sitalOpcodeCondition_ALWAYS, wpCurrentWrittenWord);
	wpCurrentWrittenWord++;
	(*wpCurrentWrittenWord) = 0U;
	wpCurrentWrittenWord++;
	wWordCount += bcMemoryObjectSize_COMMAND;

	/// Write the contents of the helper buffer at place as the new low priority asynchronous messages Tx subroutine.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, dsspDeviceState->bsBcState.dwAddressOfLowAsynchronousTxSubroutine, sitalDeviceMemorySection_Ram, wWordCount, waHelperBuffer);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Raise GPF-7 to let given device enter the updated low priority asynchronous message Tx subroutine.
	swResult = bc_Gpf_SetState (swDevice, sitalBcConditionCode_GPF7, sitalBcGpfEffect_SET);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	// NB - 9.1.2017
	// Adding a sleep to let the HW execute in the case that this function is recalled without delays and GPF7 is cleared on entry
	Sleep_NonOsDependent(1U);
	return (S16BIT)wCountOfLowPriorityMessagesAssignedForTx;
}

/// <summary>
/// Fix for given BC device the subroutine that asynchronously transmits messages at low priority, so that it will transmit all the currently defined
/// asynchronous messages.
/// Then raise the proper general purpose flag, GPF-7, so that this subroutine will be actually called along the currently ongoing frame run.
///
/// Note:
/// - For an asynchronous message to be transmitted by this function it must be a dual message in which the second message's message block command
///   field is 0xFFFFU; This is the kind of messages automatically created by the sitalBc_AsynchronousMessage_Create* functions.
///   This kind of messages, once successfully transmitted using a XQF opcode that's conditioned with "good message" (which is the command used
///   by the high priority asynchronous message Tx subroutine), makes the device flip the message address to this dual message's second message,
///   where the 0xFFFFU makes the device avoid further Tx trials and message flips.
/// - Once an asynchronous message is defined, it may be transmitted at high priority again and again as many times as the user requires, but it won't
///   be transmitted more than once at low priority. Moreover, if an asynchronous message has already been transmitted at high priority, it won't be
///   retransmitted at low priority even once. In order to force its retransmission in such a case, the message must be deleted and recreated.
/// - Calling the subroutines that perform the high & low priority asynchronous message Tx (including their initial stubs) is conditioned by GPF-6 &
///   GPF-7, respectively, being on. In order to maintain this mechanism intact, user applications should never use GPF-6 and GPF-7.
/// - The count of asynchronous messages that still weren't assigned for Tx, being set for the variable pointed by wpRemainingMessageCount, is actually
///   always zero. Accordingly, the returned count of asynchronous messages assigned for Tx in the new low priority asynchronous message Tx subroutine
///   is actually the total number of currently defined asynchronous messages that still weren't asynchronously transmitted at either high or low
///   priority. In contrary to the corresponding library of DDC, all those asynchronous message that weren't yet transmitted are set for Tx by the
///   low priority asynchronous message Tx microcode subroutine that's built by this function, never mind how much free passive time is available at the end of
///   the currently executed minor frames. This policy is possible due to the fact that this library leaves the decision of whether to transmit more
///   low priority asynchronous messages or not to the device itself, which will continue Tx only as long as there's enough time for more messages,
///   and only with messages small enough to fit the time left.
/// - This function does not really require the time factor parameter, which isn't removed only in order to stay compatible with DDC.
/// - This function does not wait for the low priority asynchronous message Tx to complete;
///   Instead, the user may re-call this function again and again, possibly with a small delay in between the calls, until informed that there are no
///   more low priority asynchronous messages to transmit.
/// - The low priority asynchronous message Tx subroutine is made of a series of command quartets, one for each of the asynchronous messages that
///   weren't transmitted yet, where each of these quartets contains the following commands:
///   - A command to compare the frame timer to 2 ms.
///   - A jump command to-the-end-of-this-subroutine if-less-than
///   - An execute-and-flip command of-the-next-asynchronous-message if-good-message
///   - A command to call the high priority asynchronous message Tx subroutine conditioned by GPF-6 being raised.
///   Finally, a return command is added, in order to return control to the currently executing minor frame.
/// - The transmission of low priority asynchronous messages is supported by this library only while running a major frame that forces a common frame time
///   over all its minor frames. This enables it to concentrate the transmission commands for all the asynchronous messages in a single common routine and
///   this way save device memory space. What's more, this policy leaves the decision of which asynchronous messages to transmit at the end of each minor
///   frame for the device, which may then dynamically and accurately decide about it, taking in account the actual time it took to transmit the messages
///   of each frame in the current occasion.
///
/// Equivalent DDC definition: aceBCSendAsyncMsgLP
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wpRemainingMessageCount (out)	A pointer to a variable in which the count of asynchronous messages that still weren't assigned for Tx is returned
/// @param wTimeFactor (in) A time factor (Unused)
/// @return Positive integer	The number of asynchronous messages assigned for Tx in the new low priority asynchronous message Tx subroutine
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_AsynchronousMessage_SendAtLowPriority (S16BIT swDevice, U16BIT* wpRemainingMessageCount, U16BIT wTimeFactor)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_RUN != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (sitalBcSetupOption_ASYNCHRONOUS_LOW_PRIORITY_MODE != (sitalBcSetupOption_ASYNCHRONOUS_LOW_PRIORITY_MODE & dsspDeviceState->bsBcState.dwOptions))
	{
		return sitalReturnCode_SUITABLE_ASYNCHRONOUS_MODE_UNDEFINED;
	}

	// This function may be called only along frame run.
	// The following condition must therefore fulfill.
	Assert_NonOsDependent(((HostFrameStructure*)NULL) != dsspDeviceState->bsBcState.hfspRunningMajorFrame);

	if (0U == dsspDeviceState->bsBcState.hfspRunningMajorFrame->wFrameTime)
	{
		return sitalReturnCode_NO_FRAME_TIME_SET_FOR_MAJOR_FRAME;
	}

	/// Lower GPF-7 to prevent given device from entering the low priority asynchronous message Tx subroutine along its update.
	// Note that GPF-7 is used to protect from a situation in which the subroutine is updated at device memory at the same time when the device is
	// executing it. This protection is required in:
	// - The cases where the current subroutine is rewritten at the same place i.e., not written at a newly allocated space of device memory).
	// - The process of checking the existing low priority asynchronous message Tx subroutine in order to find out which messages haven't already been
	//   transmitted. These messages will be then assigned for Tx in the newly created subroutine, so it is required that once their Tx state is read,
	//   the device won't [re]try to transmit them anymore.
	S16BIT swResult; // Result of operation or function call.
	swResult = bc_Gpf_SetState (swDevice, sitalBcConditionCode_GPF7, sitalBcGpfEffect_CLEAR);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Wait enough time for the instruction pointer register to indicate that given device isn't currently executing the old subroutine.
	Sleep_NonOsDependent(1U + (dsspDeviceState->bsBcState.wTotalTxTimeOfLowAsynchronousTxSubroutine / 1000U));
	U16BIT wRegisterValue; // The current value of a target register, or the value to set for a target register.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, sitalRegisterAddress_BC_INSTRUCTION_LIST_POINTER, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	if ((dsspDeviceState->bsBcState.dwAddressOfHighAsynchronousTxSubroutine <= wRegisterValue) && (dsspDeviceState->bsBcState.dwLastAddressOfHighAsynchronousTxSubroutine >= wRegisterValue))
	{
		return sitalReturnCode_ASYNCHRONOUS_SUBROUTINE_BUSY;
	}

	if (((U16BIT*)NULL) == wpRemainingMessageCount)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Set the count of asynchronous messages that still weren't assigned for Tx.
	// (See remark above in the documentation for this function.)
	(*wpRemainingMessageCount) = 0U;

	/// Loop over all the messages of given device:
	///		With each currently defined asynchronous message which was already assigned for Tx in the low priority asynchronous message Tx subroutine and whose Tx wasn't yet identified:
	///			Read the address parameter of the corresponding XQF command in the low priority asynchronous message Tx subroutine.
	///			If it shows that a flip already occurred (i.e., message has been successfully transmitted):
	///				Flag this message as asynchronously transmitted.
	///		Flag the message as one that was not yet assigned for Tx in the low priority asynchronous message Tx subroutine.
	// As the existing low priority asynchronous message Tx subroutine is now canceled, no message is considered assigned for Tx until a new subroutine is created.
	HostMessageStructure* hmspMessage; // A pointer to a host message structure.
	hmspMessage = dsspDeviceState->bsBcState.hmsaMessage;
	U16BIT wMessageId; // A message ID.
	for (wMessageId=0U; wMessageId<sitalBcCounter_MESSAGES; wMessageId++, hmspMessage++)
	{
		if	(
				(FALSE == hmspMessage->bIsFreeForUse)
				&&
				(TRUE == hmspMessage->bIsAsynchronousMessage)
				&&
				(TRUE == hmspMessage->bIsAssignedForLowPriorityAsynchronousTx)
				&&
				(FALSE == hmspMessage->bIsAnAlreadyTransmittedAsynchronousMessage)
			)
		{
			U16BIT wCurrentAddressInTxCommand; // The address stored in device memory for the XQF command of the current message in the low priority asynchronous message Tx subroutine.
			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, hmspMessage->dwAddressOfTransmitterCommandParameter, sitalDeviceMemorySection_Ram, 1U, &wCurrentAddressInTxCommand);
			if (sitalReturnCode_SUCCESS != swResult)
			{
				return swResult;
			}
			if (bcCommandBlock_ExecuteAndFlip_AddressFlipBitMask == (bcCommandBlock_ExecuteAndFlip_AddressFlipBitMask & wCurrentAddressInTxCommand))
			{
				hmspMessage->bIsAnAlreadyTransmittedAsynchronousMessage = TRUE;
			}
		}

		hmspMessage->bIsAssignedForLowPriorityAsynchronousTx = FALSE;
	}

	/// Loop over all the messages of given device:
	///		If current message is a currently defined not-yet-transmitted asynchronous dual message whose command1 is set to "skip message":
	///			Count this message in the total number of messages that are assigned for inclusion in the new low priority asynchronous message Tx subroutine.
	///			Assign this message for inclusion in the low priority asynchronous message Tx subroutine.
	///			Add the Tx time of this message to the overall message Tx time of the newly created low priority asynchronous message Tx subroutine.
	///		Else:
	///			Sign this message as not assigned for inclusion in the low priority asynchronous message Tx subroutine.
	U16BIT wCountOfLowPriorityMessagesAssignedForTx; // The number of asynchronous messages assigned for Tx in the new low priority asynchronous message Tx subroutine.
	wCountOfLowPriorityMessagesAssignedForTx = 0U;
	dsspDeviceState->bsBcState.wTotalTxTimeOfLowAsynchronousTxSubroutine = 0U;
	hmspMessage = dsspDeviceState->bsBcState.hmsaMessage;
	for (wMessageId=0; wMessageId<sitalBcCounter_MESSAGES; wMessageId++, hmspMessage++)
	{
		if ((FALSE == hmspMessage->bIsFreeForUse) && (TRUE == hmspMessage->bIsAsynchronousMessage) && (bcMemoryObjectSize_DUAL_MESSAGE == hmspMessage->wActualSize) && (FALSE == hmspMessage->bIsAnAlreadyTransmittedAsynchronousMessage))
		{
			U32BIT dwCommandAddressOfSkippedMessage; // The address of the command word of the second message in our dual message.
			dwCommandAddressOfSkippedMessage = (hmspMessage->dwAddress + bcMemoryObjectSize_LARGE_MESSAGE + bcMessageBlock_OFFSET_OF_COMMAND_1);
			U16BIT wCommandOfSecondMessage; // The command word of the second message in given dual message, which must be a "skip message" message command (see the documentation for this function).
			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, dwCommandAddressOfSkippedMessage, sitalDeviceMemorySection_Ram, 1U, &wCommandOfSecondMessage);
			if ((sitalReturnCode_SUCCESS == swResult) && (bcMessageBlock_Command1_SKIP_MESSAGE == wCommandOfSecondMessage))
			{
				wCountOfLowPriorityMessagesAssignedForTx++;
				hmspMessage->bIsAssignedForLowPriorityAsynchronousTx = TRUE;
				dsspDeviceState->bsBcState.wTotalTxTimeOfLowAsynchronousTxSubroutine += hmspMessage->wMessageTxTime;
			}
		}
	}

	if (0U == wCountOfLowPriorityMessagesAssignedForTx)
	{
		return sitalReturnCode_ASYNCHRONOUS_LIST_IS_EMPTY;
	}

	/// Calculate the size (in words) of the new low priority asynchronous message Tx subroutine.
	/// If the size of the device memory currently allocated for the low priority asynchronous message Tx subroutine isn't enough for the new subroutine:
	///		Allocate a new suitable region in the bottom section of device memory.
	///		Record the new region's starting address, ending address, and size.
	///		Loop over all the commands in the currently executed major frame that call the low priority asynchronous messages Tx subroutine:
	///			Update the called address to point the device memory region that was just allocated.
	/// Else:
	///		Record the new region's ending address.
	U16BIT wSizeOfNewLowAsynchronousTxSubroutine; // The size (in words) of the new low priority asynchronous message Tx subroutine.
	wSizeOfNewLowAsynchronousTxSubroutine = (((wCountOfLowPriorityMessagesAssignedForTx * (U16BIT)asynchronousMessaging_COMMAND_COUNT_PER_LOW_PRIORITY_MESSAGE) + (U16BIT)1U) * (U16BIT)bcMemoryObjectSize_COMMAND);
	if (dsspDeviceState->bsBcState.wSizeOfLowAsynchronousTxSubroutine < wSizeOfNewLowAsynchronousTxSubroutine)
	{
		U32BIT dwAllocationSize; // The size (in words) of the device memory allocation.
		dwAllocationSize = wSizeOfNewLowAsynchronousTxSubroutine;
		BOOLEAN bIsAllocationSuccessfullyAccomplished; // A flag that says whether the allocation actually succeeded.
		U32BIT dwAllocationBaseAddress; // The address in device memory where a suitable segment of memory has been allocated for the newly created object.
		swResult = Device_Memory_BottomSection_AllocateContinuity (&(dsspDeviceState->hdmmsDeviceMemoryMap), &dwAllocationSize, 5, &bIsAllocationSuccessfullyAccomplished, &dwAllocationBaseAddress);
		if ( (sitalReturnCode_SUCCESS != swResult) || (FALSE == bIsAllocationSuccessfullyAccomplished) )
		{
			return sitalReturnCode_ALLOCATION_FAIL;
		}

		dsspDeviceState->bsBcState.dwAddressOfLowAsynchronousTxSubroutine = dwAllocationBaseAddress;
		dsspDeviceState->bsBcState.dwLastAddressOfLowAsynchronousTxSubroutine = (dwAllocationBaseAddress + (U32BIT)wSizeOfNewLowAsynchronousTxSubroutine - (U32BIT)1U);
		dsspDeviceState->bsBcState.wSizeOfLowAsynchronousTxSubroutine = (U16BIT)dwAllocationSize;

		U32BIT* dwpCurrentLowAsynchronousTxSubroutineCallAddress; // A pointer to the current entry in the array that stores the device memory addresses where the address of the low priority asynchronous messages Tx subroutine is recorded as parameter of call commands.
		dwpCurrentLowAsynchronousTxSubroutineCallAddress = dsspDeviceState->bsBcState.dwaLowAsynchronousTxSubroutineCallAddress;
		U16BIT wIoContents; // The variable into which the contents of a device word is read, or the variable whose contents are written to device.
		wIoContents = (U16BIT)dsspDeviceState->bsBcState.dwAddressOfLowAsynchronousTxSubroutine;
		for (U16BIT iNestedMinorFrameIndex=0U; iNestedMinorFrameIndex<dsspDeviceState->bsBcState.wNestedMinorFrameCount; iNestedMinorFrameIndex++, dwpCurrentLowAsynchronousTxSubroutineCallAddress++)
		{
			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, (*dwpCurrentLowAsynchronousTxSubroutineCallAddress), sitalDeviceMemorySection_Ram, 1U, &wIoContents);
			if (sitalReturnCode_SUCCESS != swResult)
			{
				return swResult;
			}
		}

		// Note that the region of device memory where the old low priority asynchronous messages Tx subroutine has been written isn't freed: there's no way to free a particular allocation in the bottom section of device memory.
	}
	else
	{
		// There's no need to allocate new memory: the region of device memory where the current low priority asynchronous messages Tx subroutine is written is enough to contain the new one.
		dsspDeviceState->bsBcState.dwLastAddressOfLowAsynchronousTxSubroutine = (dsspDeviceState->bsBcState.dwAddressOfLowAsynchronousTxSubroutine + wSizeOfNewLowAsynchronousTxSubroutine - 1U);
	}

	/// Calculate the device memory address of the return command of the newly created low priority asynchronous messages Tx subroutine.
	U32BIT dwReturnCommandAddress; // The device memory address of the return command of the newly created low priority asynchronous messages Tx subroutine.
	dwReturnCommandAddress = (dsspDeviceState->bsBcState.dwLastAddressOfLowAsynchronousTxSubroutine - 1U);

	/// Initialize a helper buffer.
	// A helper buffer of static size is used to decrease the number of device memory write operations, as dynamic allocations are totally avoided by this library.
	// This buffer must be large enough to contain the scheme of the low priority asynchronous message Tx subroutine described above in the documentation for this function.
	U16BIT waHelperBuffer[((sitalBcMaximum_ASYNCHRONOUS_MESSAGES * asynchronousMessaging_COMMAND_COUNT_PER_LOW_PRIORITY_MESSAGE) + 1U) * bcMemoryObjectSize_COMMAND]; // Helper host buffer that prepares a writing to device.
	memset (waHelperBuffer, 0, sizeof(waHelperBuffer));

	/// Calculate the time stamp when no more asynchronous messages may be transmitted.
	// Note: Below calculation assumes that the currently executing major frame determines a common frame time for all its included minor frames (see further information in the documentation for this function).
	U16BIT wMinorFrameTime; // The Tx time principally assigned for given minor frame.
	wMinorFrameTime = dsspDeviceState->bsBcState.hfspRunningMajorFrame->wFrameTime;
	U16BIT wActualMinorFrameTime; // The Tx time actually assigned for given minor frame.
	wActualMinorFrameTime = ( ((U16BIT)0U == dsspDeviceState->bsBcState.wWatchDogTimeout) ? (U16BIT)0xFFFFU : (dsspDeviceState->bsBcState.wWatchDogTimeout + wMinorFrameTime) );
	U16BIT wEndTimeStamp; // The time stamp when the frame (including the following low priority asynchronous messages, if required) must end.
	wEndTimeStamp = (wActualMinorFrameTime - wMinorFrameTime);
	U16BIT wAsynchronousMessageTxThresholdStamp; // The time stamp when no more asynchronous messages may be transmitted.
	wAsynchronousMessageTxThresholdStamp = (wEndTimeStamp + (U16BIT)20U); // 2 ms.

	/// Loop over all the messages of given device:
	///		With each message that's currently assigned for low priority asynchronous Tx:
	///			Write in the helper buffer a time checker command that checks whether there's enough time to transmit this message.
	///			Write in the helper buffer a jump command to the end of the subroutine conditioned "if greater than".
	///			Write in the helper buffer an execute-and-flip command for current message conditioned "if good message".
	///			Write in the helper buffer a command to call the high priority asynchronous message Tx subroutine conditioned "GPF-6 raised".
	///			Record for this message the device memory address where the address of this message was written as the address parameter of the corresponding transmitter command.
	U16BIT wWordCount; // The counter of words that were already written to the helper buffer.
	wWordCount = 0U;
	U16BIT* wpCurrentWrittenWord; // A pointer to the word in the helper buffer where to write next.
	wpCurrentWrittenWord = waHelperBuffer;
	U32BIT dwCurrentAddressOfTransmitterCommandParameter; // The device memory address where the address of current message is written as the address parameter of the corresponding transmitter command.
	dwCurrentAddressOfTransmitterCommandParameter = (dsspDeviceState->bsBcState.dwAddressOfLowAsynchronousTxSubroutine + (U32BIT)5); // The offset of 5 words includes: CFT, parameter, JMP, parameter, XQF.
	hmspMessage = dsspDeviceState->bsBcState.hmsaMessage;
	for (wMessageId=0; wMessageId<sitalBcCounter_MESSAGES; wMessageId++, hmspMessage++, dwCurrentAddressOfTransmitterCommandParameter+=(asynchronousMessaging_COMMAND_COUNT_PER_LOW_PRIORITY_MESSAGE*bcMemoryObjectSize_COMMAND))
	{
		if (TRUE == hmspMessage->bIsAssignedForLowPriorityAsynchronousTx)
		{
			swResult = sitalBc_Command_GetWord (sitalOpcode_COMPARE_TO_FRAME_TIMER, sitalOpcodeCondition_ALWAYS, wpCurrentWrittenWord);
			wpCurrentWrittenWord++;
			(*wpCurrentWrittenWord) = wAsynchronousMessageTxThresholdStamp;
			wpCurrentWrittenWord++;
			wWordCount += bcMemoryObjectSize_COMMAND;

			swResult = sitalBc_Command_GetWord (sitalOpcode_JUMP, sitalOpcodeCondition_GREATER_THAN, wpCurrentWrittenWord);
			wpCurrentWrittenWord++;
			(*wpCurrentWrittenWord) = (U16BIT)dwReturnCommandAddress;
			wpCurrentWrittenWord++;
			wWordCount += bcMemoryObjectSize_COMMAND;

			swResult = sitalBc_Command_GetWord (sitalOpcode_EXECUTE_AND_FLIP, sitalOpcodeCondition_GOOD_MESSAGE, wpCurrentWrittenWord);
			wpCurrentWrittenWord++;
			(*wpCurrentWrittenWord) = ((U16BIT)(hmspMessage->dwAddress));
			wpCurrentWrittenWord++;
			wWordCount += bcMemoryObjectSize_COMMAND;

			swResult = sitalBc_Command_GetWord (sitalOpcode_CALL_SUBROUTINE, sitalOpcodeCondition_GP6_1, wpCurrentWrittenWord);
			wpCurrentWrittenWord++;
			(*wpCurrentWrittenWord) = ((U16BIT)(dsspDeviceState->bsBcState.dwAddressOfHighAsynchronousTxSubroutine));
			wpCurrentWrittenWord++;
			wWordCount += bcMemoryObjectSize_COMMAND;

			hmspMessage->dwAddressOfTransmitterCommandParameter = dwCurrentAddressOfTransmitterCommandParameter;
		}
	}

	/// Write in the helper buffer an ending return command.
	swResult = sitalBc_Command_GetWord (sitalOpcode_RETURN_FROM_SUBROUTINE, sitalOpcodeCondition_ALWAYS, wpCurrentWrittenWord);
	wpCurrentWrittenWord++;
	(*wpCurrentWrittenWord) = 0U;
	wpCurrentWrittenWord++;
	wWordCount += bcMemoryObjectSize_COMMAND;

	/// Write the contents of the helper buffer at place as the new low priority asynchronous messages Tx subroutine.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, dsspDeviceState->bsBcState.dwAddressOfLowAsynchronousTxSubroutine, sitalDeviceMemorySection_Ram, wWordCount, waHelperBuffer);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Raise GPF-7 to let given device enter the updated low priority asynchronous message Tx subroutine.
	swResult = bc_Gpf_SetState (swDevice, sitalBcConditionCode_GPF7, sitalBcGpfEffect_SET);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	return (S16BIT)wCountOfLowPriorityMessagesAssignedForTx;
}


/// <summary>
/// Fix for given BC device the subroutine that asynchronously transmits a single desired message at high priority, so that it will transmit given message.
/// Then raise the proper general purpose flag, GPF-6, so that this subroutine will be actually called along the currently ongoing frame run.
/// Finally, wait for given message to be transmitted.
///
/// Note:
/// - Given message must be an asynchronous message.
/// - Given message must be a dual message in which the second message's message block command field is 0xFFFF, which is an illegal message;
///   This is the kind of messages automatically created by the sitalBc_AsynchronousMessage_Create* functions.
///   This kind of messages, once successfully transmitted using a XQF opcode that's conditioned with "good message" (which is the command used
///   by the high priority asynchronous message Tx subroutine), makes the device flip the message address to this dual message's second message,
///   where the 0xFFFFU makes the device avoid further Tx trials and message flips, so no time will be spent anymore with this message.
/// - Once an asynchronous message is defined, it may be transmitted at high priority again and again as many times as the user requires, but it won't
///   be transmitted more than once at low priority. Moreover, if an asynchronous message has already been transmitted at high priority, it won't be
///   retransmitted at low priority even once. In order to force its retransmission in such a case, the message must be deleted and recreated.
/// - This function does not really require the time factor parameter, which isn't removed only in order to stay compatible with DDC.
/// - Calling the subroutines that perform the high & low priority asynchronous message Tx (including their initial stubs) is conditioned by GPF-6 &
///   GPF-7, respectively, being on; User applications should restrict themselves to never use GPF-6 and GPF-7!
///
///		NB - 9.1.2017 - 
///		Added a non-DDC compatible API enhancement which signals the hardware to transmit the high priority async message only once, on good and bad messages
///
/// Equivalent DDC definition: aceBCSendAsyncMsgHP
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wMessageId (in)	A unique ID designating a message (0-(sitalBcCounter_MESSAGES-1))
/// @param wTimeFactor (in) A time factor 
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_AsynchronousMessage_SendAtHighPriority_ExecuteOnce (S16BIT swDevice, U16BIT wMessageId, U16BIT wTimeFactor)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (sitalBcSetupOption_ASYNCHRONOUS_HIGH_PRIORITY_MODE != (sitalBcSetupOption_ASYNCHRONOUS_HIGH_PRIORITY_MODE & dsspDeviceState->bsBcState.dwOptions))
	{
		return sitalReturnCode_SUITABLE_ASYNCHRONOUS_MODE_UNDEFINED;
	}

	HostMessageStructure* hmspMessage; // A pointer to a host message structure.
	hmspMessage = (HostMessageStructure*)&(dsspDeviceState->bsBcState.hmsaMessage[wMessageId]);
	if (TRUE == hmspMessage->bIsFreeForUse)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}
	if (FALSE == hmspMessage->bIsAsynchronousMessage)
	{
		return sitalReturnCode_ASYNCHRONOUS_MESSAGE_ERROR;
	}
	S16BIT swResult; // Result of operation or function call.
	if (bcMemoryObjectSize_DUAL_MESSAGE != hmspMessage->wActualSize)
	{
		//swResult = sitalProcess_Log_PrintLine ("#StldDll.Async.Hi.Error: device - %i, message - %i, message_actual_size - %i, expected_message_actual_size - %i\n", swDevice, wMessageId, hmspMessage->wActualSize, bcMemoryObjectSize_DUAL_MESSAGE);
		return sitalReturnCode_ASYNCHRONOUS_MESSAGE_ERROR;
	}
	U32BIT dwCommandAddressOfSkippedMessage; // The address of the command word of the second message in our dual message.
	dwCommandAddressOfSkippedMessage = (hmspMessage->dwAddress + bcMemoryObjectSize_LARGE_MESSAGE + bcMessageBlock_OFFSET_OF_COMMAND_1);
	U16BIT wCommandOfSecondMessage; // The command word of the second message in given dual message, which must be a "skip message" message command (see the documentation for this function).
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, dwCommandAddressOfSkippedMessage, sitalDeviceMemorySection_Ram, 1U, &wCommandOfSecondMessage);
	if ((sitalReturnCode_SUCCESS != swResult) || (bcMessageBlock_Command1_SKIP_MESSAGE != wCommandOfSecondMessage))
	{
		//swResult = sitalProcess_Log_PrintLine ("#StldDll.Async.Hi.Error: device - %i, message - %i, result - %i, 2nd_message_command - %04X, expected_2nd_message_command - %04X\n", swDevice, wMessageId, swResult, wCommandOfSecondMessage, bcMessageBlock_Command1_SKIP_MESSAGE);
		return sitalReturnCode_ASYNCHRONOUS_MESSAGE_ERROR;
	}

	/// Lower GPF-6 to prevent given device from entering the high priority asynchronous message Tx subroutine along its update.
	swResult = bc_Gpf_SetState (swDevice, sitalBcConditionCode_GPF6, sitalBcGpfEffect_CLEAR);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Wait enough time for the instruction pointer register to indicate that given device isn't currently executing the updated subroutine.
	Sleep_NonOsDependent(1U);
	U16BIT wRegisterValue; // The current value of a target register, or the value to set for a target register.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, sitalRegisterAddress_BC_INSTRUCTION_LIST_POINTER, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	if ((dsspDeviceState->bsBcState.dwAddressOfHighAsynchronousTxSubroutine <= wRegisterValue) && (dsspDeviceState->bsBcState.dwLastAddressOfHighAsynchronousTxSubroutine >= wRegisterValue))
	{
		return sitalReturnCode_ASYNCHRONOUS_SUBROUTINE_BUSY;
	}

	// Now it's clear that the target subroutine isn't currently accessed by the device itself.
	// Since the GPF that controls its access was just lowered (see above), the device won't enter this subroutine, so its safe to update it.
	// As function sitalBc_Start creates a stub high priority asynchronous message Tx subroutine, here this stub (or the current subroutine,
	// if the stub was already changed) must be fixed.
	// In that stub subroutine everything is in place, and the only thing to change is the address of the transmitted message.
	/// Fix the message address in the existing high priority asynchronous message Tx subroutine to point given message.
	U16BIT wIoContents; // The variable into which the contents of a device word is read, or the variable whose contents are written to device.
	wIoContents = hmspMessage->dwAddress;
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, (dsspDeviceState->bsBcState.dwAddressOfHighAsynchronousTxSubroutine + 1U), sitalDeviceMemorySection_Ram, 1U, &wIoContents);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Raise GPF-6 to let given device enter the updated high priority asynchronous message Tx subroutine.
	swResult = bc_Gpf_SetState (swDevice, sitalBcConditionCode_GPF6, sitalBcGpfEffect_SET);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Wait enough time for given message to be transmitted.
	// Relying on a timeout (compatible to DDC implementation) and user-specified additional time factor
	U16BIT wCurrentAddressInTxCommand; // The address stored in device memory for the XQF command of the high priority asynchronous message Tx subroutine.
	U32BIT wInterimTotalSleep; // The current interim total of actual sleep (in units of milliseconds).
	wInterimTotalSleep = wTimeFactor > 1000U ? (1000001 * (wTimeFactor / 1000U)) : 1000001;
	U16BIT wMaximumSleep; // The maximum allowed period of sleep (in units of milliseconds).
	wMaximumSleep = 2U;
	BOOLEAN bFirstIteration; // A flag that says whether the loop is now making its first iteration.
	bFirstIteration = TRUE;
	do
	{
		wInterimTotalSleep--;
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, hmspMessage->dwAddress + bcMessageBlock_OFFSET_OF_BLOCK_STATUS, sitalDeviceMemorySection_Ram, 1U, &wCurrentAddressInTxCommand);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
	}
	while ((wCurrentAddressInTxCommand & 0x8000) == 0 && wInterimTotalSleep > 0);

	// clearing the GPF6 to prevent further transmissions 
	swResult = bc_Gpf_SetState (swDevice, sitalBcConditionCode_GPF6, sitalBcGpfEffect_CLEAR);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	if (bcCommandBlock_ExecuteAndFlip_AddressFlipBitMask != (bcCommandBlock_ExecuteAndFlip_AddressFlipBitMask & wCurrentAddressInTxCommand))
	{
		// The message that should have been successfully transmitted probably has not.
		// Read its block status word, the message command 1, and the RT status word 1.
		U16BIT wBlockStatusWord; // Message block status.
		U16BIT wCommandWord1; // Command word.
		U16BIT wRtStatusWord1; // RT status word 1.
		swResult = sitalDevice_AccessMemory (swDevice, sitalDeviceAccessOperation_Read, (wCurrentAddressInTxCommand + bcMessageBlock_OFFSET_OF_BLOCK_STATUS), sitalDeviceMemorySection_Ram, 1U, &wBlockStatusWord);
		swResult = sitalDevice_AccessMemory (swDevice, sitalDeviceAccessOperation_Read, (wCurrentAddressInTxCommand + bcMessageBlock_OFFSET_OF_COMMAND_1), sitalDeviceMemorySection_Ram, 1U, &wCommandWord1);
		swResult = sitalDevice_AccessMemory (swDevice, sitalDeviceAccessOperation_Read, (wCurrentAddressInTxCommand + bcMessageBlock_OFFSET_OF_RT_STATUS_WORD_1), sitalDeviceMemorySection_Ram, 1U, &wRtStatusWord1);
		swResult = sitalProcess_Log_PrintLine ("#StldDll.Async.Hi.Error: device - %i, message - %i, address_in_tx_command - %04X, expected_bit_on - 0010, bsw - %04X, command_1 - %04X, rt_status_1 - %04X\n", swDevice, wMessageId, wCurrentAddressInTxCommand, wBlockStatusWord, wCommandWord1, wRtStatusWord1);
		return sitalReturnCode_ASYNCHRONOUS_MESSAGE_ERROR;
	}

	/// Sign given message as an already asynchronously transmitted one.
	hmspMessage->bIsAnAlreadyTransmittedAsynchronousMessage = TRUE;
	hmspMessage->bIsAnAlreadyRecordedAsynchronousMessage = FALSE;

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Fix for given BC device the subroutine that asynchronously transmits a single desired message at high priority, so that it will transmit given message.
/// Then raise the proper general purpose flag, GPF-6, so that this subroutine will be actually called along the currently ongoing frame run.
/// Finally, wait for given message to be transmitted.
///
/// Note:
/// - Given message must be an asynchronous message.
/// - Given message must be a dual message in which the second message's message block command field is 0xFFFF, which is an illegal message;
///   This is the kind of messages automatically created by the sitalBc_AsynchronousMessage_Create* functions.
///   This kind of messages, once successfully transmitted using a XQF opcode that's conditioned with "good message" (which is the command used
///   by the high priority asynchronous message Tx subroutine), makes the device flip the message address to this dual message's second message,
///   where the 0xFFFFU makes the device avoid further Tx trials and message flips, so no time will be spent anymore with this message.
/// - Once an asynchronous message is defined, it may be transmitted at high priority again and again as many times as the user requires, but it won't
///   be transmitted more than once at low priority. Moreover, if an asynchronous message has already been transmitted at high priority, it won't be
///   retransmitted at low priority even once. In order to force its retransmission in such a case, the message must be deleted and recreated.
/// - This function does not really require the time factor parameter, which isn't removed only in order to stay compatible with DDC.
/// - Calling the subroutines that perform the high & low priority asynchronous message Tx (including their initial stubs) is conditioned by GPF-6 &
///   GPF-7, respectively, being on; User applications should restrict themselves to never use GPF-6 and GPF-7!
///
/// Equivalent DDC definition: aceBCSendAsyncMsgHP
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wMessageId (in)	A unique ID designating a message (0-(sitalBcCounter_MESSAGES-1))
/// @param wTimeFactor (in) A time factor (Unused)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_AsynchronousMessage_SendAtHighPriority (S16BIT swDevice, U16BIT wMessageId, U16BIT wTimeFactor)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (sitalBcSetupOption_ASYNCHRONOUS_HIGH_PRIORITY_MODE != (sitalBcSetupOption_ASYNCHRONOUS_HIGH_PRIORITY_MODE & dsspDeviceState->bsBcState.dwOptions))
	{
		return sitalReturnCode_SUITABLE_ASYNCHRONOUS_MODE_UNDEFINED;
	}

	HostMessageStructure* hmspMessage; // A pointer to a host message structure.
	hmspMessage = (HostMessageStructure*)&(dsspDeviceState->bsBcState.hmsaMessage[wMessageId]);
	if (TRUE == hmspMessage->bIsFreeForUse)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}
	if (FALSE == hmspMessage->bIsAsynchronousMessage)
	{
		return sitalReturnCode_ASYNCHRONOUS_MESSAGE_ERROR;
	}
	S16BIT swResult; // Result of operation or function call.
	if (bcMemoryObjectSize_DUAL_MESSAGE != hmspMessage->wActualSize)
	{
		//swResult = sitalProcess_Log_PrintLine ("#StldDll.Async.Hi.Error: device - %i, message - %i, message_actual_size - %i, expected_message_actual_size - %i\n", swDevice, wMessageId, hmspMessage->wActualSize, bcMemoryObjectSize_DUAL_MESSAGE);
		return sitalReturnCode_ASYNCHRONOUS_MESSAGE_ERROR;
	}
	U32BIT dwCommandAddressOfSkippedMessage; // The address of the command word of the second message in our dual message.
	dwCommandAddressOfSkippedMessage = (hmspMessage->dwAddress + bcMemoryObjectSize_LARGE_MESSAGE + bcMessageBlock_OFFSET_OF_COMMAND_1);
	U16BIT wCommandOfSecondMessage; // The command word of the second message in given dual message, which must be a "skip message" message command (see the documentation for this function).
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, dwCommandAddressOfSkippedMessage, sitalDeviceMemorySection_Ram, 1U, &wCommandOfSecondMessage);
	if ((sitalReturnCode_SUCCESS != swResult) || (bcMessageBlock_Command1_SKIP_MESSAGE != wCommandOfSecondMessage))
	{
		//swResult = sitalProcess_Log_PrintLine ("#StldDll.Async.Hi.Error: device - %i, message - %i, result - %i, 2nd_message_command - %04X, expected_2nd_message_command - %04X\n", swDevice, wMessageId, swResult, wCommandOfSecondMessage, bcMessageBlock_Command1_SKIP_MESSAGE);
		return sitalReturnCode_ASYNCHRONOUS_MESSAGE_ERROR;
	}

	/// Lower GPF-6 to prevent given device from entering the high priority asynchronous message Tx subroutine along its update.
	swResult = bc_Gpf_SetState (swDevice, sitalBcConditionCode_GPF6, sitalBcGpfEffect_CLEAR);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Wait enough time for the instruction pointer register to indicate that given device isn't currently executing the updated subroutine.
	Sleep_NonOsDependent(1U);
	U16BIT wRegisterValue; // The current value of a target register, or the value to set for a target register.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, sitalRegisterAddress_BC_INSTRUCTION_LIST_POINTER, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	if ((dsspDeviceState->bsBcState.dwAddressOfHighAsynchronousTxSubroutine <= wRegisterValue) && (dsspDeviceState->bsBcState.dwLastAddressOfHighAsynchronousTxSubroutine >= wRegisterValue))
	{
		return sitalReturnCode_ASYNCHRONOUS_SUBROUTINE_BUSY;
	}

	// Now it's clear that the target subroutine isn't currently accessed by the device itself.
	// Since the GPF that controls its access was just lowered (see above), the device won't enter this subroutine, so its safe to update it.
	// As function sitalBc_Start creates a stub high priority asynchronous message Tx subroutine, here this stub (or the current subroutine,
	// if the stub was already changed) must be fixed.
	// In that stub subroutine everything is in place, and the only thing to change is the address of the transmitted message.
	/// Fix the message address in the existing high priority asynchronous message Tx subroutine to point given message.
	U16BIT wIoContents; // The variable into which the contents of a device word is read, or the variable whose contents are written to device.
	wIoContents = hmspMessage->dwAddress;
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, (dsspDeviceState->bsBcState.dwAddressOfHighAsynchronousTxSubroutine + 1U), sitalDeviceMemorySection_Ram, 1U, &wIoContents);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Raise GPF-6 to let given device enter the updated high priority asynchronous message Tx subroutine.
	swResult = bc_Gpf_SetState (swDevice, sitalBcConditionCode_GPF6, sitalBcGpfEffect_SET);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Wait enough time for given message to be transmitted.
	// Note: A message may take up to 700 us to transmit, and the high priority asynchronous message that is transmitted right after it may take the same time, so waiting 1 ms twice should suffice for the longest combination.
	U16BIT wCurrentAddressInTxCommand; // The address stored in device memory for the XQF command of the high priority asynchronous message Tx subroutine.
	U16BIT wInterimTotalSleep; // The current interim total of actual sleep (in units of milliseconds).
	wInterimTotalSleep = 0U;
	U16BIT wMaximumSleep; // The maximum allowed period of sleep (in units of milliseconds).
	wMaximumSleep = 2U;
	BOOLEAN bFirstIteration; // A flag that says whether the loop is now making its first iteration.
	bFirstIteration = TRUE;
	do
	{
		if (FALSE == bFirstIteration)
		{
			Sleep_NonOsDependent(1U); // 1 ms.
			wInterimTotalSleep++;
		}

		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, (dsspDeviceState->bsBcState.dwAddressOfHighAsynchronousTxSubroutine + 1U), sitalDeviceMemorySection_Ram, 1U, &wCurrentAddressInTxCommand);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}

		bFirstIteration = FALSE;
	}
	while ((bcCommandBlock_ExecuteAndFlip_AddressFlipBitMask != (bcCommandBlock_ExecuteAndFlip_AddressFlipBitMask & wCurrentAddressInTxCommand)) && (wInterimTotalSleep < wMaximumSleep));

	if (bcCommandBlock_ExecuteAndFlip_AddressFlipBitMask != (bcCommandBlock_ExecuteAndFlip_AddressFlipBitMask & wCurrentAddressInTxCommand))
	{
		// The message that should have been successfully transmitted probably has not.
		// Read its block status word, the message command 1, and the RT status word 1.
		U16BIT wBlockStatusWord; // Message block status.
		U16BIT wCommandWord1; // Command word.
		U16BIT wRtStatusWord1; // RT status word 1.
		swResult = sitalDevice_AccessMemory (swDevice, sitalDeviceAccessOperation_Read, (wCurrentAddressInTxCommand + bcMessageBlock_OFFSET_OF_BLOCK_STATUS), sitalDeviceMemorySection_Ram, 1U, &wBlockStatusWord);
		swResult = sitalDevice_AccessMemory (swDevice, sitalDeviceAccessOperation_Read, (wCurrentAddressInTxCommand + bcMessageBlock_OFFSET_OF_COMMAND_1), sitalDeviceMemorySection_Ram, 1U, &wCommandWord1);
		swResult = sitalDevice_AccessMemory (swDevice, sitalDeviceAccessOperation_Read, (wCurrentAddressInTxCommand + bcMessageBlock_OFFSET_OF_RT_STATUS_WORD_1), sitalDeviceMemorySection_Ram, 1U, &wRtStatusWord1);
		swResult = sitalProcess_Log_PrintLine ("#StldDll.Async.Hi.Error: device - %i, message - %i, address_in_tx_command - %04X, expected_bit_on - 0010, bsw - %04X, command_1 - %04X, rt_status_1 - %04X\n", swDevice, wMessageId, wCurrentAddressInTxCommand, wBlockStatusWord, wCommandWord1, wRtStatusWord1);
		return sitalReturnCode_ASYNCHRONOUS_MESSAGE_ERROR;
	}

	/// Sign given message as an already asynchronously transmitted one.
	hmspMessage->bIsAnAlreadyTransmittedAsynchronousMessage = TRUE;
	hmspMessage->bIsAnAlreadyRecordedAsynchronousMessage = FALSE;

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Initialize (or re-initialize) given BC device's host buffer.
///
/// Equivalent DDC definition: aceBCInstallHBuf
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param dwHostBufferSize (in)	The desired size (in words) of the host buffer (sitalMinimum_SIZE_OF_HOST_BUFFER-sitalMaximum_SIZE_OF_HOST_BUFFER)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
S16BIT _DECL sitalBc_HostBuffer_Initialize (S16BIT swDevice, U32BIT dwHostBufferSize)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((sitalMinimum_SIZE_OF_HOST_BUFFER > dwHostBufferSize) || (sitalMaximum_SIZE_OF_HOST_BUFFER < dwHostBufferSize))
	{
		return sitalReturnCode_INVALID_HOST_BUFFER_SIZE;
	}

	/// If given device's host buffer is currently in use:
	///		Reset given device's host buffer.
	HostBufferStructure* hbspHostBuffer; // A host buffer structure.
	hbspHostBuffer = &(dsspDeviceState->bsBcState.hbsHostBuffer);
	S16BIT swResult; // Result of operation or function call.
	if (0U != hbspHostBuffer->dwHostBufferSize)
	{
		swResult = sitalBc_HostBuffer_Free (swDevice);
	}

	///	Properly set given device's host buffer.
	hbspHostBuffer->dwHostBufferSize = ( dwHostBufferSize - (dwHostBufferSize % sitalBcMaximum_MESSAGE_SIZE) );
	hbspHostBuffer->dwLastMessageTimeTag = 0U;
	hbspHostBuffer->dwOffsetOfNextMessageToRead = 0U;
	hbspHostBuffer->dwOffsetOfNextMessageToWrite = 0U;
	hbspHostBuffer->dwMessageCount = 0U;
	hbspHostBuffer->dwLostMessageCount = 0U;
	hbspHostBuffer->wFullnessPercentage = 0U;
	hbspHostBuffer->wMaximumFullnessPercentage = 0U;

	/// In case of a real device:
	///		Configure the user's interrupt mask pseudo register to issue interrupts when the time tag register rolls over to zero.
	if (sitalAccess_CARD == dsspDeviceState->wAccess)
	{
		dsspDeviceState->dwInternalImr |= sitalInterruptRegister1_TIME_TAG_ROLLOVER;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Free given bc device's host buffer.
///
/// Equivalent DDC definition: aceBCUninstallHBuf
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
S16BIT _DECL sitalBc_HostBuffer_Free (S16BIT swDevice)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	HostBufferStructure* hbspHostBuffer; // A host buffer structure.
	hbspHostBuffer = &(dsspDeviceState->bsBcState.hbsHostBuffer);
	if (0U == hbspHostBuffer->dwHostBufferSize)
	{
		return sitalReturnCode_HOST_BUFFER_NOT_INSTALLED;
	}

	///	Free given device's host buffer.
	hbspHostBuffer->dwHostBufferSize = 0U;
	hbspHostBuffer->dwLastMessageTimeTag = 0U;
	hbspHostBuffer->dwOffsetOfNextMessageToRead = 0U;
	hbspHostBuffer->dwOffsetOfNextMessageToWrite = 0U;
	hbspHostBuffer->dwMessageCount = 0U;
	hbspHostBuffer->dwLostMessageCount = 0U;
	hbspHostBuffer->wFullnessPercentage = 0U;
	hbspHostBuffer->wMaximumFullnessPercentage = 0U;

	/// In case of a real device:
	///		Configure the user's interrupt mask pseudo register not to issue interrupts when the time tag register rolls over to zero.
	if (sitalAccess_CARD == dsspDeviceState->wAccess)
	{
		dsspDeviceState->dwInternalImr &= (~sitalInterruptRegister1_TIME_TAG_ROLLOVER);
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Get the number of messages that are currently available in the host buffer that is assigned with given bc device.
///
/// Equivalent DDC definition: aceBCGetHBufMsgCount
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @return Non-negative integer	The number of messages that are currently available in the host buffer that is assigned with given device
/// @return Negative sitalReturnCode_*	Error condition or function failed
S16BIT _DECL sitalBc_HostBuffer_Message_GetCount (S16BIT swDevice)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	HostBufferStructure* hbspHostBuffer; // A host buffer structure.
	hbspHostBuffer = (HostBufferStructure*)&(dsspDeviceState->bsBcState.hbsHostBuffer);
	if (0U == hbspHostBuffer->dwHostBufferSize)
	{
		return sitalReturnCode_HOST_BUFFER_NOT_INSTALLED;
	}

	return (S16BIT)(hbspHostBuffer->dwMessageCount);
}


/// <summary>
/// Read from the host buffer of given BC device the message at given location, and decode it into given structure.
/// Remove from the host buffer the message that was read.
///
/// Equivalent DDC definition: aceBCGetHBufMsgDecoded
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param dmspDecodedMessage (out)	A pointer to a structure into which a message is decoded
/// @param dwpMessageCount (out)	A pointer to a variable in which the number of retrieved messages (actually only 0 or 1) is returned
/// @param dwpLostMessageCount (out)	A pointer to a variable in which the host buffer's current number of lost messages is returned
/// @param wMessageLocationAndRemoval (in)	The location in the stack or host buffer of the message to read, and removal instructions (sitalMessageLocationAndRemoval_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
S16BIT _DECL sitalBc_HostBuffer_Message_GetDecoded (	S16BIT swDevice,
														sitalDecodedMessageStructure* dmspDecodedMessage,
														U32BIT* dwpMessageCount,
														U32BIT* dwpLostMessageCount,
														U16BIT wMessageLocationAndRemoval)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((((sitalDecodedMessageStructure*)NULL) == dmspDecodedMessage) || (((U32BIT*)NULL) == dwpMessageCount) || (((U32BIT*)NULL) == dwpLostMessageCount))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if ((0U > wMessageLocationAndRemoval) || (messageLocationAndRemoval_BORDER <= wMessageLocationAndRemoval))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	HostBufferStructure* hbspHostBuffer; // A host buffer structure.
	hbspHostBuffer = (HostBufferStructure*)&(dsspDeviceState->bsBcState.hbsHostBuffer);
	if (0U == hbspHostBuffer->dwHostBufferSize)
	{
		return sitalReturnCode_HOST_BUFFER_NOT_INSTALLED;
	}

	///	Set the returned count of lost messages.
	(*dwpLostMessageCount) = hbspHostBuffer->dwLostMessageCount;

	/// If no messages are available in the host buffer of given device:
	///		Properly set the returned count of messages.
	///		Return.
	if ((0U == hbspHostBuffer->dwMessageCount) || (hbspHostBuffer->dwOffsetOfNextMessageToRead == hbspHostBuffer->dwOffsetOfNextMessageToWrite))
	{
		(*dwpMessageCount) = 0U;
		return sitalReturnCode_SUCCESS;
	}

	/// Interpret given message location directive.
	BOOLEAN bIsNextMessageRequired; // A flag that says whether to read the next available message (or, else, the last available one).
	bIsNextMessageRequired = (BOOLEAN)((U16BIT)sitalMessageLocation_NEXT == ((U16BIT)messageLocationAndRemoval_LOCATION & wMessageLocationAndRemoval));

	/// Interpret given message removal directive.
	BOOLEAN bIsMessagePurgeRequired; // A flag that says whether to delete the record of the message that's read.
	bIsMessagePurgeRequired = (BOOLEAN)((U16BIT)sitalMessageRemoval_PURGE == ((U16BIT)messageLocationAndRemoval_REMOVAL & wMessageLocationAndRemoval));

	/// Use given message location and purge directives to:
	///		Point the place in host buffer of given device where the requested message is presumably stored.
	///		If the returned message should be purged:
	///			Purge returned message.
	// With all above operations the possibility of an interim rollover is, of course, taken in account below.
	// Note that here 'Purge' solely means a proper update of the host buffer's internal offsets, not an actual zeroing of the message, so it still may be later on decoded (see below).
	U16BIT* wapBuffer; // A pointer to the place in the host buffer in which the requested raw message is stored.
	if (bIsNextMessageRequired)
	{
		wapBuffer = (hbspHostBuffer->waBuffer + hbspHostBuffer->dwOffsetOfNextMessageToRead);

		if (bIsMessagePurgeRequired)
		{
			hbspHostBuffer->dwOffsetOfNextMessageToRead += sitalBcMaximum_MESSAGE_SIZE;
			hbspHostBuffer->dwOffsetOfNextMessageToRead = ( (hbspHostBuffer->dwHostBufferSize == hbspHostBuffer->dwOffsetOfNextMessageToRead) ? 0 : hbspHostBuffer->dwOffsetOfNextMessageToRead );

			hbspHostBuffer->dwMessageCount--;
		}
	}
	else // Last message required
	{
		U32BIT dwOffsetOfLatestWrittenMessage; // The offset (in words) from the beginning of the host buffer of the location where the latest message has been written.
		dwOffsetOfLatestWrittenMessage = ( ((0U == hbspHostBuffer->dwOffsetOfNextMessageToWrite) ? hbspHostBuffer->dwHostBufferSize : hbspHostBuffer->dwOffsetOfNextMessageToWrite) - sitalBcMaximum_MESSAGE_SIZE );
		wapBuffer = (hbspHostBuffer->waBuffer + dwOffsetOfLatestWrittenMessage);

		if (bIsMessagePurgeRequired)
		{
			hbspHostBuffer->dwOffsetOfNextMessageToRead = hbspHostBuffer->dwOffsetOfNextMessageToWrite;
			hbspHostBuffer->dwMessageCount = 0U;
		}
	}

	///	If the returned message should be purged and configured to collect operational statistics for given device:
	///		Update the fullness statistics for given device.
	if ((TRUE == bIsMessagePurgeRequired) && (TRUE == dsspDeviceState->bIsOperationalStatisticsCollected))
	{
		hbspHostBuffer->wFullnessPercentage = (U16BIT)( (double)100.0 * (double)(((hbspHostBuffer->dwOffsetOfNextMessageToRead > hbspHostBuffer->dwOffsetOfNextMessageToWrite) ? hbspHostBuffer->dwHostBufferSize : 0U) + hbspHostBuffer->dwOffsetOfNextMessageToWrite - hbspHostBuffer->dwOffsetOfNextMessageToRead) / ((double)(hbspHostBuffer->dwHostBufferSize)) );
	}

	/// If succeeds to decode a new message starting at the pointed place in host buffer of given device:
	///		Properly set the returned count of messages.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalBc_Message_DecodeRaw (swDevice, wapBuffer, dmspDecodedMessage);
	(*dwpMessageCount) = ( (sitalReturnCode_SUCCESS == swResult) ? 1U : 0U );

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Read from the host buffer of given bc device as many currently available raw messages as possible (that is, as the size of given buffer permits).
/// Remove from the host buffer the messages that were read.
///
/// Note:
/// - Given buffer is first zeroed, and then filled with available messages, where each message is stored as follows:
///   - A number of sitalBcMaximum_MESSAGE_SIZE memory words is dedicated per message, never mind its actual size.
///   - The data stack pointer is replaced with a word whose:
///     - MSByte contains the count of data words for the message that was read.
///     - LSByte contains the type of the message that was read (sitalMessageType_*).
///   - The data words are stored right after the longest possible message block, that is, starting at offset sitalBcMaximum_ACTUAL_MESSAGE_BLOCK.
///     In case of a mode code message with data, this data word is returned as the first (actually the single) data word.
///   - Message data is copied under assumption that the expected number of data words has been actually received, what the caller may verify by checking the block status.
///
/// Equivalent DDC definition: aceBCGetHBufMsgsRaw
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wapBuffer (out)	A pointer to a buffer in which the raw messages are stored
/// @param wBufferSize (in)	The size (in words) of the data buffer that is pointed by wapBuffer (>0)
/// @param dwpMessageCount (out)	A pointer to a variable in which the number of retrieved messages (>=0) is returned
/// @param dwpLostMessageCount (out)	A pointer to a variable in which the host buffer's current number of lost messages is returned
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
S16BIT _DECL sitalBc_HostBuffer_Message_GetRaw (	S16BIT swDevice,
													U16BIT* wapBuffer,
													U16BIT wBufferSize,
													U32BIT* dwpMessageCount,
													U32BIT* dwpLostMessageCount)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((((U16BIT*)NULL) == wapBuffer) || (((U32BIT*)NULL) == dwpMessageCount) || (((U32BIT*)NULL) == dwpLostMessageCount))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if (sitalBcMaximum_MESSAGE_SIZE > wBufferSize)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	HostBufferStructure* hbspHostBuffer; // A host buffer structure.
	hbspHostBuffer = (HostBufferStructure*)&(dsspDeviceState->bsBcState.hbsHostBuffer);
	if (0U == hbspHostBuffer->dwHostBufferSize)
	{
		return sitalReturnCode_HOST_BUFFER_NOT_INSTALLED;
	}

	/// Zero given buffer.
	memset ((void*)wapBuffer, (int)0, (size_t)(wBufferSize << 1U));

	///	Set the returned count of lost messages.
	(*dwpLostMessageCount) = hbspHostBuffer->dwLostMessageCount;

	/// Zero the count of returned messages.
	/// While there are more unread messages in the host buffer and there's still place for another message in given buffer:
	///		Copy another message from the host buffer to given buffer.
	///		Point to the place in given buffer where the next message should be stored, if at all.
	///		Decrement the size of the buffer to reflect the remaining size.
	///		Increment the count of raw messages that have been copied.
	///		Purge the message that was just read from the host buffer.
	///		Increment the count of returned messages.
	(*dwpMessageCount) = 0U;
	while ((0U < hbspHostBuffer->dwMessageCount) && (sitalBcMaximum_MESSAGE_SIZE <= wBufferSize))
	{
		void* vp; // A pointer to a void.
		vp = memcpy (wapBuffer, (hbspHostBuffer->waBuffer + hbspHostBuffer->dwOffsetOfNextMessageToWrite), (sitalBcMaximum_MESSAGE_SIZE << 1U));

		wapBuffer += sitalBcMaximum_MESSAGE_SIZE;
		wBufferSize -= sitalBcMaximum_MESSAGE_SIZE;

		hbspHostBuffer->dwOffsetOfNextMessageToRead += sitalBcMaximum_MESSAGE_SIZE;
		hbspHostBuffer->dwOffsetOfNextMessageToRead = ( (hbspHostBuffer->dwHostBufferSize == hbspHostBuffer->dwOffsetOfNextMessageToRead) ? 0 : hbspHostBuffer->dwOffsetOfNextMessageToRead );

		hbspHostBuffer->dwMessageCount--;

		(*dwpMessageCount)++;
	}

	///	If the returned message should be purged and configured to collect operational statistics for given device:
	///		Update the fullness statistics for given device.
	if ((0U < (*dwpMessageCount)) && (TRUE == dsspDeviceState->bIsOperationalStatisticsCollected))
	{
		hbspHostBuffer->wFullnessPercentage = (U16BIT)( (double)100.0 * (double)(((hbspHostBuffer->dwOffsetOfNextMessageToRead > hbspHostBuffer->dwOffsetOfNextMessageToWrite) ? hbspHostBuffer->dwHostBufferSize : 0U) + hbspHostBuffer->dwOffsetOfNextMessageToWrite - hbspHostBuffer->dwOffsetOfNextMessageToRead) / ((double)(hbspHostBuffer->dwHostBufferSize)) );
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Return performance information about the host buffer of given BC device.
///
/// Equivalent DDC definition: aceBCGetHBufMetric
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param hbosspHostBufferOperationalStatistics (out)	A pointer to the host buffer operational statistics structure into which the required operational statistics are written
/// @param bIsResetOfHighestRecordedPercentageRequired (in)	A flag that says whether the record of the highest percentage reached by now should be reset
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalBc_HostBuffer_GetOperationalStatistics (S16BIT swDevice, sitalHostBufferOperationalStatisticsStructure* hbosspHostBufferOperationalStatistics, U16BIT bIsResetOfHighestRecordedPercentageRequired)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (((sitalHostBufferOperationalStatisticsStructure*)NULL) == hbosspHostBufferOperationalStatistics)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if (FALSE == dsspDeviceState->bIsOperationalStatisticsCollected)
	{
		return sitalReturnCode_OPERATIONAL_STATISTICS_NOT_ENABLED;
	}

	HostBufferStructure* hbspHostBuffer; // A host buffer structure.
	hbspHostBuffer = (HostBufferStructure*)&(dsspDeviceState->bsBcState.hbsHostBuffer);
	if (0U == hbspHostBuffer->dwHostBufferSize)
	{
		return sitalReturnCode_HOST_BUFFER_NOT_INSTALLED;
	}

	if ((U16BIT)0U != bIsResetOfHighestRecordedPercentageRequired)
	{
		hbspHostBuffer->wMaximumFullnessPercentage = 0U;
	}

	return sitalReturnCode_SUCCESS;
}

S16BIT _DECL sitalBc_Set_Error(U16BIT swDevice, U16BIT wErrorType, U16BIT wMessageNumber, U16BIT wWordNumber, U16BIT wInjectionParameters, S16BIT wZXDistortion)
{
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}
	
	// Validate that is in BC mode
	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_BC != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

		if ((sitalAccess_CARD != dsspDeviceState->wAccess) && (sitalAccess_USER != dsspDeviceState->wAccess))
	{
		return sitalReturnCode_INVALID_ACCESS;
	}

	if (wMessageNumber < mrt_MSG_NUMBER_MIN || wMessageNumber > mrt_MSG_NUMBER_MAX)
		return sitalReturnCode_MESSGE_NUMBER_TO_INSERT_ERROR_IS_INVALID;

	if (wWordNumber < mrt_WORD_NUMBER_MIN || wWordNumber > mrt_WORD_NUMBER_MAX)
		return sitalReturnCode_WORD_NUMBER_TO_INSERT_ERROR_IS_INVALID;

	U16BIT errType = 0;
	S16BIT errParams = 0;
	switch(wErrorType)
	{
		case NO_ERROR_SPEC:
			return sitalReturnCode_NO_ERROR_SPECIFIED;
		case PARITY_ERROR:
			errType = (PARITY_ERROR | (wMessageNumber << 8) | (wWordNumber & 0x3F));
			break;
		case BIPHASE_ERROR:
			errType = (BIPHASE_ERROR | (wMessageNumber << 8) | (wWordNumber & 0x3F));
			errParams = (wInjectionParameters << 8);
			break;
		case SYNC_ERROR:
			if ((wInjectionParameters < mrt_SYNC_ERR_MIN || wInjectionParameters > mrt_SYNC_ERR_MAX) && wInjectionParameters != mrt_SYNC_INVERT)
				return sitalReturnCode_SYNC_INJECTION_PARAM_INVALID;
			errType = (SYNC_ERROR | (wMessageNumber << 8) | (wWordNumber & 0x3F));
			errParams = (wInjectionParameters << 8);
			break;
		case ZERO_CROSSING_ERROR:
			if (wZXDistortion < mrt_ZX_DISTORTION_MIN || wZXDistortion > mrt_ZX_DISTORTION_MAX)
				return sitalReturnCode_ZERO_CROSSING_INJECTION_PARAM_INVALID;
			errType = (ZERO_CROSSING_ERROR | (wMessageNumber << 8) | (wWordNumber & 0x3F));
			errParams = ((wInjectionParameters << 8) | (wZXDistortion & 0x3F));
			break;
		default:
			return sitalReturnCode_SPECIFIED_ERROR_INJECTION_NOT_SUPPORTED;
	}
	sitalBc_SetErrors(swDevice, errType, errParams);

	return sitalReturnCode_SUCCESS;
}

S16BIT _DECL sitalBc_SetErrors (U16BIT swDevice, U16BIT wErrorType, U16BIT wErrorParams)
{
	// Internal implementation verifies the correct running mode and updating the registers accordingly
	S16BIT results = sitalDevice_Register_Write(swDevice, sitalRegisterAddress_ERRORINJ1, wErrorType);
	if (results != sitalReturnCode_SUCCESS)
	{
		return results;
	}
	results = sitalDevice_Register_Write(swDevice, sitalRegisterAddress_ERRORINJ2, wErrorParams);
	return results;	
}


/*

---------------------------------------------------------------------------------------------------
***************************************************************************************************
---------------------------------------------------------------------------------------------------
	Multi RT functions
---------------------------------------------------------------------------------------------------
***************************************************************************************************
---------------------------------------------------------------------------------------------------

 	Initialize device as a mRT with initialization options. 
 	Release any past allocations of device memory. 
 	Reset all SW pointers.
*/
_EXTERN S16BIT _DECL sital_mRt_Initialize (U16BIT swDevice, U32BIT dwOptions)
{	
	/*
	- Verify validity of function params
	- reset device 
	- Reset all pointer in host 
	- Reset configurations in host
	- Set options
	*/
	//Verify validity of function params
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalMode_MRT != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalAccess_CARD != dsspDeviceState->wAccess) && (sitalAccess_USER != dsspDeviceState->wAccess))
	{
		return sitalReturnCode_INVALID_ACCESS;
	}

	U16BIT value;
	sitalDevice_AccessMemory(swDevice, sitalDeviceAccessOperation_Read, sitalRegisterAddress_MRT_CODE, sitalDeviceMemorySection_Registers, 1, &value);
	if(value != sitalRegisterVALUE_MRT_CODE)
		return sitalReturnCode_MRT_CODE_IN_REG_1A_INCORRECT;
	//reset device 
	//swResult = device_Register_UpdateImage (swDevice, sitalRegisterAddress_MRT_TIME_TAG_LSB, registerMask_ALL_BITS_ON, tempTimeVal);
	U16BIT wRegisterValue = sitalStartResetRegister_MRT_RESET;
	S16BIT Result = sitalDevice_AccessMemory (swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_MRT_START_RESET, sitalDeviceMemorySection_Registers, sitalStartResetRegister_MRT_RESET, &wRegisterValue);
	mrtDeviceStructDB[swDevice].RunningBusList = -1;

	//Reset configurations in host (the registers in the device where HW reset)
	for(int j = 0; j < 32 ; j++)
	{
		mrtDeviceStructDB[swDevice].Registers[j] = 0;
	}

	// Set options - TBD

	return Result;
}

/*
 	Create a buslist of buslist elements. 
 	Each buslist element handles a 1553 message.
*/
_EXTERN S16BIT _DECL sital_mRt_Create_BusList (U16BIT wBusList)
{
	if(mrtBusListStructDB[wBusList].Mode != UnInitialized)
		return sitalReturnCode_BUSLIST_ALREADY_EXISTS;
	
	mrtBusListStructDB[wBusList].Mode = Ready;
	mrtBusListStructDB[wBusList].RunningOnDeviceID = -1;// During runtiem, indicates which buslist is running.
	mrtBusListStructDB[wBusList].NumOfElements = 0;

	return sitalReturnCode_SUCCESS;
}

/*
 	Create a buslist element in a given buslist. 
 	Return index of element in the buslist.
*/
_EXTERN S16BIT _DECL sital_mRt_Create_BusList_Element (U16BIT wElement, U16BIT wCommand, U16BIT wOptions)
{
	if(mrtElementsStructDB[wElement].Mode != UnInitialized)
		return sitalReturnCode_ELEMENT_ALREADY_EXISTS;
	
	mrtElementsStructDB[wElement].Mode = Ready;
//	mrtElementsStructDB[wElement].BusListID = -1;// Mapping will couple this element to a specific buslist
	mrtElementsStructDB[wElement].DataBlock_IsMapped = FALSE;
	mrtElementsStructDB[wElement].Options = wOptions;
	mrtElementsStructDB[wElement].Command_1553 = wCommand;
	mrtElementsStructDB[wElement].ElementAddress = -1;

	return sitalReturnCode_SUCCESS;
}

/*
    Create a memory data block in the desired size for the specified buslist entry.
    Element is a number.
    memory size is in the size of 0 to 7.
*/
_EXTERN S16BIT _DECL sital_mRt_Create_Element_DataBlock (U16BIT wDataBlock, U16BIT wDataBlockMode, U16BIT* wBuffer, U16BIT wBufferSize)
{
	if (mrtDataBlockStructDB[wDataBlock].Mode != UnInitialized)
		return sitalReturnCode_DATABLOCK_ALREADY_EXISTS;
	
	/* The possible Datablock sizes constants.
	#define sital_mRt_DataBlockMode_32_WORDS	0x0000U	//R/W
	#define sital_mRt_DataBlockMode_64_WORDS 	0x0010U	//R/W
	#define sital_mRt_DataBlockMode_256_WORDS	0x0020U	//R/W
	#define sital_mRt_DataBlockMode_1K_WORDS	0x0030U	//R/W
	#define sital_mRt_DataBlockMode_4K_WORDS	0x0040U	//R/W
	#define sital_mRt_DataBlockMode_16K_WORDS	0x0050U	//R/W
	#define sital_mRt_DataBlockMode_RESERVED	0x0060U	//R/W
	#define sital_mRt_DataBlockMode_GLOBAL		0x0070U	//R/W
	*/

	if (((wDataBlockMode >> 4) % 16)  > 7)
		return sitalReturnCode_DATABLOCK_SIZE_ASSINGMENT_ERROR;
	if(( wDataBlockMode == sital_mRt_DataBlockMode_32_WORDS	&& wBufferSize < 64)	
	|| ( wDataBlockMode == sital_mRt_DataBlockMode_64_WORDS	&& wBufferSize < 64)
	|| ( wDataBlockMode == sital_mRt_DataBlockMode_256_WORDS	&& wBufferSize < 256)
	|| ( wDataBlockMode == sital_mRt_DataBlockMode_1K_WORDS	&& wBufferSize < 1024)
	|| ( wDataBlockMode == sital_mRt_DataBlockMode_4K_WORDS	&& wBufferSize < 4096)
	|| ( wDataBlockMode == sital_mRt_DataBlockMode_16K_WORDS	&& wBufferSize < 16384))
		return sitalReturnCode_DATABLOCK_SIZE_TOO_SMALL;
		
	mrtDataBlockStructDB[wDataBlock].Mode = Ready;
	mrtDataBlockStructDB[wDataBlock].ElementID = -1;
	mrtDataBlockStructDB[wDataBlock].DataBLockLength = wDataBlockMode;
	mrtDataBlockStructDB[wDataBlock].Data = wBuffer;
	//mrtDataBlockStructDB[wDataBlock].SWOffsetPointer = 0;
	mrtDataBlockStructDB[wDataBlock].DeviceIdRunningOn = -1;
	
	return sitalReturnCode_SUCCESS;
}

_EXTERN S16BIT _DECL sital_mRt_Map_DataBlock_To_Element (U16BIT wElement, U16BIT wDataBlock)
{
	if(mrtElementsStructDB[wElement].Mode != Ready || mrtDataBlockStructDB[wDataBlock].Mode != Ready)
		return sitalReturnCode_MAPPING_UNREADY_CONSTRUCTS;

	mrtElementsStructDB[wElement].DataBlockID = wDataBlock;
	mrtElementsStructDB[wElement].DataBlock_IsMapped = true;
	//mrtDataBlockStructDB[wDataBlock].ElementID = wElement;

	return sitalReturnCode_SUCCESS;
}

_EXTERN S16BIT _DECL sital_mRt_Map_Element_To_BusList (U16BIT wBusList, U16BIT wElement)
{
	if(mrtElementsStructDB[wElement].Mode != Ready || mrtBusListStructDB[wBusList].Mode != Ready)
		return sitalReturnCode_MAPPING_UNREADY_CONSTRUCTS;
	if(mrtBusListStructDB[wBusList].NumOfElements > MAX_ELEMENTS_PER_BUSLIST -1)
		return sitalReturnCode_BUSLIST_CONTAINS_TOO_MANY_ELEMENTS;

	mrtBusListStructDB[wBusList].Elements[mrtBusListStructDB[wBusList].NumOfElements] = wElement;
	mrtBusListStructDB[wBusList].NumOfElements++;

	return sitalReturnCode_SUCCESS;
}

U16BIT _DECL CalcNextHwPointer(U16BIT dbAddress, U16BIT dataBLockLength)
{
	switch(dataBLockLength)
	{
	// NB 16.9.2014 bug fix - taking under account double buffering
	case sital_mRt_DataBlockMode_32_WORDS	: return (dbAddress + 64) & 0xFFC0;
	case sital_mRt_DataBlockMode_64_WORDS	: return (dbAddress + 64) & 0xFFC0;
	case sital_mRt_DataBlockMode_256_WORDS	: return (dbAddress + 256) & 0xFF00;
	case sital_mRt_DataBlockMode_1K_WORDS	: return (dbAddress + 1024) & 0xFC00;
	case sital_mRt_DataBlockMode_4K_WORDS	: return (dbAddress + 4096) & 0xF000;
	case sital_mRt_DataBlockMode_16K_WORDS	: return (dbAddress + 4096 * 4) & 0xC000;
	case sital_mRt_DataBlockMode_RESERVED	: return dbAddress;
	case sital_mRt_DataBlockMode_GLOBAL		: return dbAddress;
	default: return dbAddress;
	}
}

/*
 	Set mRT device start handling messages. 
*/
_EXTERN S16BIT _DECL sital_mRt_Start (U16BIT swDevice, U16BIT wBusList)
{
	/*
	TODO - Make sure that the dynamic mem allocation for the elements does not overflows the available memory of the specified device.

	- Check that the device is ready
	- Check that the buslist is ready
	- Update device and buslist states as running
	- Build buslist of elements into memory
	- Build datablocks in memory
	- Load all registers (Start register NOT included)
	- Write to start register START command
	*/
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	// Validate that is in MRT mode
	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_MRT != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_RUN != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((sitalAccess_CARD != dsspDeviceState->wAccess) && (sitalAccess_USER != dsspDeviceState->wAccess))
	{
		return sitalReturnCode_INVALID_ACCESS;
	}

	if(mrtDeviceStructDB[swDevice].RunningBusList != -1 || mrtBusListStructDB[wBusList].Mode != Ready)
		return sitalReturnCode_BUSLIST_IS_RUNNING;

	mrtDeviceStructDB[swDevice].RunningBusList = wBusList;
	mrtBusListStructDB[wBusList].Mode = Running;

	U16BIT blAddress = 0; // Buslist address of where to update buslist elements' data
	U16BIT dbAddress = 1024 -16; //Datablocks address of where to update datablocks with physical address
	U16BIT nextdbAddress = 1024 + 32;
	U16BIT currentElement; 
	U16BIT currentDataBlock; 
	S16BIT result ;
	U32BIT deviceMemLimit = dsspDeviceState->dcsDeviceCapabilities.dwRamSize;
	//Build buslist of elements into memory
	for (int i = 0; i < mrtBusListStructDB[wBusList].NumOfElements ; i++)
	{
		currentElement = mrtBusListStructDB[wBusList].Elements[i];
		currentDataBlock = mrtElementsStructDB[currentElement].DataBlockID;
		
		// In case that datablock is not mapped, fail the start.
		if (currentDataBlock == -1)
			return sitalReturnCode_DATABLOCK_NOT_MAPPED_TO_ELEMENT;
		// In case that element is not mapped, fail the start.
		if (currentElement == -1)
			return sitalReturnCode_ELEMENT_NOT_MAPPED_TO_BUSLIST;

		mrtElementsStructDB[mrtBusListStructDB[wBusList].Elements[i]].ElementAddress = blAddress;
		// Control word
		WMem(swDevice, blAddress, mrtElementsStructDB[currentElement].Options | mrtDataBlockStructDB[currentDataBlock].DataBLockLength);
		blAddress++;
		// Time Tag - not required
		blAddress++;
		// Data Pointer
		if(mrtDataBlockStructDB[currentDataBlock].Mode == Running)
			{
				mrtElementsStructDB[mrtBusListStructDB[wBusList].Elements[i]].HWPointer = mrtDataBlockStructDB[currentDataBlock].HWPointer;
				//Write Data pointer to memory location + 2
				WMem(swDevice, blAddress, mrtDataBlockStructDB[currentDataBlock].HWPointer);
			}
		else
			{
				nextdbAddress =  CalcNextHwPointer(dbAddress, mrtDataBlockStructDB[currentDataBlock].DataBLockLength);
				if(nextdbAddress >= deviceMemLimit)
					return sitalReturnCode_DEVICE_MEMORY_FULL;
				mrtElementsStructDB[mrtBusListStructDB[wBusList].Elements[i]].HWPointer = nextdbAddress;
				//Write Data pointer to memory location + 2
				WMem(swDevice, blAddress, nextdbAddress);
				mrtDataBlockStructDB[currentDataBlock].Mode = Running;
				mrtDataBlockStructDB[currentDataBlock].HWPointer = nextdbAddress;
				mrtDataBlockStructDB[currentDataBlock].DeviceIdRunningOn = swDevice;
			}
		blAddress++;
		// Command
		WMem(swDevice, blAddress, mrtElementsStructDB[currentElement].Command_1553);
		blAddress++;

		// Mark constrcuts as running
		mrtElementsStructDB[currentElement].Mode = Running;		
		
		//mrtDataBlockStructDB[currentDataBlock].SWOffsetPointer /* SW pointer was previously incremented during ready mode when the buffer was written to. thus it is not updated in this stage. */

		// Add data to block.
		result =  DumpHostToDevice(swDevice, mrtDataBlockStructDB[currentDataBlock].Data, mrtDataBlockStructDB[currentDataBlock].HWPointer,
								   MemModeToLength(mrtDataBlockStructDB[currentDataBlock].DataBLockLength), MemModeToLength(mrtDataBlockStructDB[currentDataBlock].DataBLockLength));
		dbAddress = nextdbAddress;
	}
	mrtDeviceStructDB[swDevice].Registers[sitalRegisterAddress_MRT_COMMAND_LIST_LENGTH] = mrtBusListStructDB[wBusList].NumOfElements;
	mrtDeviceStructDB[swDevice].Registers[sitalRegisterAddress_MRT_COMMAND_LIST_POINTER] = 0;

	// Load all registers (Start register NOT included)
	WReg(swDevice, sitalRegisterAddress_MRT_INTERRUPT_ENABLE_REGISTER_1, mrtDeviceStructDB[swDevice].Registers[sitalRegisterAddress_MRT_INTERRUPT_ENABLE_REGISTER_1 % 32]);

	WReg(swDevice, sitalRegisterAddress_MRT_CONFIGURATION_REGISTER, mrtDeviceStructDB[swDevice].Registers[sitalRegisterAddress_MRT_CONFIGURATION_REGISTER % 32]);
	
	WReg(swDevice, sitalRegisterAddress_MRT_RT15_TO_0_ENABLE, mrtDeviceStructDB[swDevice].Registers[sitalRegisterAddress_MRT_RT15_TO_0_ENABLE % 32]);
	
	WReg(swDevice, sitalRegisterAddress_MRT_RT30_TO_16_ENABLE, mrtDeviceStructDB[swDevice].Registers[sitalRegisterAddress_MRT_RT30_TO_16_ENABLE % 32]);
	
	WReg(swDevice, sitalRegisterAddress_MRT_COMMAND_LIST_POINTER, mrtDeviceStructDB[swDevice].Registers[sitalRegisterAddress_MRT_COMMAND_LIST_POINTER % 32]);
	
	WReg(swDevice, sitalRegisterAddress_MRT_COMMAND_LIST_LENGTH, mrtDeviceStructDB[swDevice].Registers[sitalRegisterAddress_MRT_COMMAND_LIST_LENGTH % 32]);
	
	WReg(swDevice, sitalRegisterAddress_MRT_GLOBAL_RX_DATA_POINTER, mrtDeviceStructDB[swDevice].Registers[sitalRegisterAddress_MRT_GLOBAL_RX_DATA_POINTER % 32]);
	
	WReg(swDevice, sitalRegisterAddress_MRT_GLOBAL_TX_DATA_POINTER, mrtDeviceStructDB[swDevice].Registers[sitalRegisterAddress_MRT_GLOBAL_TX_DATA_POINTER % 32]);
	
	WReg(swDevice, sitalRegisterAddress_MRT_ERROR_DEFINITION, mrtDeviceStructDB[swDevice].Registers[sitalRegisterAddress_MRT_ERROR_DEFINITION % 32]);
	
	WReg(swDevice, sitalRegisterAddress_MRT_ERROR_PARAMETERS, mrtDeviceStructDB[swDevice].Registers[sitalRegisterAddress_MRT_ERROR_PARAMETERS % 32]);
	
	// Write to start register START command
	WReg(swDevice, sitalRegisterAddress_MRT_START_RESET, sitalStartResetRegister_MRT_START);

	// Validate that the HW is set to running successfully
	U16BIT isActive;
	RReg(swDevice, sitalRegisterAddress_MRT_CONFIGURATION_REGISTER, &isActive);
	if ((isActive & sitalConfigurationRegister1_MRT_ACTIVE) != sitalConfigurationRegister1_MRT_ACTIVE)
	{ // still active
		return sitalReturnCode_MRT_START_RUN_FAILED;		
	}	
	return sitalReturnCode_SUCCESS;
}

// This function copies data from source address to destination adress (typically between host and device).
// The copy increment is subject to the cyclic mode of the block / buffer
S16BIT _DECL DumpHostToDevice(U16BIT swDevice, U16BIT* AddSource, U16BIT AddDestination, U16BIT BufferLength, U16BIT iterations)
{
	S16BIT result = sitalReturnCode_SUCCESS; 
	U32BIT destinationAddress_LSBs = (U32BIT)AddDestination % BufferLength; 
	U32BIT destinationAddress_MSBs = (U32BIT)(AddDestination - destinationAddress_LSBs); 
	
	for (U16BIT i = 0 ; i < iterations ; i++)
	{
		result = sitalDevice_AccessMemory (swDevice, sitalDeviceAccessOperation_Write, destinationAddress_LSBs + destinationAddress_MSBs, sitalDeviceMemorySection_Ram, 1, AddSource + (i % BufferLength));
		destinationAddress_LSBs = (destinationAddress_LSBs + 1) % BufferLength;
		if(result < 0 )
			return result;
	}
	return result;
}

// This function copies data from source address to destination adress (typically between host and device).
// The copy increment is subject to the cyclic mode of the block / buffer
S16BIT _DECL DumpDeviceToHost(U16BIT swDevice, U16BIT AddSource, U16BIT* AddDestination, U16BIT BufferLength, U16BIT iterations)
{
	S16BIT result = sitalReturnCode_SUCCESS; 

//	U32BIT sourceAddress_LSBs = (U32BIT)AddDestination % BufferLength;
//	U32BIT sourceAddress_MSBs = (U32BIT)(AddDestination - sourceAddress_LSBs);

	U64BIT sourceAddress_LSBs = (U64BIT)AddDestination % BufferLength;
	U64BIT sourceAddress_MSBs = (U64BIT)(AddDestination - sourceAddress_LSBs);
	
	for (U16BIT i = 0 ; i < iterations ; i++)
	{
		result = sitalDevice_AccessMemory (swDevice, sitalDeviceAccessOperation_Read, sourceAddress_LSBs + sourceAddress_MSBs, sitalDeviceMemorySection_Ram, 1, AddDestination + (i % BufferLength));
		sourceAddress_LSBs = (sourceAddress_MSBs + 1) % BufferLength;
		if(result < 0 )
			return result;
	}
	return result;
}

S16BIT _DECL MemModeToLength(U16BIT Mode)
{
	switch(Mode)
	{
		case sital_mRt_DataBlockMode_32_WORDS	: return 32;
		case sital_mRt_DataBlockMode_64_WORDS	: return 64 ;
		case sital_mRt_DataBlockMode_256_WORDS	: return 256;
		case sital_mRt_DataBlockMode_1K_WORDS	: return 1024;
		case sital_mRt_DataBlockMode_4K_WORDS	: return 4096;
		case sital_mRt_DataBlockMode_16K_WORDS	: return 4096 * 4;
		case sital_mRt_DataBlockMode_RESERVED	: return 4096 * 4;
		case sital_mRt_DataBlockMode_GLOBAL		: return 32; // TODO - revisit Global mode	
	}
	return sitalReturnCode_DATABLOCK_SIZE_ASSINGMENT_ERROR;
}


S16BIT _DECL WMem(U16BIT swDevice, U16BIT Address, U16BIT Data)
{
	S16BIT result = sitalDevice_AccessMemory (swDevice, sitalDeviceAccessOperation_Write, Address, sitalDeviceMemorySection_Ram, 1, &Data);
	
	return result;
}

S16BIT _DECL WReg(U16BIT swDevice, U16BIT Address, U16BIT Data)
{
	S16BIT result = sitalDevice_AccessMemory (swDevice, sitalDeviceAccessOperation_Write, Address, sitalDeviceMemorySection_Registers, 1, &Data);
	
	return result;
}

S16BIT _DECL RMem(U16BIT swDevice, U16BIT Address, U16BIT* Data)
{
	S16BIT result = sitalDevice_AccessMemory (swDevice, sitalDeviceAccessOperation_Read, Address, sitalDeviceMemorySection_Ram, 1, Data);
	
	return result;
}

S16BIT _DECL RReg(U16BIT swDevice, U16BIT Address, U16BIT* Data)
{
	S16BIT result = sitalDevice_AccessMemory (swDevice, sitalDeviceAccessOperation_Read, Address, sitalDeviceMemorySection_Registers, 1U, Data);
	
	return result;
}

S16BIT _DECL RBar2(U16BIT card, U16BIT Address, U32BIT Length, U32BIT* Data)
{
	return sitalCard_Read_Bar2(card, Address, Length, Data);
}

_EXTERN S16BIT _DECL MemTest(U16BIT swDevice, U16BIT startAddress, U16BIT endAddress, U16BIT* pass, U16BIT* errorAddress)
{
	// Fill mem from start address to end address with incremental data
	// Read mem from start address to end address and check correct data
	S16BIT result = 0;
	for(U32BIT address = startAddress ; address <= endAddress ; address++)
	{
		result += WMem(swDevice, address, address);
	}
	if(result < 0)
		return result;

	U16BIT data;
	for(U16BIT address = startAddress ; address <= endAddress ; address++)
	{
		result += RMem(swDevice, address, &data);
		if(data != address)
		{
			*pass = 0;
			*errorAddress = address;
			return result;
		}
	}
	*pass = 1;
	*errorAddress = 0;
	return result;
}

/*
 	Write a block of data to a bus element.
 	This function verifies the memory management mode and updates the data accordingly.
*/
_EXTERN S16BIT _DECL sital_mRt_Element_DataBlock_Write (U16BIT wElement, U16BIT wDataBlock, U16BIT* wBuffer, U16BIT wBufferSize)
{

	/*TODO - 
	- Read the 1553 command
	- Allow datablock write for Tx command's datablocks. Do not allow for Rx commands - return error
	*/
	/*
	- Verify datablock is initialized
	- Verify Element is initialized
	- Verify that Datablock is mapped to the specified Element	
	*/
	//Verify datablock is initialized
	if(mrtDataBlockStructDB[wDataBlock].Mode == UnInitialized)
		return sitalReturnCode_MRT_WRITING_TO_UNINITIALIZED_DATABLOCK;

	//Verify Element is initialized
	if(mrtElementsStructDB[wElement].Mode == UnInitialized)
		return sitalReturnCode_MRT_WRITING_TO_UNINITIALIZED_ELEMENT;

	//Verify that Datablock is mapped to the specified Element
	if(!mrtElementsStructDB[wElement].DataBlock_IsMapped || mrtElementsStructDB[wElement].DataBlockID != wDataBlock)
		return sitalReturnCode_MRT_WRITING_TO_UNMAPPED_DATABLOCK;
	U16BIT* swPointer = mrtDataBlockStructDB[wDataBlock].Data;

	/*
	- processing for Mode = ready:
		- Go to the Host buffer
		- Copy wBuffer to Datablock's data
		- Update SW offset pointer	
	*/
	//processing for Mode = ready:
	if(mrtDataBlockStructDB[wDataBlock].Mode == Ready)
	{
		switch(mrtDataBlockStructDB[wDataBlock].DataBLockLength)
			{
				case sital_mRt_DataBlockMode_32_WORDS:  
				case sital_mRt_DataBlockMode_64_WORDS:  
					{
						if(wBufferSize > 32)
							return sitalReturnCode_DATABLOCK_SIZE_TOO_SMALL;
						for (U16BIT i = 0 ; i < wBufferSize ; i++)
						{
							swPointer[i] = wBuffer[i];
						}
						// In this mode, the SW offset pointer points to the beginning (0) of the data
						mrtElementsStructDB[wElement].SWOffsetPointer = 0;
						break;
					}
					
				case sital_mRt_DataBlockMode_256_WORDS:  
					{
						if(wBufferSize > 256)
							return sitalReturnCode_DATABLOCK_SIZE_TOO_SMALL;
						// In ready mode the hardware pointer should remain in 0.
						mrtDataBlockStructDB[wDataBlock].HWPointer = 0;
						for (U16BIT i = 0 ; i < wBufferSize ; i++)
						{
							swPointer[mrtElementsStructDB[wElement].SWOffsetPointer] = wBuffer[i];
							mrtElementsStructDB[wElement].SWOffsetPointer = (mrtElementsStructDB[wElement].SWOffsetPointer++) % 256; 
						}
						break;
					}
				case sital_mRt_DataBlockMode_1K_WORDS:  
					{
						if(wBufferSize > 1024)
							return sitalReturnCode_DATABLOCK_SIZE_TOO_SMALL;
						// In ready mode the hardware pointer should remain in 0.
						mrtDataBlockStructDB[wDataBlock].HWPointer = 0;
						for (U16BIT i = 0 ; i < wBufferSize ; i++)
						{
							swPointer[mrtElementsStructDB[wElement].SWOffsetPointer] = wBuffer[i];
							mrtElementsStructDB[wElement].SWOffsetPointer = (mrtElementsStructDB[wElement].SWOffsetPointer++) % 1024; 
						}
						break;
					}
				case sital_mRt_DataBlockMode_4K_WORDS:  
					{
						if(wBufferSize > 1024 * 4)
							return sitalReturnCode_DATABLOCK_SIZE_TOO_SMALL;
						// In ready mode the hardware pointer should remain in 0.
						mrtDataBlockStructDB[wDataBlock].HWPointer = 0;
						for (U16BIT i = 0 ; i < wBufferSize ; i++)
						{
							swPointer[mrtElementsStructDB[wElement].SWOffsetPointer] = wBuffer[i];
							mrtElementsStructDB[wElement].SWOffsetPointer = (mrtElementsStructDB[wElement].SWOffsetPointer++) % (1024 * 4 ); 
						}
						break;
					}
				case sital_mRt_DataBlockMode_16K_WORDS:  
					{
						if(wBufferSize > 1024 * 16)
							return sitalReturnCode_DATABLOCK_SIZE_TOO_SMALL;
						// In ready mode the hardware pointer should remain in 0.
						mrtDataBlockStructDB[wDataBlock].HWPointer = 0;
						for (U16BIT i = 0 ; i < wBufferSize ; i++)
						{
							swPointer[mrtElementsStructDB[wElement].SWOffsetPointer] = wBuffer[i];
							mrtElementsStructDB[wElement].SWOffsetPointer = (mrtElementsStructDB[wElement].SWOffsetPointer++) % (1024 * 16 ); 
						}
						break;
					}
				default:  
					{
						return sitalReturnCode_FUNCTION_NOT_IMPLEMENTED;
					}
			}
	}
	/*
	processing for Mode = running:
		- Go to the Device buffer
		- Copy wBuffer to Datablock's data
		- Update SW pointer
	*/

	//processing for Mode = running:
	if(mrtDataBlockStructDB[wDataBlock].Mode == Running)
	{
		if(mrtDataBlockStructDB[wDataBlock].DeviceIdRunningOn < 0)
			return sitalReturnCode_MRT_ACCESSING_INVALID_DEVICE_ID;

		U16BIT actualDevice_HWPointer;
		RMem(mrtDataBlockStructDB[wDataBlock].DeviceIdRunningOn, mrtElementsStructDB[wElement].ElementAddress + 2, &actualDevice_HWPointer);
		U16BIT target_HWPointer = (actualDevice_HWPointer ^ 0x0020) & 0xFFE0;
		U16BIT ad = target_HWPointer;

		switch(mrtDataBlockStructDB[wDataBlock].DataBLockLength)
			{
				case sital_mRt_DataBlockMode_32_WORDS:  
					{
						if(wBufferSize > 32)
							return sitalReturnCode_DATABLOCK_SIZE_TOO_SMALL;

						for (U16BIT i = 0 ; i < wBufferSize ; i++)
						{
							WMem(mrtDataBlockStructDB[wDataBlock].DeviceIdRunningOn, ad, wBuffer[i]);
							ad++;
						}
						// In this mode the SW swaps bit 6 of the pointer on each successfull completion of write
						WMem(mrtDataBlockStructDB[wDataBlock].DeviceIdRunningOn, (mrtElementsStructDB[wElement].ElementAddress + 2), (target_HWPointer & 0xFFE0));
						break;
					}
				case sital_mRt_DataBlockMode_64_WORDS:  
					{
						if(wBufferSize > 32)
							return sitalReturnCode_DATABLOCK_SIZE_TOO_SMALL;

						for (U16BIT i = 0 ; i < wBufferSize ; i++)
						{
							WMem(mrtDataBlockStructDB[wDataBlock].DeviceIdRunningOn, target_HWPointer, wBuffer[i]);
							target_HWPointer++;
						}
						// In this mode the hardware swaps bit 6 of the pointer on each successfull completion of message
						break;
					}
				case sital_mRt_DataBlockMode_256_WORDS:  
					{
						if(wBufferSize > 256)
							return sitalReturnCode_DATABLOCK_SIZE_TOO_SMALL;
						DumpHostToDevice(mrtDataBlockStructDB[wDataBlock].DeviceIdRunningOn, wBuffer, mrtElementsStructDB[wElement].SWOffsetPointer + mrtDataBlockStructDB[wDataBlock].HWPointer, 256, wBufferSize);
						// In this mode the SW pointer is incremented by the buffer size cyclically.
						mrtElementsStructDB[wElement].SWOffsetPointer = CyclicIncrement(mrtElementsStructDB[wElement].SWOffsetPointer, wBufferSize, 256);				
						break;
					}
				case sital_mRt_DataBlockMode_1K_WORDS:  
					{
						if(wBufferSize > 256 * 4)
							return sitalReturnCode_DATABLOCK_SIZE_TOO_SMALL;
						DumpHostToDevice(mrtDataBlockStructDB[wDataBlock].DeviceIdRunningOn, wBuffer, mrtElementsStructDB[wElement].SWOffsetPointer + mrtDataBlockStructDB[wDataBlock].HWPointer, 256 * 4, wBufferSize);
						// In this mode the SW pointer is incremented by the buffer size cyclically.
						mrtElementsStructDB[wElement].SWOffsetPointer = CyclicIncrement(mrtElementsStructDB[wElement].SWOffsetPointer, wBufferSize, 256 * 4);				
						break;
					}
				case sital_mRt_DataBlockMode_4K_WORDS:  
					{
						if(wBufferSize > 4096)
							return sitalReturnCode_DATABLOCK_SIZE_TOO_SMALL;
						DumpHostToDevice(mrtDataBlockStructDB[wDataBlock].DeviceIdRunningOn, wBuffer, mrtElementsStructDB[wElement].SWOffsetPointer + mrtDataBlockStructDB[wDataBlock].HWPointer, 4096, wBufferSize);
						// In this mode the SW pointer is incremented by the buffer size cyclically.
						mrtElementsStructDB[wElement].SWOffsetPointer = CyclicIncrement(mrtElementsStructDB[wElement].SWOffsetPointer, wBufferSize, 4096);				
						break;
					}
				case sital_mRt_DataBlockMode_16K_WORDS:  
					{
						if(wBufferSize > 4096 * 4)
							return sitalReturnCode_DATABLOCK_SIZE_TOO_SMALL;
						DumpHostToDevice(mrtDataBlockStructDB[wDataBlock].DeviceIdRunningOn, wBuffer, mrtElementsStructDB[wElement].SWOffsetPointer + mrtDataBlockStructDB[wDataBlock].HWPointer, 4096 * 4, wBufferSize);
						// In this mode the SW pointer is incremented by the buffer size cyclically.
						mrtElementsStructDB[wElement].SWOffsetPointer = CyclicIncrement(mrtElementsStructDB[wElement].SWOffsetPointer, wBufferSize, 4096 * 4);				
						break;
					}
			}
	}


	return sitalReturnCode_SUCCESS;
}

U16BIT _DECL CyclicIncrement(U16BIT source, U16BIT size, U16BIT modulu)
{
	U16BIT temp = ((source % modulu) + size) % modulu;
	U16BIT MSBs = source - (source % modulu);
	return temp + MSBs;
}

/*
 	Read a block of data from a bus element.
 	This function verifies the memory management mode and updates the data accordingly.
*/
_EXTERN S16BIT _DECL sital_mRt_Element_DataBlock_Read (U16BIT wElement, U16BIT wDataBlock, U16BIT* wBuffer, U16BIT* wBufferSize)
{
	/*
	- Verify element & datablock are valid ids
	- Verify datablock & Element are initialized
	- Verify that Datablock is mapped to the specified Element	
	*/
	// Verify element & datablock are valid ids
	if (wElement > MAX_ELEMENTS || wDataBlock > MAX_DATABLOCKS)
		return sitalReturnCode_MRT_REQUESTED_ID_EXCEEDED_MAX_ALLOWED;

	//Verify datablock is initialized
	if(mrtDataBlockStructDB[wDataBlock].Mode == UnInitialized)
		return sitalReturnCode_MRT_WRITING_TO_UNINITIALIZED_DATABLOCK;

	//Verify Element is initialized
	if(mrtElementsStructDB[wElement].Mode == UnInitialized)
		return sitalReturnCode_MRT_WRITING_TO_UNINITIALIZED_ELEMENT;

	//Verify that Datablock is mapped to the specified Element
	if(!mrtElementsStructDB[wElement].DataBlock_IsMapped || mrtElementsStructDB[wElement].DataBlockID != wDataBlock)
		return sitalReturnCode_MRT_WRITING_TO_UNMAPPED_DATABLOCK;
		
	U16BIT command;
	U16BIT hwPointer;
	U16BIT swPointer;
	U16BIT index;
	U16BIT bufferIdx;

	//processing for Mode = ready: The HW did not update the data in ready mode thus, the buffers are empty.
	if(mrtDataBlockStructDB[wDataBlock].Mode == Ready)
	{
		*wBufferSize = 0;
		return sitalReturnCode_READING_EMPTY_BUFFER;
	}

	/*
	Runtime Mode:
	- Get Command
		- if Tx, return error
		
	32
	- Read WC
	- Loop 0 - (WC-1) 
	- Retrun buffersize = WC

	64
	- Read HW Pointer
	- Negate SW Pointer (to get the pointer where data is and not the current pointer)
	- Read WC
	- Loop SWPointer - (SWPointer + WC -1)
	- Retrun buffersize = WC
	
	256 | 1024 | 4096 | 4096 * 4
	- Read HW Pointer
	- Loop SWPointer - HWPointer
	- Advance SW Pointer by 1
	- Return buffer size (HWPointer - SWPointer)

	Global - TBD
	*/

	// Handling runtime 
	if(mrtDataBlockStructDB[wDataBlock].Mode == Running)
	{
		RMem(mrtDataBlockStructDB[wDataBlock].DeviceIdRunningOn, mrtElementsStructDB[wElement].ElementAddress + 3 , &mrtElementsStructDB[wElement].Command_1553);
		RMem(mrtDataBlockStructDB[wDataBlock].DeviceIdRunningOn, mrtElementsStructDB[wElement].ElementAddress + 2 , &mrtElementsStructDB[wElement].HWPointer);
		command = mrtElementsStructDB[wElement].Command_1553;
		hwPointer = mrtElementsStructDB[wElement].HWPointer;
		swPointer = mrtElementsStructDB[wElement].SWOffsetPointer;
		// Verify that getting Tx/Rx value from bit 6 MSB of command
		U16BIT tx = 0;
		tx = command & 0x0400;
		// If command is Tx mode, return error
		if (tx > 0)
			return sitalReturnCode_MRT_READ_DATA_WHILE_TX_NOT_ALLOWED;
		U16BIT internalIndex;
		U16BIT commandWC = command & 0x001F;
		commandWC = (commandWC == 0) ? 32 : commandWC;
		// Different handling for command mode code : if command with data then command WC = 1, else 0

		switch(mrtDataBlockStructDB[wDataBlock].DataBLockLength)		
		{
			case sital_mRt_DataBlockMode_32_WORDS:  
				{
					for (index = 0 ; index < commandWC ; index++)
					{
						RMem(mrtDataBlockStructDB[wDataBlock].DeviceIdRunningOn, hwPointer + index, &wBuffer[index]);						
					}
					*wBufferSize = commandWC;
					break;
				}
			case sital_mRt_DataBlockMode_64_WORDS:  
				{
					// Negate HW pointer 
					hwPointer = hwPointer ^ 0x0020;
					
					for (index = 0 ; index < commandWC ; index++)
					{
						RMem(mrtDataBlockStructDB[wDataBlock].DeviceIdRunningOn, hwPointer + index, &wBuffer[index]);						
					}
					*wBufferSize = commandWC;
					break;
				}
			case sital_mRt_DataBlockMode_256_WORDS:
				{
					bufferIdx = 0;
					internalIndex = swPointer; 

					if (swPointer == (hwPointer & 0x00FF))
					{
						*wBufferSize = 0;
						return sitalReturnCode_SUCCESS;
					}

					if (swPointer < (hwPointer & 0x00FF))
					{
						for (index = swPointer ; index < (hwPointer & 0x00FF) ; index++)
						{
							RMem(mrtDataBlockStructDB[wDataBlock].DeviceIdRunningOn, (hwPointer & 0xFF00) + index, &wBuffer[bufferIdx++]);
						}
						mrtElementsStructDB[wElement].SWOffsetPointer = index;
						*wBufferSize = bufferIdx;	
					}
					// The SW pointer is bigger or equal to the HW pointer (cyclically smaller)
					else
					{
						
						for (index = 0 ; index < ((hwPointer & 0x00FF) + 256 - internalIndex) ; index++)
						{
							RMem(mrtDataBlockStructDB[wDataBlock].DeviceIdRunningOn, (hwPointer & 0xFF00) + (swPointer & 0x00FF) , &wBuffer[bufferIdx++]);
							swPointer++;
							swPointer &= 0x00FF;
						}
						mrtElementsStructDB[wElement].SWOffsetPointer = swPointer;
						*wBufferSize = bufferIdx;	
					}
					break;
				}
			case sital_mRt_DataBlockMode_1K_WORDS:
				{
					bufferIdx = 0;
					internalIndex = swPointer; 

					if (swPointer == (hwPointer & 0x03FF))
					{
						*wBufferSize = 0;
						return sitalReturnCode_SUCCESS;
					}

					if (swPointer < (hwPointer & 0x03FF))
					{
						for (index = swPointer ; index < (hwPointer & 0x03FF) ; index++)
						{
							RMem(mrtDataBlockStructDB[wDataBlock].DeviceIdRunningOn, (hwPointer & 0xFC00) + index, &wBuffer[bufferIdx++]);
						}
						mrtElementsStructDB[wElement].SWOffsetPointer = index;
						*wBufferSize = bufferIdx;	
					}
					// The SW pointer is bigger or equal to the HW pointer (cyclically smaller)
					else
					{
						for (index = 0 ; index < ((hwPointer & 0x03FF) + 1024 - internalIndex) ; index++)
						{
							RMem(mrtDataBlockStructDB[wDataBlock].DeviceIdRunningOn, (hwPointer & 0xFC00) + (swPointer & 0x03FF) , &wBuffer[bufferIdx++]);
							swPointer++;
							swPointer &= 0x03FF;
						}
						mrtElementsStructDB[wElement].SWOffsetPointer = swPointer;
						*wBufferSize = bufferIdx;	
					}
					break;
				}
			case sital_mRt_DataBlockMode_4K_WORDS:
				{
					bufferIdx = 0;
					internalIndex = swPointer; 

					if (swPointer == (hwPointer & 0x0FFF))
					{
						*wBufferSize = 0;
						return sitalReturnCode_SUCCESS;
					}

					if (swPointer < (hwPointer & 0x0FFF))
					{
						for (index = swPointer ; index < (hwPointer & 0x0FFF) ; index++)
						{
							RMem(mrtDataBlockStructDB[wDataBlock].DeviceIdRunningOn, (hwPointer & 0xF000) + index, &wBuffer[bufferIdx++]);
						}
						mrtElementsStructDB[wElement].SWOffsetPointer = index;
						*wBufferSize = bufferIdx;	
					}
					// The SW pointer is bigger or equal to the HW pointer (cyclically smaller)
					else
					{
						for (index = 0 ; index < ((hwPointer & 0x0FFF) + 4096 - internalIndex) ; index++)
						{
							RMem(mrtDataBlockStructDB[wDataBlock].DeviceIdRunningOn, (hwPointer & 0xF000) + (swPointer & 0x0FFF) , &wBuffer[bufferIdx++]);
							swPointer++;
							swPointer &= 0x0FFF;
						}
						mrtElementsStructDB[wElement].SWOffsetPointer = swPointer;
						*wBufferSize = bufferIdx;	
					}
					break;
				}
			case sital_mRt_DataBlockMode_16K_WORDS:
				{
					bufferIdx = 0;
					internalIndex = swPointer; 

					if (swPointer == (hwPointer & 0x3FFF))
					{
						*wBufferSize = 0;
						return sitalReturnCode_SUCCESS;
					}

					if (swPointer < (hwPointer & 0x3FFF))
					{
						for (index = swPointer ; index < (hwPointer & 0x3FFF) ; index++)
						{
							RMem(mrtDataBlockStructDB[wDataBlock].DeviceIdRunningOn, (hwPointer & 0xC000) + index, &wBuffer[bufferIdx++]);
						}
						mrtElementsStructDB[wElement].SWOffsetPointer = index;
						*wBufferSize = bufferIdx;	
					}
					// The SW pointer is bigger or equal to the HW pointer (cyclically smaller)
					else
					{
						for (index = 0 ; index < ((hwPointer & 0x3FFF) + (4096 * 4) - internalIndex) ; index++)
						{
							RMem(mrtDataBlockStructDB[wDataBlock].DeviceIdRunningOn, (hwPointer & 0xC000) + (swPointer & 0x3FFF) , &wBuffer[bufferIdx++]);
							swPointer++;
							swPointer &= 0x3FFF;							
						}
						mrtElementsStructDB[wElement].SWOffsetPointer = swPointer;
						*wBufferSize = bufferIdx;	
					}
					break;
				}
			default:
				return sitalReturnCode_FUNCTION_NOT_IMPLEMENTED;
		}
	}

	return sitalReturnCode_SUCCESS;
}

_EXTERN S16BIT _DECL sital_mRt_Delete_BusList (U16BIT wBusList)
{
	// Verify legal buslist ID
	if (wBusList > MAX_BUSLISTS)
		return sitalReturnCode_MRT_REQUESTED_ID_EXCEEDED_MAX_ALLOWED;

	// Verify trying to delete an existing buslist
	if(mrtBusListStructDB[wBusList].Mode == UnInitialized)
		return sitalReturnCode_MRT_REQUESTED_ID_UNINITIALIZED;

	// Verify that buslist is not running
	if(mrtBusListStructDB[wBusList].RunningOnDeviceID != -1 || mrtBusListStructDB[wBusList].Mode == Running)
		return sitalReturnCode_BUSLIST_IS_RUNNING;
	S16BIT res;
	// Unmapping all elements from buslist
	for (U16BIT i = 0 ; i < mrtBusListStructDB[wBusList].NumOfElements ; i++)
	{
		res = sital_mRt_UnMap_Element_From_BusList(wBusList, mrtBusListStructDB[wBusList].Elements[i]); 
		if (res != sitalReturnCode_SUCCESS)
			return res;
	}
	
	// Reset properties
	mrtBusListStructDB[wBusList].Mode = UnInitialized;
	mrtBusListStructDB[wBusList].HWPointer = 0;
	mrtBusListStructDB[wBusList].NumOfElements = 0;

	return sitalReturnCode_SUCCESS;
}

_EXTERN S16BIT _DECL sital_mRt_Delete_BusList_Element (U16BIT wElement)
{
	// Verify legal element
	if (wElement > MAX_ELEMENTS)
		return sitalReturnCode_MRT_REQUESTED_ID_EXCEEDED_MAX_ALLOWED;

	// Verify that element is not running
	if(mrtElementsStructDB[wElement].Mode == Running)
		return sitalReturnCode_ELEMENT_IS_RUNNING;
	
	S16BIT res;
	// Unmapping a datablock that is mapped to this element
	if(mrtElementsStructDB[wElement].DataBlockID != -1)
	{
		res = sital_mRt_UnMap_DataBlock_From_Element(wElement, mrtElementsStructDB[wElement].DataBlockID);
		if (res != sitalReturnCode_SUCCESS)
			return res;	
		
	}
	
	// Reset properties
	mrtElementsStructDB[wElement].Mode = UnInitialized;
	mrtElementsStructDB[wElement].Command_1553 = 0;
	mrtElementsStructDB[wElement].DataBlockID = 0;
	mrtElementsStructDB[wElement].DataBlock_IsMapped = false;
	mrtElementsStructDB[wElement].HWPointer = 0;
	mrtElementsStructDB[wElement].Options = 0;
	
	// For all buslists, loop
	// Foreach buslist loop through elements until deleted element
	// Shift up all remaining elements
	// Decrement NumberOfElements
	bool compress = false;
	for (U16BIT bl = 0 ; bl < MAX_BUSLISTS ; bl++)
	{
		for (U16BIT el = 0 ; el < mrtBusListStructDB[bl].NumOfElements	 ; el++)
		{
			if (mrtBusListStructDB[bl].Elements[el] == wElement)
				compress = true;
			if (compress)
				mrtBusListStructDB[bl].Elements[el] = mrtBusListStructDB[bl].Elements[el + 1];
		}
		mrtBusListStructDB[bl].NumOfElements--;
	}
	
	return sitalReturnCode_SUCCESS;
}

_EXTERN S16BIT _DECL sital_mRt_Get_DataBlock_NumberOfWordsToRead (U16BIT wElement, U16BIT wDataBlock, U16BIT* numWordsToRead)
{
	return sital_mRt_Get_DataBlock_Words_Pending(wElement, wDataBlock, numWordsToRead);
}

_EXTERN S16BIT _DECL sital_mRt_Get_DataBlock_NumberOfWordsToWrite (U16BIT wElement, U16BIT wDataBlock, U16BIT* numWordsToWrite)
{
	return sital_mRt_Get_DataBlock_Words_Pending(wElement, wDataBlock, numWordsToWrite);
}

S16BIT _DECL sital_mRt_Get_DataBlock_Words_Pending (U16BIT wElement, U16BIT wDataBlock, U16BIT* numPendingWords)
{
	/*
	- Verify legal datablock and element
	- In ready mode return error, runnning mode only
	- Does not support 32 and 64 data length, in that case retrun error
	- Read SW and HW pointers, if equal retrun 0
	- For Tx - retrun HW - SW cyclic on size
	- For Rx - retrun HW - SW cyclic on size
	Do not read command and always retrun HW - SW cyclic
	*/
	// Verify legal datablock
	if (wDataBlock > MAX_DATABLOCKS || wElement > MAX_ELEMENTS)
		return sitalReturnCode_MRT_REQUESTED_ID_EXCEEDED_MAX_ALLOWED;

	if(mrtDataBlockStructDB[wDataBlock].Mode != Running || mrtElementsStructDB[wElement].HWPointer == mrtElementsStructDB[wElement].SWOffsetPointer)
	{
		*numPendingWords = 0;
		return sitalReturnCode_READING_EMPTY_BUFFER;
	}

	U16BIT hwPointer;
	U16BIT swPointer;

	RMem(mrtDataBlockStructDB[wDataBlock].DeviceIdRunningOn, mrtElementsStructDB[wElement].ElementAddress + 2 , &mrtElementsStructDB[wElement].HWPointer);
	hwPointer = mrtElementsStructDB[wElement].HWPointer;
	swPointer = mrtElementsStructDB[wElement].SWOffsetPointer;

	switch(mrtDataBlockStructDB[wDataBlock].DataBLockLength)		
	{
		case sital_mRt_DataBlockMode_32_WORDS	:
		case sital_mRt_DataBlockMode_64_WORDS	:
		case sital_mRt_DataBlockMode_RESERVED	:
		case sital_mRt_DataBlockMode_GLOBAL		: return sitalReturnCode_DATABLOCK_SIZE_ASSINGMENT_ERROR;
		case sital_mRt_DataBlockMode_256_WORDS	: *numPendingWords = (256 + hwPointer - swPointer) & 0x00FF;		break;
		case sital_mRt_DataBlockMode_1K_WORDS	: *numPendingWords = (1024 + hwPointer - swPointer) & 0x03FF;		break;
		case sital_mRt_DataBlockMode_4K_WORDS	: *numPendingWords = (4096 + hwPointer - swPointer) & 0x0FFF;		break;
		case sital_mRt_DataBlockMode_16K_WORDS	: *numPendingWords = ((4096 * 4) + hwPointer - swPointer) & 0x3FFF; break;
	}
	return sitalReturnCode_SUCCESS;
}

_EXTERN S16BIT _DECL sital_mRt_Delete_Element_DataBlock (U16BIT wDataBlock)
{
	// Verify legal datablock
	if (wDataBlock > MAX_DATABLOCKS)
		return sitalReturnCode_MRT_REQUESTED_ID_EXCEEDED_MAX_ALLOWED;

	// Verify that element is not running
	if(mrtDataBlockStructDB[wDataBlock].Mode == Running)
		return sitalReturnCode_DATABLOCK_IS_RUNNING;

	// Unmapping a datablock that is mapped elements
	//if(mrtDataBlockStructDB[wDataBlock].ElementID != -1)
	for (U16BIT el = 0 ; el < MAX_ELEMENTS ; el++)
	{
		if (mrtElementsStructDB[el].DataBlockID == wDataBlock)
		{
			mrtElementsStructDB[el].DataBlockID = -1;
			mrtElementsStructDB[el].DataBlock_IsMapped = false;
		}
	}

	// Reset properties
	mrtDataBlockStructDB[wDataBlock].Mode = UnInitialized;
	mrtDataBlockStructDB[wDataBlock].ElementID = -1;
	mrtDataBlockStructDB[wDataBlock].DataBLockLength = 0;
	mrtDataBlockStructDB[wDataBlock].Data = 0;
	//mrtDataBlockStructDB[wDataBlock].SWOffsetPointer = 0;
	mrtDataBlockStructDB[wDataBlock].HWPointer = 0;
	mrtDataBlockStructDB[wDataBlock].DeviceIdRunningOn = -1;

	return sitalReturnCode_SUCCESS;
}

_EXTERN S16BIT _DECL sital_mRt_UnMap_DataBlock_From_Element (U16BIT wElement, U16BIT wDataBlock)
{
	// Verify legal element and datablock
	if (wElement > MAX_ELEMENTS || wDataBlock > MAX_DATABLOCKS)
		return sitalReturnCode_MRT_REQUESTED_ID_EXCEEDED_MAX_ALLOWED;

	// Verify element and datablock created
	if (mrtElementsStructDB[wElement].Mode == UnInitialized || mrtDataBlockStructDB[wDataBlock].Mode == UnInitialized)
		return sitalReturnCode_MRT_REQUESTED_ID_UNINITIALIZED;

	// Verify element and datablock not running
	if (mrtElementsStructDB[wElement].Mode == Running || mrtDataBlockStructDB[wDataBlock].Mode == Running)
		return sitalReturnCode_DATABLOCK_IS_RUNNING;

	// Verify that datablock is mapped to specified element
	if (mrtElementsStructDB[wElement].DataBlockID != wDataBlock)
		return sitalReturnCode_DATABLOCK_NOT_MAPPED_TO_ELEMENT;

	// Reset mapping
	mrtElementsStructDB[wElement].DataBlockID = -1;
	mrtElementsStructDB[wElement].DataBlock_IsMapped = false;

	return sitalReturnCode_SUCCESS;
}

_EXTERN S16BIT _DECL sital_mRt_UnMap_Element_From_BusList (U16BIT wBusList, U16BIT wElement)
{
	// Verify legal buslist and datablock
	if (wBusList > MAX_BUSLISTS || wElement > MAX_ELEMENTS)
		return sitalReturnCode_MRT_REQUESTED_ID_EXCEEDED_MAX_ALLOWED;

	// Verify buslist and element created
	if (mrtBusListStructDB[wBusList].Mode == UnInitialized || mrtElementsStructDB[wElement].Mode == UnInitialized)
		return sitalReturnCode_MRT_REQUESTED_ID_UNINITIALIZED;

	// Verify buslist and element not running
	if (mrtBusListStructDB[wBusList].Mode == Running || mrtElementsStructDB[wElement].Mode == Running)
		return sitalReturnCode_ELEMENT_IS_RUNNING;

	// Verify element is mapped to specified buslist
	if (mrtBusListStructDB[wBusList].Elements[wElement] != wElement)
		return sitalReturnCode_ELEMENT_NOT_MAPPED_TO_BUSLIST;

	// Reset mapping
	mrtBusListStructDB[wBusList].Elements[wElement] = -1;
	//mrtBusListStructDB[wBusList].NumOfElements--;

	return sitalReturnCode_SUCCESS;
}

/*
 	Close device.
 	Release any allocations of device memory. 
 	Reset all SW pointers.
*/
_EXTERN S16BIT _DECL sital_mRt_Close (U16BIT swDevice)
{
	/*
	- Validate device
	- Reset device
	- Reset all pointer in host
	- Reset configurations
	- Call HW close to force HW
	- Set device state as Reset
	*/
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	// Validate that is in MRT mode
	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_MRT != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_RUN != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((sitalAccess_CARD != dsspDeviceState->wAccess) && (sitalAccess_USER != dsspDeviceState->wAccess))
	{
		return sitalReturnCode_INVALID_ACCESS;
	}
	S16BIT Result;
	U16BIT value;
	
	sitalDevice_AccessMemory(swDevice, sitalDeviceAccessOperation_Read, sitalRegisterAddress_MRT_CODE, sitalDeviceMemorySection_Registers, 1, &value);
	if(value != sitalRegisterVALUE_MRT_CODE)
		return sitalReturnCode_MRT_CODE_IN_REG_1A_INCORRECT;
	//reset device 
	//swResult = device_Register_UpdateImage (swDevice, sitalRegisterAddress_MRT_TIME_TAG_LSB, registerMask_ALL_BITS_ON, tempTimeVal);
	U16BIT wRegisterValue = sitalStartResetRegister_MRT_RESET;
	Result = sitalDevice_AccessMemory (swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_MRT_START_RESET, sitalDeviceMemorySection_Registers, sitalStartResetRegister_MRT_RESET, &wRegisterValue);
	mrtDeviceStructDB[swDevice].RunningBusList = -1;

	//Reset configurations in host (the registers in the device where HW reset)
	for(int rg = 0; rg < 32 ; rg++)
	{
		mrtDeviceStructDB[swDevice].Registers[rg] = 0;
	}

	// Unmap all existing mapping and set all initialized datablocks to uninitialized
	for (U16BIT el = 0 ; el < mrtBusListStructDB[swDevice].NumOfElements ; el++)
	{
		mrtBusListStructDB[swDevice].Elements[el] = 0;
		mrtElementsStructDB[el].DataBlock_IsMapped = 0;
		mrtElementsStructDB[el].DataBlockID = -1;
		mrtElementsStructDB[el].Mode = UnInitialized;
		mrtElementsStructDB[el].SWOffsetPointer = 0;
	}
	mrtBusListStructDB->Mode = UnInitialized;
	mrtBusListStructDB->RunningOnDeviceID =-1;
	for (U16BIT dbl = 0 ; dbl < MAX_DATABLOCKS ; dbl++)
	{
		if(mrtDataBlockStructDB[dbl].Mode != UnInitialized)
		{
			mrtDataBlockStructDB[dbl].DeviceIdRunningOn = -1;
			mrtDataBlockStructDB[dbl].Mode = UnInitialized;
			mrtDataBlockStructDB[dbl].ElementID = -1;
		}
	}

	dsspDeviceState->wCurrentState = sitalDeviceState_RESET;

	return sitalReturnCode_SUCCESS;
}

/*
 	Stop mRT device from handling messages.  
	This functions sets the bit 6 of START RESET REGISTER WRITING TO ADDRESS 0X6 - 
	1 stops mRT operation after end of current message.
*/
_EXTERN S16BIT _DECL sital_mRt_Stop (U16BIT swDevice)
{
	/* 
	- Validate device
	- Write to start register stop command
	- Verify that mRT stopped.
	- If didn't stop, wait 1 mS and Verify that mRT stopped.
	- If didn't stop, return error
	- - Update device and buslist states as stopped 
	*/ 
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	// Validate that is in MRT mode
	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_MRT != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_RUN != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((sitalAccess_CARD != dsspDeviceState->wAccess) && (sitalAccess_USER != dsspDeviceState->wAccess))
	{
		return sitalReturnCode_INVALID_ACCESS;
	}

	if (mrtDeviceStructDB[swDevice].RunningBusList == -1)
		return sitalReturnCode_MRT_NOT_IN_RUNNING_MODE;

	// Write to start register stop command
	//WReg(swDevice, sitalRegisterAddress_MRT_START_RESET, sitalStartResetRegister_MRT_STOP_AT_END_OF_LAST_MESSAGE);
	// NB: Dec 25, 2013: Register value bug fix
	WReg(swDevice, sitalRegisterAddress_MRT_START_RESET, sitalStartResetRegister_MRT_STOP_AT_END_OF_CURRENT_MESSAGE);

	U16BIT isActive;
	//RReg(swDevice, sitalConfigurationRegister1_MRT_ACTIVE, &isActive);
	// NB: Dec 25, 2013: Register address bug fix
	RReg(swDevice, sitalRegisterAddress_MRT_CONFIGURATION_REGISTER, &isActive);

	// NB March 25 - fix for stop, waiting for the message to complete and call reset
	// The HW returns that it is stopped but continues to reply to messages
	Sleep_NonOsDependent(1U);
	WReg(swDevice, sitalRegisterAddress_MRT_START_RESET, sitalStartResetRegister_MRT_RESET);
	
	// Verify that mRT stopped.
	//if ((isActive & sitalConfigurationRegister1_MRT_BUS_ACTIVE) == sitalConfigurationRegister1_MRT_BUS_ACTIVE)
	// NB: Dec 25, 2013: Register value bug fix
	U16BIT r = 0;
	while ((isActive & sitalConfigurationRegister1_MRT_ACTIVE) == sitalConfigurationRegister1_MRT_ACTIVE)
	{ 
		// still active - sleep for 1 millisecond (non OS dependent)
		Sleep_NonOsDependent(1U);
		// NB: Dec 25, 2013: Remove Sleep for Linux compatibility
		RReg(swDevice, sitalRegisterAddress_MRT_CONFIGURATION_REGISTER, &isActive);
		
		if ((isActive & sitalConfigurationRegister1_MRT_ACTIVE) == sitalConfigurationRegister1_MRT_ACTIVE)
		{
			// In case that does not stop, write SW reset and return busy.
			WReg(swDevice, sitalRegisterAddress_MRT_START_RESET, sitalStartResetRegister_MRT_RESET);
			return sitalReturnCode_DEVICE_BUSY;
		}
		//if ((isActive & sitalConfigurationRegister1_MRT_BUS_ACTIVE) == sitalConfigurationRegister1_MRT_BUS_ACTIVE)
		//{ // still active
		//	return sitalReturnCode_MRT_STOP_RUN_FAILED;
		//}
	}
	U16BIT currentBusList = mrtDeviceStructDB[swDevice].RunningBusList;
	U16BIT currentElement; 
	U16BIT currentDataBlock; 
	mrtBusListStructDB[currentBusList].Mode = Ready;

	for (int i = 0; i < mrtBusListStructDB[currentBusList].NumOfElements ; i++)
	{
		currentElement = mrtBusListStructDB[currentBusList].Elements[i];
		currentDataBlock = mrtElementsStructDB[currentElement].DataBlockID;

		// Mark constrcuts as stopped
		mrtElementsStructDB[currentElement].Mode = Ready;
		mrtDataBlockStructDB[currentDataBlock].Mode = Ready;
		mrtDataBlockStructDB[currentDataBlock].DeviceIdRunningOn = -1;
	}
	mrtDeviceStructDB[swDevice].RunningBusList = -1;

	return sitalReturnCode_SUCCESS;
}

/*
 	Set 32 bit time tag.  
	Set the time tag register to given value.
*/
_EXTERN S16BIT _DECL sital_mRt_SetTime (U16BIT swDevice, U32BIT wTime)
{
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	// Validate that is in MRT mode
	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_MRT != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_RUN != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((sitalAccess_CARD != dsspDeviceState->wAccess) && (sitalAccess_USER != dsspDeviceState->wAccess))
	{
		return sitalReturnCode_INVALID_ACCESS;
	}

	if(mrtDeviceStructDB[swDevice].RunningBusList != -1)
		return sitalReturnCode_BUSLIST_IS_RUNNING;

	// Writing to image.
	U16BIT rtTtgLSB = (U16BIT) (wTime & 0xFFFF);
	mrtDeviceStructDB[swDevice].Registers[sitalRegisterAddress_MRT_TIME_TAG_LSB] = rtTtgLSB;

	U16BIT rtTtgMSB = (U16BIT) ((wTime >> 16 ) & 0xFFFF);
	mrtDeviceStructDB[swDevice].Registers[sitalRegisterAddress_MRT_TIME_TAG_MSB] = rtTtgMSB;

	return sitalReturnCode_SUCCESS;
}

/*
 	Get 32 bit time tag.
*/
_EXTERN S16BIT _DECL sital_mRt_GetTime (U16BIT swDevice, U32BIT* wTime)
{
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	// Validate that is in MRT mode
	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_MRT != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_RUN != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((sitalAccess_CARD != dsspDeviceState->wAccess) && (sitalAccess_USER != dsspDeviceState->wAccess))
	{
		return sitalReturnCode_INVALID_ACCESS;
	}
	S16BIT result;
	U16BIT rtTtgLSB_First;
	U16BIT rtTtgLSB_Second;
	U16BIT rtTtgMSB;
	U16BIT numberOfRetries = 5;

	// Retry numberOfRetries times to compare the high 8 bits of sitalRegisterAddress_MRT_TIME_TAG_LSB read to verify reading consistency
	for (U16BIT idx = 0 ; idx < numberOfRetries ; idx++)
	{
		// Read LSBs, extract the 8 high bits for comparison
		result = RReg(swDevice, sitalRegisterAddress_MRT_TIME_TAG_LSB, &rtTtgLSB_First);
		if(result < 0)
			return result;
		result = RReg(swDevice, sitalRegisterAddress_MRT_TIME_TAG_MSB, &rtTtgMSB);
		if(result < 0)
			return result;
		result = RReg(swDevice, sitalRegisterAddress_MRT_TIME_TAG_LSB, &rtTtgLSB_Second);
		if(result < 0)
			return result;
		
		if ((rtTtgLSB_First & 0xFF00) == (rtTtgLSB_Second & 0xFF00))
		{
			*wTime = (U32BIT)((rtTtgMSB << 16) | rtTtgLSB_Second);
			return sitalReturnCode_SUCCESS;
		}
	}
	return sitalReturnCode_MRT_GET_TIMETAG_FAILED_DATA_INCONSISTENT;
}

/*
    Get the version of the IP.
*/
_EXTERN S16BIT _DECL sital_mRt_Get_Version (U16BIT swDevice, U16BIT* wVersion)
{
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}
	// Validate that is in MRT mode
	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_MRT != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}
	if ((sitalAccess_CARD != dsspDeviceState->wAccess) && (sitalAccess_USER != dsspDeviceState->wAccess))
	{
		return sitalReturnCode_INVALID_ACCESS;
	}

	return RReg(swDevice, sitalRegisterAddress_MRT_VERSION_OF_CORE, wVersion);
}

/*
 	Enable RTs support by setting appropriate bit in 31 bit vector. 
*/
_EXTERN S16BIT _DECL sital_mRt_EnableRts (U16BIT swDevice, U32BIT wRtsVector)
{
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	// Validate that is in MRT mode
	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_MRT != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_RUN != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((sitalAccess_CARD != dsspDeviceState->wAccess) && (sitalAccess_USER != dsspDeviceState->wAccess))
	{
		return sitalReturnCode_INVALID_ACCESS;
	}

	if(mrtDeviceStructDB[swDevice].RunningBusList != -1)
		return sitalReturnCode_BUSLIST_IS_RUNNING;

	// Writing to image.
	U16BIT rtVecLSB = (U16BIT) (wRtsVector & 0xFFFF);
	mrtDeviceStructDB[swDevice].Registers[sitalRegisterAddress_MRT_RT15_TO_0_ENABLE] = rtVecLSB;
	U16BIT rtVecMSB = (U16BIT) ((wRtsVector >> 16 ) & 0xFFFF);
	mrtDeviceStructDB[swDevice].Registers[sitalRegisterAddress_MRT_RT30_TO_16_ENABLE] = rtVecMSB;

	return sitalReturnCode_SUCCESS;
}

/*
 	Get Enabled RTs by reading 31 bit vector. 
*/
_EXTERN S16BIT _DECL sital_mRt_Get_EnabledRts (U16BIT swDevice, U32BIT* wRtsVector)
{
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	// Validate that is in MRT mode
	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_MRT != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_RUN != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((sitalAccess_CARD != dsspDeviceState->wAccess) && (sitalAccess_USER != dsspDeviceState->wAccess))
	{
		return sitalReturnCode_INVALID_ACCESS;
	}

	U16BIT rtVecLSB;
	U16BIT rtVecMSB;
	S16BIT result;
	result = RReg(swDevice, sitalRegisterAddress_MRT_RT15_TO_0_ENABLE, &rtVecLSB);
	if(result < 0)
		return result;
	result = RReg(swDevice, sitalRegisterAddress_MRT_RT30_TO_16_ENABLE, &rtVecMSB);
	if(result < 0)
		return result;
	// Bit 16 in MSB is masked 

	*wRtsVector = (U32BIT)(((rtVecMSB & ~sitalInterruptEnableRegister1_MRT_MSB_HIGH_BIT_MASK) << 16) | rtVecLSB);
	
	return sitalReturnCode_SUCCESS;
}

/*
 	Set enable for interrupts.  
*/
_EXTERN S16BIT _DECL sital_mRt_SetIntEnable (U16BIT swDevice, U16BIT wInterrupsEnabled)
{
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	// Validate that is in MRT mode
	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_MRT != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_RUN != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((sitalAccess_CARD != dsspDeviceState->wAccess) && (sitalAccess_USER != dsspDeviceState->wAccess))
	{
		return sitalReturnCode_INVALID_ACCESS;
	}

	if(mrtDeviceStructDB[swDevice].RunningBusList != -1)
		return sitalReturnCode_BUSLIST_IS_RUNNING;

	// Writing to image.
	mrtDeviceStructDB[swDevice].Registers[sitalRegisterAddress_MRT_INTERRUPT_ENABLE_REGISTER_1] = wInterrupsEnabled;
	return sitalReturnCode_SUCCESS;
}

/*
 	Get interrupt vector 
*/
_EXTERN S16BIT _DECL sital_mRt_GetIntVector (U16BIT swDevice, U16BIT* wInterruptsStatuses)
{
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	// Validate that is in MRT mode
	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_MRT != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_RUN != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((sitalAccess_CARD != dsspDeviceState->wAccess) && (sitalAccess_USER != dsspDeviceState->wAccess))
	{
		return sitalReturnCode_INVALID_ACCESS;
	}

	S16BIT result;
	U16BIT enabled;
	U16BIT status;
	// Bug fix - 9.2.2014 - Reading from incorrect register
	// Enhancement - 9.2.2014- reading the enable register + status register. ANDing between them and retrun that value.
	result = RReg(swDevice, sitalRegisterAddress_MRT_INTERRUPT_ENABLE_REGISTER_1, &enabled);
	if(result < 0)
		return result;
	result = RReg(swDevice, sitalRegisterAddress_MRT_INTERRUPT_STATUS_REGISTER_1, &status);
	if(result < 0)
		return result;
	*wInterruptsStatuses = (enabled & status);
	return sitalReturnCode_SUCCESS;
}

/*
	Sets the specified error and its parameters to registers.
*/
_EXTERN S16BIT _DECL sital_mRt_Set_Error(U16BIT swDevice, U16BIT wErrorType, U16BIT wMessageNumber, U16BIT wWordNumber, U16BIT wInjectionParameters, S16BIT wZXDistortion)
{
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	// Validate that is in MRT mode
	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_MRT != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_RUN != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((sitalAccess_CARD != dsspDeviceState->wAccess) && (sitalAccess_USER != dsspDeviceState->wAccess))
	{
		return sitalReturnCode_INVALID_ACCESS;
	}

	if (wMessageNumber < mrt_MSG_NUMBER_MIN || wMessageNumber > mrt_MSG_NUMBER_MAX)
		return sitalReturnCode_MESSGE_NUMBER_TO_INSERT_ERROR_IS_INVALID;

	if (wWordNumber < mrt_WORD_NUMBER_MIN || wWordNumber > mrt_WORD_NUMBER_MAX)
		return sitalReturnCode_WORD_NUMBER_TO_INSERT_ERROR_IS_INVALID;
	U16BIT errType = 0;
	S16BIT errParams = 0;
	switch(wErrorType)
	{
		case MRT_NO_ERROR:
			//13.11.14 : return sitalReturnCode_NO_ERROR_SPECIFIED;
			// 1.12.14 : First remove the error then return OK
			errType = (MRT_NO_ERROR);
			break;
		case MRT_PARITY_ERROR:
			errType = (MRT_PARITY_ERROR | (wMessageNumber << 8) | (wWordNumber & 0x3F));
			break;
		case MRT_BIPHASE_ERROR:
			errType = (MRT_BIPHASE_ERROR | (wMessageNumber << 8) | (wWordNumber & 0x3F));
			errParams = (wInjectionParameters << 8);
			break;
		case MRT_SYNC_ERROR:
			if ((wInjectionParameters < mrt_SYNC_ERR_MIN || wInjectionParameters > mrt_SYNC_ERR_MAX) && wInjectionParameters != mrt_SYNC_INVERT)
				return sitalReturnCode_SYNC_INJECTION_PARAM_INVALID;
			errType = (MRT_SYNC_ERROR | (wMessageNumber << 8) | (wWordNumber & 0x3F));
			errParams = (wInjectionParameters << 8);
			break;
		case MRT_ZERO_CROSSING_ERROR:
			if (wZXDistortion < mrt_ZX_DISTORTION_MIN || wZXDistortion > mrt_ZX_DISTORTION_MAX)
				return sitalReturnCode_ZERO_CROSSING_INJECTION_PARAM_INVALID;
			errType = (MRT_ZERO_CROSSING_ERROR | (wMessageNumber << 8) | (wWordNumber & 0x3F));
			errParams = ((wInjectionParameters << 8) | (wZXDistortion & 0x3F));
			break;
		default:
			return sitalReturnCode_SPECIFIED_ERROR_INJECTION_NOT_SUPPORTED;
	}
	return sital_mRt_SetErrors(swDevice, errType, errParams);
}

S16BIT _DECL sital_mRt_SetErrors (U16BIT swDevice, U16BIT wErrorType, U16BIT wErrorParams)
{
	// In Ready Mode
	if(mrtDeviceStructDB[swDevice].RunningBusList == -1 && mrtBusListStructDB[mrtDeviceStructDB[swDevice].RunningBusList].Mode != Running)
	{
		mrtDeviceStructDB[swDevice].Registers[sitalRegisterAddress_MRT_ERROR_DEFINITION] = wErrorType;
		mrtDeviceStructDB[swDevice].Registers[sitalRegisterAddress_MRT_ERROR_PARAMETERS] = wErrorParams;
	}
	// Running mode
	else
	{
		WReg(swDevice, sitalRegisterAddress_MRT_ERROR_DEFINITION, wErrorType);
		WReg(swDevice, sitalRegisterAddress_MRT_ERROR_PARAMETERS, wErrorParams);
	}
	return sitalReturnCode_SUCCESS;
}

/*
 	Set the time tag resolution.
*/
_EXTERN S16BIT _DECL sital_mRt_SetTimeResolution (U16BIT swDevice, U16BIT wTimeResolution)
{
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	// Validate that is in MRT mode
	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_MRT != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_RUN != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((sitalAccess_CARD != dsspDeviceState->wAccess) && (sitalAccess_USER != dsspDeviceState->wAccess))
	{
		return sitalReturnCode_INVALID_ACCESS;
	}

	if(mrtDeviceStructDB[swDevice].RunningBusList != -1)
		return sitalReturnCode_BUSLIST_IS_RUNNING;

	if (wTimeResolution < sitalConfigurationRegister1_MRT_TIME_TAG_64US || wTimeResolution > sitalConfigurationRegister1_MRT_TIME_TAG_INCREMENT_TAG_CLK)
		return sitalReturnCode_MRT_TIME_REQUESTED_NOT_IN_VALID_RANGE;

	if ((wTimeResolution != sitalConfigurationRegister1_MRT_TIME_TAG_64US) && 					
		(wTimeResolution != sitalConfigurationRegister1_MRT_TIME_TAG_32US) &&					
		(wTimeResolution != sitalConfigurationRegister1_MRT_TIME_TAG_16US) &&				
		(wTimeResolution != sitalConfigurationRegister1_MRT_TIME_TAG_8US) &&					
		(wTimeResolution != sitalConfigurationRegister1_MRT_TIME_TAG_4US) &&					
		(wTimeResolution != sitalConfigurationRegister1_MRT_TIME_TAG_2US) &&					
		(wTimeResolution != sitalConfigurationRegister1_MRT_TIME_TAG_RESOLUTION_INCREMENT) &&	
		(wTimeResolution != sitalConfigurationRegister1_MRT_TIME_TAG_INCREMENT_TAG_CLK))
		return sitalReturnCode_MRT_TIME_VALUE_REQUESTED_IS_INVALID;

	S16BIT result;
	U16BIT currentTtResolution, maskedCurrentResolution;
	result = RReg(swDevice, sitalRegisterAddress_MRT_CONFIGURATION_REGISTER, &currentTtResolution);
	if(result < 0)
		return result;
	// Extracting all current config without the TTG
	maskedCurrentResolution = currentTtResolution & 0xF8FF;
	U16BIT rtTtResolution = (U16BIT) (wTimeResolution & sitalConfigurationRegister1_MRT_TIME_TAG_RESOLUTION_MASK);
	U16BIT ttRes = maskedCurrentResolution | rtTtResolution;

	mrtDeviceStructDB[swDevice].Registers[sitalRegisterAddress_MRT_CONFIGURATION_REGISTER] = ttRes;

	return sitalReturnCode_SUCCESS;
}

/*
 	Get the time tag resolution.
*/
_EXTERN S16BIT _DECL sital_mRt_GetTimeResolution (U16BIT swDevice, U16BIT* wTimeResolution)
{
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	// Validate that is in MRT mode
	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_MRT != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_RUN != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((sitalAccess_CARD != dsspDeviceState->wAccess) && (sitalAccess_USER != dsspDeviceState->wAccess))
	{
		return sitalReturnCode_INVALID_ACCESS;
	}
	S16BIT result;
	U16BIT currentTtResolution;
	result = RReg(swDevice, sitalRegisterAddress_MRT_CONFIGURATION_REGISTER, &currentTtResolution);
	if(result < 0)
		return result;
	*wTimeResolution = (currentTtResolution & sitalConfigurationRegister1_MRT_TIME_TAG_RESOLUTION_MASK);

	return sitalReturnCode_SUCCESS;
}

/*
    Create a global memory data block in the desired size for Tx messages' data.
*/
_EXTERN S16BIT _DECL sital_mRt_Create_Global_Tx_DataBlock (	U16BIT swDevice, U16BIT wMemorySize)
{
	return sitalReturnCode_FUNCTION_NOT_IMPLEMENTED;
}

/*
    Create a global memory data block in the desired size for Rx messages' data.
*/
_EXTERN S16BIT _DECL sital_mRt_Create_Global_Rx_DataBlock (	U16BIT swDevice, U16BIT wMemorySize)
{
	return sitalReturnCode_FUNCTION_NOT_IMPLEMENTED;
}

/*
    Get the current global memory data block pointer value.
*/
_EXTERN S16BIT _DECL sital_mRt_Get_Global_Tx_DataBlock_Address (U16BIT swDevice, U16BIT* wMemorySize)
{
	return sitalReturnCode_FUNCTION_NOT_IMPLEMENTED;
}

/*
    Get the current global memory data block pointer value.
*/
_EXTERN S16BIT _DECL sital_mRt_Get_Global_Rx_DataBlock_Address (U16BIT swDevice, U16BIT* wMemorySize)
{
	return sitalReturnCode_FUNCTION_NOT_IMPLEMENTED;
}

/*
    Returns the number of elements created for the buslist.
    There is a limit on the maximum length of such a list to 64 messages.
*/
_EXTERN S16BIT _DECL sital_mRt_Get_buslist_Length (S16BIT wBusList)
{
	return sitalReturnCode_FUNCTION_NOT_IMPLEMENTED;
}

/*
    Get the memory data block size from the specified buslist entry.
    Element is a number.
    memory size is in the size of 0 to 7.
*/
_EXTERN S16BIT _DECL sital_mRt_Get_Element_DataBlock_GetSize (S16BIT wBusList, U16BIT wElement, S16BIT* wMemorySize)
{
	return sitalReturnCode_FUNCTION_NOT_IMPLEMENTED;
}

/*
    Get the memory data block pointer address and memory mode from the specified buslist entry.
    Element is a number.
    memory size is in the size of 0 to 7.
*/
_EXTERN S16BIT _DECL sital_mRt_Element_DataBlock_GetAddress (S16BIT wBusList, U16BIT wElement, S16BIT* wAddress, S16BIT* wMode)
{
	return sitalReturnCode_FUNCTION_NOT_IMPLEMENTED;
}

/*
 	Map an Element data block to a message number in a buslist.
*/
_EXTERN S16BIT _DECL sital_mRt_Element_DataBlock_MapToMessage (S16BIT wBusList, U16BIT wElement)
{
	return sitalReturnCode_FUNCTION_NOT_IMPLEMENTED;
}

/*
 	UnMap an Element data block from a message number in a buslist.
*/
_EXTERN S16BIT _DECL sital_mRt_Element_DataBlock_UnmapFromMessage (S16BIT wBusList, U16BIT wElement)
{
	return sitalReturnCode_FUNCTION_NOT_IMPLEMENTED;
}

/*
    Enables interrupt for this message element upon it's good completion.
*/
_EXTERN S16BIT _DECL sital_mRt_Element_EnableIrq (U16BIT wElement)
{
	// Verify legal element and buslist
	if (wElement > MAX_ELEMENTS)
		return sitalReturnCode_MRT_REQUESTED_ID_EXCEEDED_MAX_ALLOWED;

	// Verify that element is not running
	if(mrtElementsStructDB[wElement].Mode == Running)
		return sitalReturnCode_ELEMENT_IS_RUNNING;

	mrtElementsStructDB[wElement].Options = mrtElementsStructDB[wElement].Options | sitalCommandEntryConfiguration_MRT_SET_EOM_INTERRUPT;

	return sitalReturnCode_SUCCESS;
}

/*
    Gets interrupt enable status for this element.
	Being read from image, allowed both in ready mode and runtime
*/
_EXTERN S16BIT _DECL sital_mRt_Element_ElementGetIrq (S16BIT wBusList, U16BIT wElement, U16BIT* wInterruptStatusRegisterValue)
{
	// Verify legal element and buslist
	if (wElement > MAX_ELEMENTS || wBusList > MAX_BUSLISTS)
		return sitalReturnCode_MRT_REQUESTED_ID_EXCEEDED_MAX_ALLOWED;

	// Verify that element is mapped to buslist
	if (mrtBusListStructDB[wBusList].Elements[mrtBusListStructDB[wBusList].NumOfElements] != wElement)
		return sitalReturnCode_ELEMENT_NOT_MAPPED_TO_BUSLIST;
	
	// In Ready mode read from Image
	if (mrtElementsStructDB[wElement].Mode == Ready)
		*wInterruptStatusRegisterValue = (mrtElementsStructDB[wElement].Options & sitalInterruptStatusRegister1_MRT_MESSAGE_HAS_ENDED);
	// In Running mode read from HW
	else 
		if (mrtElementsStructDB[wElement].Mode == Running)
		{
			U16BIT val;
			RReg(mrtBusListStructDB[wBusList].RunningOnDeviceID, sitalRegisterAddress_MRT_INTERRUPT_STATUS_REGISTER_1, &val);
			*wInterruptStatusRegisterValue = val & sitalInterruptStatusRegister1_MRT_MESSAGE_HAS_ENDED;
		}

	return sitalReturnCode_FUNCTION_NOT_IMPLEMENTED;
}

/*
 	Legalize all messages for enabled RTs that are not in the buslist of messages. 
*/
_EXTERN S16BIT _DECL sital_mRt_MessageLegality_Enable (S16BIT wBusList)
{
	return sitalReturnCode_FUNCTION_NOT_IMPLEMENTED;
}

/*
 	Illegalize all messages for enabled RTs that are not in the buslist of messages. 
*/
_EXTERN S16BIT _DECL sital_mRt_MessageLegality_Disable (S16BIT wBusList)
{
	return sitalReturnCode_FUNCTION_NOT_IMPLEMENTED;
}

/*
 	Get the current legalization state of buslist. 
*/
_EXTERN S16BIT _DECL sital_mRt_MessageLegality_GetStatus (S16BIT wBusList)
{
	return sitalReturnCode_FUNCTION_NOT_IMPLEMENTED;
}

/*
 	Make a buslist element raise the busy bit in the status responses.
*/
_EXTERN S16BIT _DECL sital_mRt_MessageBusyBit_Set (S16BIT wBusList, U16BIT wElement)
{
	return sitalReturnCode_FUNCTION_NOT_IMPLEMENTED;
}

/*
 	Make a buslist element clear the busy bit in the status responses.
*/
_EXTERN S16BIT _DECL sital_mRt_MessageBusyBit_Clear (S16BIT wBusList, U16BIT wElement)
{
	return sitalReturnCode_FUNCTION_NOT_IMPLEMENTED;
}

/*
 	Get the current busy bit state of a buslist element.
*/
_EXTERN S16BIT _DECL sital_mRt_MessageBusyBit_GetStatus (S16BIT wBusList, U16BIT wElement)
{
	return sitalReturnCode_FUNCTION_NOT_IMPLEMENTED;
}

/*
 	Make a buslist element set specific status response bits.
*/
_EXTERN S16BIT _DECL sital_mRt_ResponseStatusBits_Set (S16BIT wBusList, U16BIT wElement, S16BIT wBits)
{
	return sitalReturnCode_FUNCTION_NOT_IMPLEMENTED;
}

/*
 	Clear a buslist element specific status response bits.
*/
_EXTERN S16BIT _DECL sital_mRt_ResponseStatusBits_Unset (S16BIT wBusList, U16BIT wElement, S16BIT wBits)
{
	return sitalReturnCode_FUNCTION_NOT_IMPLEMENTED;
}

/*
    Access specific bus list element and return with the message struct of the last message.
    This API gathers the command data and status words from the data block and bus element 
    based on the memory managment mode.
*/
_EXTERN S16BIT _DECL sital_mRt_GetDecodedMessage (S16BIT wBusList, U16BIT wElement)
{
	return sitalReturnCode_FUNCTION_NOT_IMPLEMENTED;
}


S16BIT _DECL sitalMRT_HostBuffer_Free (U16BIT swDevice)
{
	return sitalReturnCode_FUNCTION_NOT_IMPLEMENTED;
}



/// <summary>
/// Initialize given device as a RT in accordance with given initialization options.
/// Release any past allocations of device memory.
///
/// Note:
/// - This function assumes that function sitalDevice_Initialize has already been called, initialized given device, and inquired its capabilities.
///   It then lets the user reinitialize given device with a non default configuration.
/// - This function illegalizes messages for all address type, direction, subaddress, and word-count-or-mode-code combinations.
///   To legalize a specific combination, either of the following functions may be used, as appropriate: sitalRt_DataBlock_MapToSubaddress, sitalRt_MessageLegality_Enable.
///
/// Equivalent DDC definition: aceRTConfigure
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wCommandStackSize (in)	The desired size (in words) of the command stack (sitalRtCommandStackSize_*)
/// @param dwOptions (in)	Initialization options (An or-ed combination of sitalRtSetupOption_*, not including b1553a options)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRt_Initialize (S16BIT swDevice, U16BIT wCommandStackSize, U32BIT dwOptions)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_RT != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (0U != (rtCommandStackSize_BORDER & wCommandStackSize))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Clear device memory.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Zero, (U32BIT)0, sitalDeviceMemorySection_Ram, dsspDeviceState->dcsDeviceCapabilities.dwRamSize, (U16BIT*)NULL);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Initialize device memory management.
	swResult = Device_Memory_Initialize (&(dsspDeviceState->hdmmsDeviceMemoryMap), dsspDeviceState->dcsDeviceCapabilities.dwRamSize);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Catch any permanently allocated regions of device memory.
	swResult = Device_Memory_TopSection_CatchRegion (&(dsspDeviceState->hdmmsDeviceMemoryMap), 0, (rtAddressMap_FREE_MEMORY - 1U));

	/// Initialize RT.
	swResult = rt_Initialize (swDevice, wCommandStackSize, dwOptions);


	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// In case of a real device:
	///		Set a suitable internal ISR.
	///		Configure the user's interrupt mask pseudo register.
	if (sitalAccess_CARD == dsspDeviceState->wAccess)
	{
		swResult = sitalProcess_SetInterruptServiceRoutine ((ISR_FUNCTION)rt_HandleInterrupt);
		dsspDeviceState->dwInternalImr = 0U;
	}


	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Set RT address source of given RT device to the one given.
///
/// Equivalent DDC definition: aceRTSetAddrSource
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wRtAddressSource (in)	Desired address source (sitalRtAddressSource_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return other sitalReturnCode_*	Function failed
/// </summary>
S16BIT _DECL sitalRt_AddressSource_Set (S16BIT swDevice, U16BIT wRtAddressSource)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalMode_RT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (rtAddressSource_BORDER <= wRtAddressSource)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Turn given RT device source into a suitable actual value.
	wRtAddressSource <<= configurationRegister6_OFFSET_OF_RT_ADDRESS_SOURCE;

	///	If fail to actually set the address source for given device:
	///		Return error.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, sitalRegisterAddress_CONFIGURATION_6, sitalDeviceMemorySection_Registers, sitalConfigurationRegister6_RT_ADDRESS_SOURCE, &wRtAddressSource);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Set the address source for given device in the image of configuration register #6.
	swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_6, (U16BIT)sitalConfigurationRegister6_RT_ADDRESS_SOURCE, (U16BIT)wRtAddressSource);

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Get RT address source of given RT device.
///
/// Equivalent DDC definition: aceRTGetAddrSource
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wpRtAddressSource (out)	Address source (sitalRtAddressSource_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return other sitalReturnCode_*	Function failed
/// </summary>
S16BIT _DECL sitalRt_AddressSource_Get (S16BIT swDevice, U16BIT* wpRtAddressSource)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalMode_RT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (((U16BIT*)NULL) == wpRtAddressSource)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	///	If fail to actually set the address source for given device:
	///		Return error.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, sitalRegisterAddress_CONFIGURATION_6, sitalDeviceMemorySection_Registers, 1U, wpRtAddressSource);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Turn the address source mask into a suitable sitalRtAddressSource_*.
	(*wpRtAddressSource) >>= configurationRegister6_OFFSET_OF_RT_ADDRESS_SOURCE;

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Latch the RT address that is currently input to given RT device.
///
/// Equivalent DDC definition: aceRTRelatchAddress
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRt_Address_Relatch (S16BIT swDevice)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalMode_RT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	/// Within both the image of the registers and the real ones:
	/// - Enable enhanced mode.
	/// - Set the RT address source to external.
	/// - Latch the RT address.
	/// - Write to the RT address bits.
	//    (This write operation locks the externally RT address that's currently input to given device.)
	//    (Note that the address that's written is sitalConfigurationRegister5_RT_ADDRESS_MASK (that contains 5 bits of '1') without the parity bit turned on, as the UNEVEN-bit-complementary parity is used!)
	/// - Cancel the latch of RT Address.
	//    (This prevents future write operations to the RT address bits from actually changing the RT Address.)
	S16BIT swResult; // Result of operation or function call.
	swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_3, (U16BIT)sitalConfigurationRegister3_ENHANCED_MODE, (U16BIT)registerMask_ALL_BITS_ON);
	swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_6, (U16BIT)sitalConfigurationRegister6_RT_ADDRESS_SOURCE, (U16BIT)sitalRtAddressSource_EXTERNAL);
	swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_4, (U16BIT)sitalConfigurationRegister4_RT_LATCH_ADDRESS, (U16BIT)registerMask_ALL_BITS_ON);
	swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_5, (U16BIT)(sitalConfigurationRegister5_RT_ADDRESS_MASK | sitalConfigurationRegister5_RT_ADDRESS_PARITY), (U16BIT)sitalConfigurationRegister5_RT_ADDRESS_MASK);
	swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_4, (U16BIT)sitalConfigurationRegister4_RT_LATCH_ADDRESS, (U16BIT)registerMask_ALL_BITS_OFF);

	U16BIT wRegisterValue; // The current value of a target register, or the value to set for a target register.
	wRegisterValue = registerMask_ALL_BITS_ON;
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, (U32BIT)sitalRegisterAddress_CONFIGURATION_3, sitalDeviceMemorySection_Registers, (U32BIT)sitalConfigurationRegister3_ENHANCED_MODE, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	wRegisterValue = sitalRtAddressSource_EXTERNAL;
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, (U32BIT)sitalRegisterAddress_CONFIGURATION_6, sitalDeviceMemorySection_Registers, (U32BIT)sitalConfigurationRegister6_RT_ADDRESS_SOURCE, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	wRegisterValue = registerMask_ALL_BITS_ON;
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, (U32BIT)sitalRegisterAddress_CONFIGURATION_4, sitalDeviceMemorySection_Registers, (U32BIT)sitalConfigurationRegister4_RT_LATCH_ADDRESS, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	wRegisterValue = (sitalConfigurationRegister5_RT_ADDRESS_MASK | sitalConfigurationRegister5_RT_ADDRESS_PARITY);
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, sitalRegisterAddress_CONFIGURATION_5, sitalDeviceMemorySection_Registers, sitalConfigurationRegister5_RT_ADDRESS_MASK, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	wRegisterValue = registerMask_ALL_BITS_OFF;
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, sitalRegisterAddress_CONFIGURATION_4, sitalDeviceMemorySection_Registers, sitalConfigurationRegister4_RT_LATCH_ADDRESS, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Set the RT address of given RT device.
///
/// Equivalent DDC definition: aceRTSetAddress
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wRtAddress (in)	A RT address (sitalRtAddress_0-sitalRtAddress_31)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRt_Address_Set (S16BIT swDevice, U16BIT wRtAddress)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalMode_RT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{

		printf("\n\r error:%x\n",dsspDeviceState->wMode);

		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((0U > wRtAddress) || (rtAddress_BORDER <= wRtAddress))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	// A limited-performance device is restricted to using RT-address-24 when initialized as RT.
	if ( (TRUE == dsspDeviceState->bLimitedOperationDevice) && (sitalRtAddress_24 != wRtAddress) )
	{
		return sitalReturnCode_LIMITED_DEVICE;
	}

	/// Count the bits of the new RT address that are raised.
	U16BIT wOnBitCount; // Counter of raised bits.
	wOnBitCount = 0U;
	U16BIT wHelper; // A helper variable.
	wHelper = wRtAddress;
	while (0U != wHelper)
	{
		if (0x0001U == (0x0001U & wHelper))
		{
			wOnBitCount++;
		}
		wHelper = (wHelper >> 1U);
	}

	/// Properly set the odd parity LS bit.
	wRtAddress = (wRtAddress << configurationRegister5_OFFSET_OF_RT_ADDRESS);
	if ((U16BIT)0U == (wOnBitCount % (U16BIT)2U))
	{
		wRtAddress |= (U16BIT)sitalConfigurationRegister5_RT_ADDRESS_PARITY;
	}

	/// Within both the image of the registers and the real ones:
	/// - Enable enhanced mode.
	/// - Latch the RT address.
	/// - Set the RT address to given one.
	S16BIT swResult; // Result of operation or function call.
	swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_3, (U16BIT)sitalConfigurationRegister3_ENHANCED_MODE, (U16BIT)registerMask_ALL_BITS_ON);
	swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_4, (U16BIT)sitalConfigurationRegister4_RT_LATCH_ADDRESS, (U16BIT)registerMask_ALL_BITS_ON);
	swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_5, (U16BIT)(sitalConfigurationRegister5_RT_ADDRESS_MASK | sitalConfigurationRegister5_RT_ADDRESS_PARITY), wRtAddress);
	swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_6, (U16BIT)sitalConfigurationRegister6_RT_ADDRESS_SOURCE, (U16BIT)registerMask_ALL_BITS_ON);

	U16BIT wRegisterValue; // The current value of a target register, or the value to set for a target register.
	wRegisterValue = registerMask_ALL_BITS_ON;
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, (U32BIT)sitalRegisterAddress_CONFIGURATION_3, sitalDeviceMemorySection_Registers, (U32BIT)sitalConfigurationRegister3_ENHANCED_MODE, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	wRegisterValue = registerMask_ALL_BITS_ON;
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, (U32BIT)sitalRegisterAddress_CONFIGURATION_4, sitalDeviceMemorySection_Registers, (U32BIT)sitalConfigurationRegister4_RT_LATCH_ADDRESS, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	wRegisterValue = wRtAddress;
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, (U32BIT)sitalRegisterAddress_CONFIGURATION_5, sitalDeviceMemorySection_Registers, (U32BIT)(sitalConfigurationRegister5_RT_ADDRESS_MASK | sitalConfigurationRegister5_RT_ADDRESS_PARITY), &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	wRegisterValue = registerMask_ALL_BITS_ON;
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, sitalRegisterAddress_CONFIGURATION_6, sitalDeviceMemorySection_Registers, sitalConfigurationRegister6_RT_ADDRESS_SOURCE, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, sitalRegisterAddress_CONFIGURATION_5, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	if (((sitalConfigurationRegister5_RT_ADDRESS_MASK | sitalConfigurationRegister5_RT_ADDRESS_PARITY) & wRegisterValue) != wRtAddress)
	{
		return sitalReturnCode_WRITE_ERROR;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Get the RT address of given RT device.
///
/// Note:
/// - Unlike DDC's aceRTGetAddress, this function also allows user applications that didn't initialize a RT device to get its RT address.
///
/// Equivalent DDC definition: aceRTGetAddress
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wpRtAddress (out)	A pointer to a variable within which the RT address is returned
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRt_Address_Get (S16BIT swDevice, U16BIT* wpRtAddress)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	S16BIT swResult; // Result of operation or function call.
#ifdef BLOCK_NON_INITIALIZER_APPS
	if ((sitalMode_RT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}
#else // ! BLOCK_NON_INITIALIZER_APPS
	dsspDeviceState->dcsDeviceCapabilities.dwStructureSize = sizeof(sitalDeviceCapabilitiesStructure);
	swResult = sitalDevice_GetInformation (swDevice, &(dsspDeviceState->dcsDeviceCapabilities));
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	if ((sitalMode_RT != dsspDeviceState->dcsDeviceCapabilities.wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->dcsDeviceCapabilities.wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (!dsspDeviceState->dcsDeviceCapabilities.bExists)
	{
		return sitalReturnCode_INVALID_STATE;
	}
#endif // BLOCK_NON_INITIALIZER_APPS

	if (((U16BIT*)NULL) == wpRtAddress)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Read the RT address from given RT device.
	U16BIT wRegisterValue; // The current value of a target register, or the value to set for a target register.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, sitalRegisterAddress_CONFIGURATION_5, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	(*wpRtAddress) = ( (sitalConfigurationRegister5_RT_ADDRESS_MASK & wRegisterValue) >> configurationRegister5_OFFSET_OF_RT_ADDRESS );

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Make given RT device start receiving messages.
///
/// Equivalent DDC definition: aceRTStart
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRt_Start (S16BIT swDevice)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_RT != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((sitalAccess_CARD != dsspDeviceState->wAccess) && (sitalAccess_USER != dsspDeviceState->wAccess))
	{
		return sitalReturnCode_INVALID_ACCESS;
	}

	/// Virtually configure given RT device to be able to start receiving messages.
	S16BIT swResult; // Result of operation or function call.
	swResult = rt_Start (swDevice);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Copy the registers from host to device memory.
	swResult = device_Register_UpdateDevice (swDevice);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Actually start the device.
	U16BIT wRegisterValue; // The current value of a target register, or the value to set for a target register.
	wRegisterValue = sitalConfigurationRegister1_FUNCTION_RT;
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, sitalRegisterAddress_CONFIGURATION_1, sitalDeviceMemorySection_Registers, sitalConfigurationRegister1_FUNCTION_MASK, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Update the state of given device.
	//swResult = sitalProcess_Log_PrintLine ("#StldDll.Device.State.Change: device - %i, old - %i, new - %i\n", swDevice, dsspDeviceState->wCurrentState, sitalDeviceState_RUN);
	dsspDeviceState->wCurrentState = sitalDeviceState_RUN;

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Stop given RT device from responding to received messages.
///
/// Equivalent DDC definition: aceRTStop
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRt_Stop (S16BIT swDevice)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_RT != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_RUN != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((sitalAccess_CARD != dsspDeviceState->wAccess) && (sitalAccess_USER != dsspDeviceState->wAccess))
	{
		return sitalReturnCode_INVALID_ACCESS;
	}

	///	Actually stop given RT device.
	U16BIT wRegisterValue; // The current value of a target register, or the value to set for a target register.
	wRegisterValue = registerMask_ALL_BITS_OFF;
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, sitalRegisterAddress_CONFIGURATION_1, sitalDeviceMemorySection_Registers, (sitalConfigurationRegister1_FUNCTION_RT | sitalConfigurationRegister1_FUNCTION_MT), &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Designate given device as ready.
	//swResult = sitalProcess_Log_PrintLine ("#StldDll.Device.State.Change: device - %i, old - %i, new - %i\n", swDevice, dsspDeviceState->wCurrentState, sitalDeviceState_READY);
	dsspDeviceState->wCurrentState = sitalDeviceState_READY;

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Get the actual size of data block and the size it is allocated in device memory for given type of RT data block.
///
/// @param wDataBlockType (in)	The type of data block to create (sitalRtDataBlockType_*)
/// @param wpSizeOfAllocatedDeviceMemory (out)	A pointer to the variable in which the size (in words) of device memory allocated for the data block is returned
/// @param wpActualSizeOfDataBlock (out)	A pointer to the variable in which the actual size (in words) of the data block is returned
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRt_DataBlock_GetSize (U16BIT wDataBlockType, U16BIT* wpSizeOfAllocatedDeviceMemory, U16BIT* wpActualSizeOfDataBlock)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if	(
			(0U >= wDataBlockType) ||
			(rtDataBlockType_BORDER <= wDataBlockType)
		)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if ((((U16BIT*)NULL) == wpSizeOfAllocatedDeviceMemory) || (((U16BIT*)NULL) == wpActualSizeOfDataBlock))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Use given type of data block to find its size.
	switch (wDataBlockType)
	{
	case sitalRtDataBlockType_DOUBLE:
		(*wpActualSizeOfDataBlock) = bcMemoryObjectSize_DOUBLE_DATA_BLOCK;
		(*wpSizeOfAllocatedDeviceMemory) = bcMemoryObjectSize_DOUBLE_DATA_BLOCK;
		break;
	case sitalRtDataBlockType_CIRCULAR_128:
	case sitalRtDataBlockType_COMMON_CIRCULAR_128:
		(*wpActualSizeOfDataBlock) = 128U;
		(*wpSizeOfAllocatedDeviceMemory) = 128U;
		break;
	case sitalRtDataBlockType_CIRCULAR_256:
	case sitalRtDataBlockType_COMMON_CIRCULAR_256:
		(*wpActualSizeOfDataBlock) = 256U;
		(*wpSizeOfAllocatedDeviceMemory) = 256U;
		break;
	case sitalRtDataBlockType_CIRCULAR_512:
	case sitalRtDataBlockType_COMMON_CIRCULAR_512:
		(*wpActualSizeOfDataBlock) = 512U;
		(*wpSizeOfAllocatedDeviceMemory) = 512U;
		break;
	case sitalRtDataBlockType_CIRCULAR_1024:
	case sitalRtDataBlockType_COMMON_CIRCULAR_1024:
		(*wpActualSizeOfDataBlock) = 1024U;
		(*wpSizeOfAllocatedDeviceMemory) = 1024U;
		break;
	case sitalRtDataBlockType_CIRCULAR_2048:
	case sitalRtDataBlockType_COMMON_CIRCULAR_2048:
		(*wpActualSizeOfDataBlock) = 2048U;
		(*wpSizeOfAllocatedDeviceMemory) = 2048U;
		break;
	case sitalRtDataBlockType_CIRCULAR_4096:
	case sitalRtDataBlockType_COMMON_CIRCULAR_4096:
		(*wpActualSizeOfDataBlock) = 4096U;
		(*wpSizeOfAllocatedDeviceMemory) = 4096U;
		break;
	case sitalRtDataBlockType_CIRCULAR_8192:
	case sitalRtDataBlockType_COMMON_CIRCULAR_8192:
		(*wpActualSizeOfDataBlock) = 8192U;
		(*wpSizeOfAllocatedDeviceMemory) = 8192U;
		break;
	default:
		// That's a single data block of any size (1-32 words).
		(*wpActualSizeOfDataBlock) = wDataBlockType;
		(*wpSizeOfAllocatedDeviceMemory) = bcMemoryObjectSize_NORMAL_DATA_BLOCK;
		break;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Create for given RT device a data block of given ID and type, and fill it with the contents of given buffer.
/// Use given type to determine both the size of the new data block and whether it will be used by some specific subaddress or globally.
/// In case a common circular data block is created, enter it into use as the common circular buffer of given RT device.
///
/// Note:
/// - Only a single circular data block that's common to all subaddresses of a RT may be created.
/// - A data block must be allocated at a device memory address that may be divided by its size, so that cyclic wrap will be a matter of zeroing the suitable number of LSBits.
///   In case of a double data block (whose size is 64 = 2 * 32 words), this also causes that each of the two normal data blocks it contains will begin at an address that divides in 32.
///
/// Equivalent DDC definition: aceRTDataBlkCreate
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swDataBlockId (in)	A unique ID designating a data block (0-(sitalRtCounter_DATA_BLOCKS-1))
/// @param wDataBlockType (in)	The type of data block to create (sitalRtDataBlockType_*)
/// @param wapBuffer (in)	A pointer to an array of data words to be copied into the new data block, or NULL if such a copy isn't required
/// @param wBufferSize (in)	The size (in words) of the data buffer that is pointed by wapBuffer (>0)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRt_DataBlock_Create (	S16BIT swDevice,
										S16BIT swDataBlockId,
										U16BIT wDataBlockType,
										U16BIT* wapBuffer,
										U16BIT wBufferSize)
{
	/// @pseudocode
	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{

		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if ((sitalMode_RT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (((S16BIT)0U > swDataBlockId) || ((S16BIT)sitalRtCounter_DATA_BLOCKS <= swDataBlockId))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if	(
			(0U >= wDataBlockType) ||
			(rtDataBlockType_BORDER <= wDataBlockType) ||
			((rtDataBlockType_NON_COMMON_BORDER <= wDataBlockType) && (TRUE == dsspDeviceState->rms.rsRtState.bIsCommonCircularDataBlockUsed))
		)
	{

		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// If this function is now called in regard with the default data block for given RT device:
	///		Use the default data block for given RT device.
	/// Else (function called in regard with a regular RT data block):
	///		Use given regular RT data block.
	HostDataBlockStructure* hdbspDataBlock; // A pointer to a host data block structure.
	if (TRUE == dsspDeviceState->rms.rsRtState.bIsHandlingTheDefaultDataBlock)
	{
		hdbspDataBlock = &(dsspDeviceState->rms.rsRtState.hdbsDefaultDataBlock);
	}
	else
	{
		hdbspDataBlock = &(dsspDeviceState->rms.rsRtState.hdbsaDataBlock[swDataBlockId]);
	}
	if (FALSE == hdbspDataBlock->bIsFreeForUse)
	{
		return sitalReturnCode_RT_DATA_BLOCK_EXISTS;
	}

	/// Use given type of data block to find its size.
	// Note: Though the operation of function sitalRt_DataBlock_GetSize could be incorporated in below switch command, this function is nevertheless called in order to insure compatibility between it and this function, sitalRt_DataBlock_Create.
	U16BIT wSizeOfAllocatedDeviceMemory; // The size (in words) of device memory allocated for the data block.
	U16BIT wActualSizeOfDataBlock; // The actual size (in words) of the data block.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalRt_DataBlock_GetSize (wDataBlockType, &wSizeOfAllocatedDeviceMemory, &wActualSizeOfDataBlock);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Use given type of data block to configure the common-circular-buffer field of configuration register #6.
	/// Build for the created block the value of the section of the subaddress control word that contains the memory mode field.
	U16BIT wCommonCircularBufferSetting; // The value to set for the common-circular-buffer field of configuration register #6.
	U16BIT wSubaddresControlWordMemoryModeBits; // Subaddress control word's memory mode field.
	switch (wDataBlockType)
	{
	case sitalRtDataBlockType_DOUBLE:
		wCommonCircularBufferSetting = sitalConfigurationRegister6_RT_GLOBAL_CIRCULAR_BUFFER_ENABLE_SIZE_SINGLE;
		wSubaddresControlWordMemoryModeBits = 0U;
		break;
	case sitalRtDataBlockType_CIRCULAR_128:
	case sitalRtDataBlockType_COMMON_CIRCULAR_128:
		wCommonCircularBufferSetting = sitalConfigurationRegister6_RT_GLOBAL_CIRCULAR_BUFFER_ENABLE_SIZE_128;
		wSubaddresControlWordMemoryModeBits = 1U;
		break;
	case sitalRtDataBlockType_CIRCULAR_256:
	case sitalRtDataBlockType_COMMON_CIRCULAR_256:
		wCommonCircularBufferSetting = sitalConfigurationRegister6_RT_GLOBAL_CIRCULAR_BUFFER_ENABLE_SIZE_256;
		wSubaddresControlWordMemoryModeBits = 2U;
		break;
	case sitalRtDataBlockType_CIRCULAR_512:
	case sitalRtDataBlockType_COMMON_CIRCULAR_512:
		wCommonCircularBufferSetting = sitalConfigurationRegister6_RT_GLOBAL_CIRCULAR_BUFFER_ENABLE_SIZE_512;
		wSubaddresControlWordMemoryModeBits = 3U;
		break;
	case sitalRtDataBlockType_CIRCULAR_1024:
	case sitalRtDataBlockType_COMMON_CIRCULAR_1024:
		wCommonCircularBufferSetting = sitalConfigurationRegister6_RT_GLOBAL_CIRCULAR_BUFFER_ENABLE_SIZE_1024;
		wSubaddresControlWordMemoryModeBits = 4U;
		break;
	case sitalRtDataBlockType_CIRCULAR_2048:
	case sitalRtDataBlockType_COMMON_CIRCULAR_2048:
		wCommonCircularBufferSetting = sitalConfigurationRegister6_RT_GLOBAL_CIRCULAR_BUFFER_ENABLE_SIZE_2048;
		wSubaddresControlWordMemoryModeBits = 5U;
		break;
	case sitalRtDataBlockType_CIRCULAR_4096:
	case sitalRtDataBlockType_COMMON_CIRCULAR_4096:
		wCommonCircularBufferSetting = sitalConfigurationRegister6_RT_GLOBAL_CIRCULAR_BUFFER_ENABLE_SIZE_4096;
		wSubaddresControlWordMemoryModeBits = 6U;
		break;
	case sitalRtDataBlockType_CIRCULAR_8192:
	case sitalRtDataBlockType_COMMON_CIRCULAR_8192:
		wCommonCircularBufferSetting = sitalConfigurationRegister6_RT_GLOBAL_CIRCULAR_BUFFER_ENABLE_SIZE_8192;
		wSubaddresControlWordMemoryModeBits = 7U;
		break;
	default:
		// That's a single data block of any size (1-32 words).
		wCommonCircularBufferSetting = sitalConfigurationRegister6_RT_GLOBAL_CIRCULAR_BUFFER_ENABLE_SIZE_SINGLE;
		wSubaddresControlWordMemoryModeBits = 0U;
		break;
	}

	if ((((U16BIT*)NULL) != wapBuffer) && (wBufferSize > wSizeOfAllocatedDeviceMemory))
	{

		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Set the required alignment to be log-base-2 of required device memory size.
	// See a related note above, in the documentation of this function.
	U16BIT wAlignment; // An exponent of 2 so that it is a request that (2^wAlignment) will be a divider of the allocation base address.
	wAlignment = 6U;
	while ((U16BIT)0U != (wSizeOfAllocatedDeviceMemory >> wAlignment)) { wAlignment++; };
	wAlignment--;

	/// Allocate for this data block a suitable segment of device memory.
	U32BIT dwAllocationSize; // The size (in words) of the device memory allocation.
	dwAllocationSize = wSizeOfAllocatedDeviceMemory;
	BOOLEAN bIsAllocationSuccessfullyAccomplished; // A flag that says whether the allocation actually succeeded.
	U32BIT dwAllocationBaseAddress; // The address in device memory where a suitable segment of memory has been allocated for the newly created object.
	swResult = Device_Memory_TopSection_AllocateContinuity (&(dsspDeviceState->hdmmsDeviceMemoryMap), rtAddressMap_FREE_MEMORY, (dsspDeviceState->dcsDeviceCapabilities.dwRamSize - 1U), &dwAllocationSize, wAlignment, &bIsAllocationSuccessfullyAccomplished, &dwAllocationBaseAddress);
	if ( (sitalReturnCode_SUCCESS != swResult) || (FALSE == bIsAllocationSuccessfullyAccomplished) )
	{
		return sitalReturnCode_ALLOCATION_FAIL;
	}

	/// Allocate and initialize a corresponding host structure for the new data block.
	// The data block whose ID is i:
	// - Has a corresponding structure at host memory, i.e., the entry whose index is i within his device's data block array.
	hdbspDataBlock->bIsFreeForUse = (BOOLEAN)FALSE;
	hdbspDataBlock->wId = (U16BIT)swDataBlockId;
	hdbspDataBlock->dwAddress = dwAllocationBaseAddress;
	hdbspDataBlock->wDeviceMemorySize = (U16BIT)dwAllocationSize;
	hdbspDataBlock->wActualSize = wActualSizeOfDataBlock;
	hdbspDataBlock->dwNextAccessedDataWord = 0U;
	hdbspDataBlock->dwTxSubaddressMapping = 0U;
	hdbspDataBlock->dwRxSubaddressMapping = 0U;
	hdbspDataBlock->dwBroadcastSubaddressMapping = 0U;
	hdbspDataBlock->wSubaddresControlWordMemoryModeBits = wSubaddresControlWordMemoryModeBits;

	/// Build the created block's word-count-or-mode-code mask.
	// Raise the proper word count bits in the word-count-or-mode-code-mask according to the size of the created data block, as follows:
	// - Each of bit-i (i>32) of the word-count-or-mode-code-mask is on when this data block is mapped to messages where the word count is i words.
	// - Bit-0 of the word-count-or-mode-code-mask is on when this data block is mapped to messages where the word-count is 32 words.
	hdbspDataBlock->dwWordCountOrModeCodeMask = 0U;
	if (bcMemoryObjectSize_NORMAL_DATA_BLOCK > hdbspDataBlock->wActualSize)
	{
		// Raise all the bits whose index is 1 and above according to the word counts that may be supported by the created data block.
		// This data block is smaller than 32 words long, so bit-0 must stay unset.
		for (S32BIT i=0; i<hdbspDataBlock->wActualSize; i++)
		{
			hdbspDataBlock->dwWordCountOrModeCodeMask <<= 1U;
			hdbspDataBlock->dwWordCountOrModeCodeMask |= 1U;
		}
		hdbspDataBlock->dwWordCountOrModeCodeMask <<= 1U;
	}
	else
	{
		// Given data block is at least 32 words long: Raise all 32 bits.
		hdbspDataBlock->dwWordCountOrModeCodeMask = sitalWordCountOrModeCodeMask_ALL;
	}

	/// If any data word have been given for copy into the data block:
	///		Copy given data words to device memory.
	if (((U16BIT*)NULL) != wapBuffer)
	{
		swResult = sitalRt_DataBlock_Write (swDevice, swDataBlockId, wapBuffer, wBufferSize, 0U);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			S16BIT swUnusedResult; // Result of operation or function call.
			swUnusedResult = Device_Memory_TopSection_FreeRegion (&(dsspDeviceState->hdmmsDeviceMemoryMap), dwAllocationBaseAddress, (dwAllocationBaseAddress + wSizeOfAllocatedDeviceMemory - 1U));
			return swResult;
		}
	}

	/// If a common circular data block is requested:
	///		Record the new data block as the common circular one of given device.
	///		Configure given device to use a common circular buffer.
	if (rtDataBlockType_NON_COMMON_BORDER <= wDataBlockType)
	{
		dsspDeviceState->rms.rsRtState.bIsCommonCircularDataBlockUsed = TRUE;
		dsspDeviceState->rms.rsRtState.wCommonCircularDataBlockId = (U16BIT)swDataBlockId;
		dsspDeviceState->dwInternalImr |= (sitalInterruptRegister2_RT_CIRCULAR_BUFFER_HALF_ROLLOVER | sitalInterruptRegister1_RT_CIRCULAR_BUFFER_ROLLOVER);
		swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_6, (U16BIT)sitalConfigurationRegister6_RT_GLOBAL_CIRCULAR_BUFFER_ENABLE_SIZE_MASK, wCommonCircularBufferSetting);
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Get the device memory address allocated for given data block of given RT device.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swDataBlockId (in)	A unique ID designating a data block (0-(sitalRtCounter_DATA_BLOCKS-1))
/// @param wpDeviceMemoryAddress (out)	A pointer to the variable in which the address (in words) of device memory allocated for the data block is returned
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRt_DataBlock_GetAddress (S16BIT swDevice, S16BIT swDataBlockId, U16BIT* wpDeviceMemoryAddress)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalMode_RT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (((S16BIT)0U > swDataBlockId) || ((S16BIT)sitalRtCounter_DATA_BLOCKS <= swDataBlockId))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	HostDataBlockStructure* hdbspDataBlock; // A pointer to a host data block structure.
	hdbspDataBlock = (HostDataBlockStructure*)&(dsspDeviceState->rms.rsRtState.hdbsaDataBlock[swDataBlockId]);
	if (TRUE == hdbspDataBlock->bIsFreeForUse)
	{
		return sitalReturnCode_UNDEFINED_NODE;
	}

	/// Get the device memory address of given data block.
	(*wpDeviceMemoryAddress) = (U16BIT)hdbspDataBlock->dwAddress;

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Delete given previously created data block of given RT device, and free the segment of device memory that has been allocated for it.
///
/// Equivalent DDC definition: aceRTDataBlkDelete
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swDataBlockId (in)	A unique ID designating a data block (0-(sitalRtCounter_DATA_BLOCKS-1))
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRt_DataBlock_Delete ( S16BIT swDevice, S16BIT swDataBlockId)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if ((sitalMode_RT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (((S16BIT)0U > swDataBlockId) || ((S16BIT)sitalRtCounter_DATA_BLOCKS <= swDataBlockId))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	HostDataBlockStructure* hdbspDataBlock; // A pointer to a host data block structure.
	hdbspDataBlock = &(dsspDeviceState->rms.rsRtState.hdbsaDataBlock[swDataBlockId]);
	if (TRUE == hdbspDataBlock->bIsFreeForUse)
	{
		return sitalReturnCode_UNDEFINED_NODE;
	}

	/// Loop over all the subaddresses of given RT device:
	///		If current subaddress is mapped with given data block for received messages:
	///			Cancel this mapping.
	///		If current subaddress is mapped with given data block for transmitted messages:
	///			Cancel this mapping.
	///		If current subaddress is mapped with given data block for broadcast messages:
	///			Cancel this mapping.
	S16BIT swUnusedResult; // Result of operation or function call.
	for (U16BIT uiSubaddressIndex=0; uiSubaddressIndex<32; uiSubaddressIndex++)
	{
		if ( (U32BIT)0U != (hdbspDataBlock->dwRxSubaddressMapping & (U32BIT)(1U << uiSubaddressIndex)) )
		{
			swUnusedResult = sitalRt_DataBlock_UnmapFromSubaddress (swDevice, swDataBlockId, uiSubaddressIndex, sitalRtMessageType_RX);
		}

		if ( (U32BIT)0U != (hdbspDataBlock->dwTxSubaddressMapping & (U32BIT)(1U << uiSubaddressIndex)) )
		{
			swUnusedResult = sitalRt_DataBlock_UnmapFromSubaddress (swDevice, swDataBlockId, (U16BIT)uiSubaddressIndex, sitalRtMessageType_TX);
		}

		if ( (U32BIT)0U != (hdbspDataBlock->dwBroadcastSubaddressMapping & (U32BIT)(1U << uiSubaddressIndex)) )
		{
			swUnusedResult = sitalRt_DataBlock_UnmapFromSubaddress (swDevice, swDataBlockId, (U16BIT)uiSubaddressIndex, sitalRtMessageType_BROADCAST);
		}
	}

	/// If given data block served as common circular data block:
	///		Also delete the record of a common circular data block.
	if (((BOOLEAN)TRUE == dsspDeviceState->rms.rsRtState.bIsCommonCircularDataBlockUsed) && ((U16BIT)swDataBlockId == dsspDeviceState->rms.rsRtState.wCommonCircularDataBlockId))
	{
		dsspDeviceState->rms.rsRtState.bIsCommonCircularDataBlockUsed = FALSE;
	}

	/// Free the device memory that has been allocated for given data block.
	swUnusedResult = Device_Memory_TopSection_FreeRegion (&(dsspDeviceState->hdmmsDeviceMemoryMap), hdbspDataBlock->dwAddress, (hdbspDataBlock->dwAddress + hdbspDataBlock->wDeviceMemorySize - 1U));

	/// Delete given data block.
	hdbspDataBlock->bIsFreeForUse = TRUE;

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Write the contents of given buffer in given data block of given RT device at given offset.
/// For this purpose consider the data block as a cyclic buffer, i.e., continue the copy operation from its start if/when reaching its end.
///
/// Equivalent DDC definition: aceRTDataBlkWrite
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swDataBlockId (in)	A unique ID designating a data block (0-(sitalRtCounter_DATA_BLOCKS-1))
/// @param wapBuffer (in)	A pointer to an array of data words to be copied into the new data block
/// @param wBufferSize (in)	The size (in words) of the data buffer that is pointed by wapBuffer (0-wDeviceMemorySize)
/// @param wOffset (in)	The offset (in words) from the beginning of the data block in device memory where cyclic copy begins (0-(<size-of-given-data-block>-1))
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRt_DataBlock_Write (	S16BIT swDevice,
										S16BIT swDataBlockId,
										U16BIT* wapBuffer,
										U16BIT wBufferSize,
										U16BIT wOffset)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalMode_RT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (((S16BIT)0U > swDataBlockId) || ((S16BIT)sitalRtCounter_DATA_BLOCKS <= swDataBlockId))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// If this function is now called in regard with the default data block for given RT device:
	///		Use the default data block for given RT device.
	/// Else (function called in regard with a regular RT data block):
	///		Use given regular RT data block.
	HostDataBlockStructure* hdbspDataBlock; // A pointer to a host data block structure.
	if (TRUE == dsspDeviceState->rms.rsRtState.bIsHandlingTheDefaultDataBlock)
	{
		hdbspDataBlock = (HostDataBlockStructure*)&(dsspDeviceState->rms.rsRtState.hdbsDefaultDataBlock);
	}
	else
	{
		hdbspDataBlock = (HostDataBlockStructure*)&(dsspDeviceState->rms.rsRtState.hdbsaDataBlock[swDataBlockId]);
	}
	if (TRUE == hdbspDataBlock->bIsFreeForUse)
	{
		return sitalReturnCode_UNDEFINED_NODE;
	}

	if (((U16BIT*)NULL) == wapBuffer)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if ((0U == wBufferSize) || (hdbspDataBlock->wActualSize < wBufferSize))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if (hdbspDataBlock->wActualSize <= wOffset)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Get given data block subaddress mapping information.
	BOOLEAN bIsDataBlockMapped; // A flag that says whether given data block is mapped to any subaddress, or not.
	U32BIT dwLookupAddress; // The address in device memory of the mapped subaddress' lookup entry.
	bIsDataBlockMapped = rt_DataBlock_GetSubaddressLookupInformation (hdbspDataBlock, ((U16BIT*)NULL), &dwLookupAddress, ((U32BIT*)NULL));

	U16BIT wTargetDataBlockBaseAddress; // The device memory address of target data block.
	U16BIT wTotalNumberOfWordsToWrite; // The total number of words to write to given data block.
	S16BIT swResult; // Result of operation or function call.
	/// If given data block is a common circular one:
	///		Set the base address of the data block to write to to be the base address of given data block.
	///		If given common circular data block is mapped to some subaddress:
	///			Get the current writing address of the mapped subaddress from the device lookup table.
	///			Calculate the principal number of words to write to given data block.
	///		Else:
	///			Set the principal number of words to write to given data block to be the size of the data block.
	///		If the principal number of words to write to given data block is bigger from the size of given buffer:
	///			Accordingly constrain the actual number of words to write to given data block.
	U16BIT wTargetDataBlockCurrentWriteAddress; // The device memory address of the next place where data will be written by the device in the target data block.
	if (bcMemoryObjectSize_DOUBLE_DATA_BLOCK < hdbspDataBlock->wActualSize)
	{

		// Set the base address of the data block to write to to be the base address of given data block.
		wTargetDataBlockBaseAddress = ((U16BIT)(hdbspDataBlock->dwAddress));

		if (bIsDataBlockMapped)
		{
			// With a common circular data block that's mapped to some subaddress, the current data block writing address for the mapped subaddress may be read from the dedicated entry in the device lookup table.
			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, dwLookupAddress, sitalDeviceMemorySection_Ram, 1U, &wTargetDataBlockCurrentWriteAddress);
			if (sitalReturnCode_SUCCESS != swResult)
			{
				return swResult;
			}

			// In case requested offset differs from the offset that's recorded in the device, the copy operation shall be restricted so that it won't reach the latter offset.
			// This is true even in case the accomplish of the required copy operation will be entailed with a cyclic wrap.
			U16BIT wDeviceReportedDataBlockOffset; // The current write offset as learned from the device lookup table.
			wDeviceReportedDataBlockOffset = (wTargetDataBlockCurrentWriteAddress - (U16BIT)hdbspDataBlock->dwAddress);
			if (wDeviceReportedDataBlockOffset == wOffset)
			{
				wTotalNumberOfWordsToWrite = hdbspDataBlock->wActualSize;
			}
			else
			if (wDeviceReportedDataBlockOffset > wOffset)
			{
				wTotalNumberOfWordsToWrite = (wDeviceReportedDataBlockOffset - wOffset);
			}
			else
			{
				wTotalNumberOfWordsToWrite = ((hdbspDataBlock->wActualSize - wOffset) + wDeviceReportedDataBlockOffset);
			}
		}
		else
		{
			wTotalNumberOfWordsToWrite = hdbspDataBlock->wActualSize;
		}

		if (wTotalNumberOfWordsToWrite > wBufferSize)
		{
			wTotalNumberOfWordsToWrite = wBufferSize;
		}
	}
	else
	/// If given data block is a double data block:
	///		If given data block is mapped to some subaddress:
	///			Get the base address of the currently active data block from the entry of the mapped subaddress in given device lookup table.
	///			Set the base address of the data block to write to be the base address of the currently inactive one.
	///		Else:
	///			Set the base address of the data block to write to to be the base address of the first normal data block that's contained in given data block.
	///		If the size of given buffer is bigger than the size of a normal data block:
	///			Constrain the actual number of words to write to given data block to be the size of given buffer.
	///		Else:
	///			Set the actual number of words to write to given data block to be the size of given buffer.
	//			(That's even if the buffer is bigger than the data block: It would cause no harm, as the maximum size of normal data block is anyway allocated.)
	if (bcMemoryObjectSize_DOUBLE_DATA_BLOCK == hdbspDataBlock->wActualSize)
	{
		if (bIsDataBlockMapped)
		{
			// A double data block contains two normal data blocks.
			// With RTs, when a double data block is mapped to any subaddress, a repeated flip between these two data blocks takes place.
			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, dwLookupAddress, sitalDeviceMemorySection_Ram, 1U, &wTargetDataBlockCurrentWriteAddress);
			if (sitalReturnCode_SUCCESS != swResult)
			{
				return swResult;
			}

			// A double data block contains two normal data blocks.
			// With RTs, a data block of double size must begin at a device memory address that's divisible by 64.
			// This way, the addresses of both its contained blocks will only differ in bit #5.
			// Therefore, when flipping from any of the contained blocks to the other, all that has to be done is flipping bit #5.
			wTargetDataBlockBaseAddress = (((~wTargetDataBlockCurrentWriteAddress) & (U16BIT)0x0020U) | (wTargetDataBlockCurrentWriteAddress & (~(U16BIT)0x0020U)));
		}
		else
		{
			wTargetDataBlockBaseAddress = (U16BIT)hdbspDataBlock->dwAddress;
		}

		wTotalNumberOfWordsToWrite = ( (bcMemoryObjectSize_NORMAL_DATA_BLOCK < wBufferSize) ? (U16BIT)bcMemoryObjectSize_NORMAL_DATA_BLOCK : wBufferSize );
	}
	else
	/// Else (given data block is a normal data block):
	///		Set the base address of the data block to write to to be the base address of given data block.
	///		If the size of given buffer is bigger than the size of a normal data block:
	///			Constrain the actual number of words to write to given data block to be the size of given buffer.
	///		Else:
	///			Set the actual number of words to write to given data block to be the size of given buffer.
	//			(That's even if the buffer is bigger than the data block: It would cause no harm, as the maximum size of normal data block is anyway allocated.)
	{
		wTargetDataBlockBaseAddress = ((U16BIT)(hdbspDataBlock->dwAddress));

		wTotalNumberOfWordsToWrite = ( ((U16BIT)bcMemoryObjectSize_NORMAL_DATA_BLOCK < wBufferSize) ? (U16BIT)bcMemoryObjectSize_NORMAL_DATA_BLOCK : wBufferSize );
	}

	/// If no cyclic wrap required along the required copy operation:
	///		Copy whole given buffer at once.
	///		Update the record of given data block's next accessed data word.
	/// Else:
	///		Calculate the number of data words that may be copied at the tail of the target data block.
	///		Copy enough to fill the tail of the data block.
	///		Copy the rest of the data buffer into the beginning of the data block.
	///		Update the record of given data block's next accessed data word.
	U16BIT wTargetDataBlockWriteAddress; // The device memory address of the exact place to write in the target data block.
	wTargetDataBlockWriteAddress = (wTargetDataBlockBaseAddress + wOffset);
	if ( hdbspDataBlock->wActualSize >= (wOffset + wTotalNumberOfWordsToWrite) )
	{
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, (U32BIT)wTargetDataBlockWriteAddress, sitalDeviceMemorySection_Ram, (U32BIT)wBufferSize, wapBuffer);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}

		hdbspDataBlock->dwNextAccessedDataWord = (U32BIT)(wOffset + wTotalNumberOfWordsToWrite);
	}
	else
	{
		U16BIT wNumberOfWordsToWriteAtTailOnCyclicWrap; // The number of words to write at the tail of given data block in case a cyclic wrap is required along copy.
		wNumberOfWordsToWriteAtTailOnCyclicWrap = (hdbspDataBlock->wActualSize - wOffset);
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, (U32BIT)wTargetDataBlockWriteAddress, sitalDeviceMemorySection_Ram, (U32BIT)wNumberOfWordsToWriteAtTailOnCyclicWrap, wapBuffer);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}

		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, hdbspDataBlock->dwAddress, sitalDeviceMemorySection_Ram, (U32BIT)(wTotalNumberOfWordsToWrite - wNumberOfWordsToWriteAtTailOnCyclicWrap), (wapBuffer + wNumberOfWordsToWriteAtTailOnCyclicWrap));
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}

		hdbspDataBlock->dwNextAccessedDataWord = (U32BIT)(wTotalNumberOfWordsToWrite - wNumberOfWordsToWriteAtTailOnCyclicWrap);
	}

	/// If given data block is a double data block:
	///		If given data block is mapped to some subaddress:
	///			Flip the base address of the currently active data block in the entry of the mapped subaddress in given device lookup table.
	if ( (bcMemoryObjectSize_DOUBLE_DATA_BLOCK == hdbspDataBlock->wActualSize) && bIsDataBlockMapped )
	{
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, dwLookupAddress, sitalDeviceMemorySection_Ram, (U32BIT)1U, &wTargetDataBlockBaseAddress);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Read the contents of given data block of given RT device starting at given offset into given buffer.
/// For this purpose consider the data block as a cyclic buffer, i.e., continue the copy operation from its start if/when reaching its end.
///
/// Equivalent DDC definition: aceRTDataBlkRead
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swDataBlockId (in)	A unique ID designating a data block (0-(sitalRtCounter_DATA_BLOCKS-1))
/// @param wapBuffer (in)	A pointer to an array of data words to be copied into the new data block
/// @param wBufferSize (in)	The size (in words) of the data buffer that is pointed by wapBuffer (0-wDeviceMemorySize)
/// @param wOffset (in)	The offset (in words) from the beginning of the data block in device memory where cyclic copy begins (0-(<size-of-given-data-block>-1))
/// @return Positive integer	The number of words that were read into given buffer
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRt_DataBlock_Read (	S16BIT swDevice,
										S16BIT swDataBlockId,
										U16BIT* wapBuffer,
										U16BIT wBufferSize,
										U16BIT wOffset)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalMode_RT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (((S16BIT)0U > swDataBlockId) || ((S16BIT)sitalRtCounter_DATA_BLOCKS <= swDataBlockId))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	HostDataBlockStructure* hdbspDataBlock; // A pointer to a host data block structure.
	hdbspDataBlock = (HostDataBlockStructure*)&(dsspDeviceState->rms.rsRtState.hdbsaDataBlock[swDataBlockId]);
	if (TRUE == hdbspDataBlock->bIsFreeForUse)
	{
		return sitalReturnCode_UNDEFINED_NODE;
	}

	if (((U16BIT*)NULL) == wapBuffer)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if ((0U == wBufferSize) || (hdbspDataBlock->wActualSize < wBufferSize))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if (hdbspDataBlock->wActualSize <= wOffset)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Get given data block subaddress mapping information.
	BOOLEAN bIsDataBlockMapped; // A flag that says whether given data block is mapped to any subaddress, or not.
	U32BIT dwLookupAddress; // The address in device memory of the mapped subaddress' lookup entry.
	U32BIT dwControlWordAddress; // The address in device memory of the mapped subaddress' control word lookup entry.
	bIsDataBlockMapped = rt_DataBlock_GetSubaddressLookupInformation (hdbspDataBlock, ((U16BIT*)NULL), &dwLookupAddress, &dwControlWordAddress);

	U16BIT wTargetDataBlockBaseAddress; // The device memory address of target data block.
	U16BIT wTotalNumberOfWordsToRead; // The total number of words to read from given data block.
	S16BIT swResult; // Result of operation or function call.
	/// If given data block is a common circular one:
	///		Set the base address of the data block to read from to be the base address of given data block.
	///		If given common circular data block is mapped to some subaddress:
	///			Get the current writing address of the mapped subaddress from the device lookup table.
	///			Calculate the principal number of words to read from given data block.
	///		Else:
	///			Set the principal number of words to read from given data block to be the size of the data block.
	///		If the principal number of words to read from given data block is bigger from the size of given buffer:
	///			Accordingly constrain the actual number of words to read from given data block.
	U16BIT wTargetDataBlockCurrentWriteAddress; // The device memory address of the next place where data will be written by the device in the target data block.
	U16BIT wSubaddressControlWord; // Given subaddress' control word as recorded in given RT device's subaddress control word lookup table.
	if (bcMemoryObjectSize_DOUBLE_DATA_BLOCK < hdbspDataBlock->wActualSize)
	{
		// Set the base address of the data block to read from to be the base address of given data block.
		wTargetDataBlockBaseAddress = ((U16BIT)(hdbspDataBlock->dwAddress));

		if (bIsDataBlockMapped)
		{
			// With a common circular data block that's mapped to some subaddress,
			// the current data block writing address for the mapped subaddress may be read from the dedicated entry in the device lookup table.
			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, dwLookupAddress, sitalDeviceMemorySection_Ram, 1U, &wTargetDataBlockCurrentWriteAddress);
			if (sitalReturnCode_SUCCESS != swResult)
			{
				return swResult;
			}

			// In case requested offset differs from the offset that's recorded in the device,
			// the copy operation shall be restricted so that it won't reach the latter offset.
			// This is true even in case the accomplish of the required copy operation will be entailed with a cyclic wrap.
			U16BIT wDeviceReportedDataBlockOffset; // The current write offset as learned from the device lookup table.
			wDeviceReportedDataBlockOffset = (wTargetDataBlockCurrentWriteAddress - ((U16BIT)(hdbspDataBlock->dwAddress)));
			if (wDeviceReportedDataBlockOffset >= wOffset)
			{
				wTotalNumberOfWordsToRead = (wDeviceReportedDataBlockOffset - wOffset);
			}
			else
			{
				wTotalNumberOfWordsToRead = ((hdbspDataBlock->wActualSize - wOffset) + wDeviceReportedDataBlockOffset);
			}
		}
		else
		{
			wTotalNumberOfWordsToRead = hdbspDataBlock->wActualSize;
		}

		if (wTotalNumberOfWordsToRead > wBufferSize)
		{
			wTotalNumberOfWordsToRead = wBufferSize;
		}
	}
	else
	/// If given data block is a double data block:
	///		If given data block is mapped to some subaddress:
	///			If given data block is mapped to its subaddress for Rx/Broadcast:
	///				Disable double buffering with the subaddress that's mapped to given data block.
	///				Get the base address of the currently active data block from the entry of the mapped subaddress in given device lookup table.
	///				Set the base address of the data block to read from to be the base address of the currently inactive one.
	///			Else:
	///				Get the base address of the currently active data block from the entry of the mapped subaddress in given device lookup table.
	///				Set the base address of the data block to read from to be the base address of the currently active one.
	///		Else:
	///			Set the base address of the data block to read from to be the base address of the first normal data block that's contained in given data block.
	///		If the size of given buffer is bigger than the size of a normal data block:
	///			Constrain the actual number of words to read from given data block to be the size of given buffer.
	///		Else:
	///			Set the actual number of words to read from given data block to be the size of given buffer.
	//			(That's even if the buffer is bigger than the data block: It would cause no harm, as the maximum size of normal data block is anyway allocated.)
	if (bcMemoryObjectSize_DOUBLE_DATA_BLOCK == hdbspDataBlock->wActualSize)
	{
		if (bIsDataBlockMapped)
		{
			if ((0U != hdbspDataBlock->dwRxSubaddressMapping) || (0U != hdbspDataBlock->dwBroadcastSubaddressMapping))
			{
				// Given data block is mapped to its subaddress for Rx/Broadcast.
				// Temporarily disable double buffering with the subaddress that's mapped to given data block.
				swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, dwControlWordAddress, sitalDeviceMemorySection_Ram, 1U, &wSubaddressControlWord);
				if (sitalReturnCode_SUCCESS != swResult)
				{
					return swResult;
				}
				wSubaddressControlWord = (wSubaddressControlWord & (~(U16BIT)rtLookupTable_SUBADDRESS_CONTROL_WORD_MESSAGE_DOUBLE_OR_COMMON_DATA_BLOCK));
				swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, dwControlWordAddress, sitalDeviceMemorySection_Ram, 1U, &wSubaddressControlWord);
				if (sitalReturnCode_SUCCESS != swResult)
				{
					return swResult;
				}

				// A double data block contains two normal data blocks.
				// With RTs, when a double data block is mapped to any subaddress, a repeated flip between these two data blocks takes place.
				swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, dwLookupAddress, sitalDeviceMemorySection_Ram, 1U, &wTargetDataBlockCurrentWriteAddress);
				if (sitalReturnCode_SUCCESS != swResult)
				{
					return swResult;
				}

				// A double data block contains two normal data blocks.
				// With RTs, a data block of double size must begin at a device memory address that's divisible by 64.
				// This way, the addresses of both its contained blocks will only differ in bit #5.
				// Therefore, when flipping from any of the contained blocks to the other, all that has to be done is flipping bit #5.
				wTargetDataBlockBaseAddress = (((~wTargetDataBlockCurrentWriteAddress) & (U16BIT)0x0020U) | (wTargetDataBlockCurrentWriteAddress & (~(U16BIT)0x0020U)));
			}
			else
			{
				// Given data block is mapped to its subaddress for Tx.
				// A double data block contains two normal data blocks.
				// With RTs, when a double data block is mapped to any subaddress, a repeated flip between these two data blocks takes place.
				swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, dwLookupAddress, sitalDeviceMemorySection_Ram, 1U, &wTargetDataBlockCurrentWriteAddress);
				if (sitalReturnCode_SUCCESS != swResult)
				{
					return swResult;
				}

				// Read from the current data block.
				wTargetDataBlockBaseAddress = wTargetDataBlockCurrentWriteAddress;
			}
		}
		else
		{
			wTargetDataBlockBaseAddress = hdbspDataBlock->dwAddress;
		}

		wTotalNumberOfWordsToRead = ( (bcMemoryObjectSize_NORMAL_DATA_BLOCK < wBufferSize) ? bcMemoryObjectSize_NORMAL_DATA_BLOCK : wBufferSize );
	}
	else
	/// Else (given data block is a normal data block):
	///		Set the base address of the data block to read from to be the base address of given data block.
	///		If the size of given buffer is bigger than the size of a normal data block:
	///			Constrain the actual number of words to read from given data block to be the size of given buffer.
	///		Else:
	///			Set the actual number of words to read from given data block to be the size of given buffer.
	//			(That's even if the buffer is bigger than the data block: It would cause no harm, as the maximum size of normal data block is anyway allocated.)
	{
		wTargetDataBlockBaseAddress = ((U16BIT)(hdbspDataBlock->dwAddress));

		wTotalNumberOfWordsToRead = ( (bcMemoryObjectSize_NORMAL_DATA_BLOCK < wBufferSize) ? (U16BIT)bcMemoryObjectSize_NORMAL_DATA_BLOCK : wBufferSize );
	}

	/// If no cyclic wrap required along the required copy operation:
	///		Copy whole given buffer at once.
	///		Update the record of given data block's next accessed data word.
	/// Else:
	///		Calculate the number of data words that may be copied from the tail of the target data block.
	///		Copy the tail of the data block.
	///		Copy the beginning of the data block.
	///		Update the record of given data block's next accessed data word.
	U16BIT wTargetDataBlockReadAddress; // The device memory address of the exact place to read from the target data block.
	wTargetDataBlockReadAddress = (wTargetDataBlockBaseAddress + wOffset);
	if ( hdbspDataBlock->wActualSize >= (wOffset + wTotalNumberOfWordsToRead) )
	{
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, (U32BIT)wTargetDataBlockReadAddress, sitalDeviceMemorySection_Ram, (U32BIT)wBufferSize, wapBuffer);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}

		hdbspDataBlock->dwNextAccessedDataWord = (U32BIT)(wOffset + wTotalNumberOfWordsToRead);
	}
	else
	{
		U16BIT wNumberOfWordsToReadFromTailOnCyclicWrap; // The number of words to read from the tail of given data block in case a cyclic wrap is required along copy.
		wNumberOfWordsToReadFromTailOnCyclicWrap = (hdbspDataBlock->wActualSize - wOffset);
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, (U32BIT)wTargetDataBlockReadAddress, sitalDeviceMemorySection_Ram, (U32BIT)wNumberOfWordsToReadFromTailOnCyclicWrap, wapBuffer);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}

		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, hdbspDataBlock->dwAddress, sitalDeviceMemorySection_Ram, (U32BIT)(wTotalNumberOfWordsToRead - wNumberOfWordsToReadFromTailOnCyclicWrap), (wapBuffer + wNumberOfWordsToReadFromTailOnCyclicWrap));
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}

		hdbspDataBlock->dwNextAccessedDataWord = (U32BIT)(wTotalNumberOfWordsToRead - wNumberOfWordsToReadFromTailOnCyclicWrap);
	}

	/// If given data block is a double data block:
	///		If given data block is mapped to some subaddress:
	///			If given data block is mapped to its subaddress for Rx/Broadcast:
	///			Flip the base address of the currently active data block in the entry of the mapped subaddress in given device lookup table.
	///			Enable double buffering with the subaddress that's mapped to given data block.
	if ( ((U16BIT)bcMemoryObjectSize_DOUBLE_DATA_BLOCK == hdbspDataBlock->wActualSize) && bIsDataBlockMapped )
	{
		if ((0U != hdbspDataBlock->dwRxSubaddressMapping) || (0U != hdbspDataBlock->dwBroadcastSubaddressMapping))
		{
			// Given data block is mapped to its subaddress for Rx/Broadcast.
			// Re-enable double buffering with the subaddress that's mapped to given data block.
			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, dwControlWordAddress, sitalDeviceMemorySection_Ram, 1U, &wSubaddressControlWord);
			if (sitalReturnCode_SUCCESS != swResult)
			{
				return swResult;
			}
			wSubaddressControlWord = (wSubaddressControlWord | (U16BIT)rtLookupTable_SUBADDRESS_CONTROL_WORD_MESSAGE_DOUBLE_OR_COMMON_DATA_BLOCK);
			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, dwControlWordAddress, sitalDeviceMemorySection_Ram, (U32BIT)1U, &wSubaddressControlWord);
			if (sitalReturnCode_SUCCESS != swResult)
			{
				return swResult;
			}
		}
	}

	return (S16BIT)wTotalNumberOfWordsToRead;
}


/// <summary>
/// Map given data block with given subaddress of given RT device for given message types.
/// Enable given interrupts with given subaddress.
/// If required, legalize given message types for:
/// - All mode code messages
/// - All messages of given subaddress
///
/// Note:
/// - Function sitalRt_Initialize illegalizes upon RT initialization messages for all address type, direction, subaddress, and word-count-or-mode-code combinations.
///   To legalize a specific combination, either of the following functions may be used, as appropriate: sitalRt_DataBlock_MapToSubaddress, sitalRt_MessageLegality_Enable.
/// - Message legalization should be configured using either functions sitalRt_MessageLegality_Enable/sitalRt_MessageLegality_Disable *OR* function sitalRt_DataBlock_MapToSubaddress, not both!
///   Using both to legalize/illegalize messages will disrupt the message legalization lookup table of the target RT!
///
/// Equivalent DDC definition: aceRTDataBlkMapToSA
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swDataBlockId (in)	A unique ID designating a data block (0-(sitalRtCounter_DATA_BLOCKS-1))
/// @param wSubaddress (in)	A RT subaddress (sitalRtSubaddress_1-sitalRtSubaddress_30)
/// @param wMessageTypes (in)	A set of message types(An or-ed combination of sitalRtMessageType_*)
/// @param wIrqOptions (in)	Required interrupts (An or-ed combination of sitalRtDataBlockIrq_*)
/// @param bIsSubaddressLegalizationRequested (in)	A flag that says whether given subaddress should be legalized
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Positive integer	ID of a data block with which a contradicting mapping already exists, OR given ID (in case required mapping already exists)
/// </summary>
S16BIT _DECL sitalRt_DataBlock_MapToSubaddress (	S16BIT swDevice,
													S16BIT swDataBlockId,
													U16BIT wSubaddress,
													U16BIT wMessageTypes,
													U16BIT wIrqOptions,
													U16BIT bIsSubaddressLegalizationRequested)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if ((sitalMode_RT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (((S16BIT)0U > swDataBlockId) || ((S16BIT)sitalRtCounter_DATA_BLOCKS <= swDataBlockId))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// If this function is now called to map the default data block of given RT device:
	///		Use the default data block of given RT device.
	/// Else (function called in regard with a regular RT data block):
	///		Use given regular RT data block.
	HostDataBlockStructure* hdbspDataBlock; // A pointer to a host data block structure.
	if (TRUE == dsspDeviceState->rms.rsRtState.bIsHandlingTheDefaultDataBlock)
	{
		hdbspDataBlock = &(dsspDeviceState->rms.rsRtState.hdbsDefaultDataBlock);

		swDataBlockId = -1;
	}
	else
	{
		hdbspDataBlock = &(dsspDeviceState->rms.rsRtState.hdbsaDataBlock[swDataBlockId]);
	}
	if (TRUE == hdbspDataBlock->bIsFreeForUse)
	{
		return sitalReturnCode_UNDEFINED_NODE;
	}

	if ((0U > wSubaddress) || (ieee1553_SUBADDRESS_BORDER <= wSubaddress))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if ((0U >= wMessageTypes) || (rtMessageType_BORDER <= wMessageTypes))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if ((0U > wIrqOptions) || (rtDataBlockIrq_BORDER <= wIrqOptions))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// If given data block is a bigger than normal data block and is not the current common circular data block:
	///		If given data block is already mapped with any subaddress for any message type:
	///			Return error.
	///		If mapping of given data block with more than single message type is requested:
	///			Return error.
	if (((U16BIT)bcMemoryObjectSize_NORMAL_DATA_BLOCK < hdbspDataBlock->wActualSize) && ((BOOLEAN)TRUE == dsspDeviceState->rms.rsRtState.bIsCommonCircularDataBlockUsed) && (dsspDeviceState->rms.rsRtState.wCommonCircularDataBlockId != (U16BIT)swDataBlockId))
	{
		if ((0U != hdbspDataBlock->dwRxSubaddressMapping) || (0U != hdbspDataBlock->dwTxSubaddressMapping) || (0U != hdbspDataBlock->dwBroadcastSubaddressMapping))
		{
			return sitalReturnCode_RT_DATA_BLOCK_MAPPED;
		}

		if ((sitalRtMessageType_RX != wMessageTypes) && (sitalRtMessageType_TX != wMessageTypes) && (sitalRtMessageType_BROADCAST != wMessageTypes))
		{
			return sitalReturnCode_INVALID_PARAMETER;
		}
	}

	HostDataBlockStructure* hdbspCurrentDataBlock; // A pointer to a host data block structure.
	hdbspCurrentDataBlock = dsspDeviceState->rms.rsRtState.hdbsaDataBlock;
	U32BIT dwSubaddressMask; // A mask designating a specific subaddress.
	dwSubaddressMask = (1U << wSubaddress);
	BOOLEAN bIsOlderMapping; // A flag that says whether a desired mapping contradicts some past mapping (or already exists).
	bIsOlderMapping = FALSE;
	U16BIT swCurrentDataBlockId; // A unique ID designating a data block.
	for (swCurrentDataBlockId=0; ((swCurrentDataBlockId < sitalRtCounter_DATA_BLOCKS) && (FALSE == bIsOlderMapping)); swCurrentDataBlockId++, hdbspCurrentDataBlock++)
	{
		if (FALSE == hdbspCurrentDataBlock->bIsFreeForUse)
		{
			bIsOlderMapping = (BOOLEAN)(bIsOlderMapping || (((U16BIT)sitalRtMessageType_RX == ((U16BIT)sitalRtMessageType_RX & wMessageTypes)) && (dwSubaddressMask == (dwSubaddressMask & hdbspCurrentDataBlock->dwRxSubaddressMapping))));
			bIsOlderMapping = (BOOLEAN)(bIsOlderMapping || (((U16BIT)sitalRtMessageType_TX == ((U16BIT)sitalRtMessageType_TX & wMessageTypes)) && (dwSubaddressMask == (dwSubaddressMask & hdbspCurrentDataBlock->dwTxSubaddressMapping))));
			bIsOlderMapping = (BOOLEAN)(bIsOlderMapping || (((U16BIT)sitalRtMessageType_BROADCAST == ((U16BIT)sitalRtMessageType_BROADCAST & wMessageTypes)) && (dwSubaddressMask == (dwSubaddressMask & hdbspCurrentDataBlock->dwBroadcastSubaddressMapping))));
		}
	}
	if (TRUE == bIsOlderMapping)
	{
		return swCurrentDataBlockId;
	}

	/// Find the device memory address of the control word of given subaddress.
	U16BIT wSubaddressControlWordAddress; // The device memory address of the control word of given subaddress.
	wSubaddressControlWordAddress = ((U16BIT)rtAddressMap_SUBADDRESS_LOOKUP_TABLE_SUBADDRESS_CONTROL_WORDS + wSubaddress);

	/// If given data block is a bigger than double data block and it isn't the current common circular data block:
	///		Map given circular data block with given subaddress for requested message types.
	if	(
				(bcMemoryObjectSize_DOUBLE_DATA_BLOCK < hdbspDataBlock->wActualSize)
			&&
				( ((BOOLEAN)FALSE == dsspDeviceState->rms.rsRtState.bIsCommonCircularDataBlockUsed) || (dsspDeviceState->rms.rsRtState.wCommonCircularDataBlockId != (U16BIT)swDataBlockId) )
		)
	{
		if (sitalRtMessageType_RX == (sitalRtMessageType_RX & wMessageTypes))
		{
			CircularDataBlockInformationStructure* cdbispRx; // Pointer to the information on the usage of circular data blocks with given RT device subaddress for Rx.
			cdbispRx = &(dsspDeviceState->rms.rsRtState.cdbisaSubaddressRxCommonCircularDataBlock[wSubaddress]);
			cdbispRx->bIsEnabled = TRUE;
			cdbispRx->dwAddress = hdbspDataBlock->dwAddress;
			cdbispRx->wActualSize = hdbspDataBlock->wActualSize;
		}

		if (sitalRtMessageType_TX == (sitalRtMessageType_TX & wMessageTypes))
		{
			CircularDataBlockInformationStructure* cdbispTx; // Pointer to the information on the usage of circular data blocks with given RT device subaddress for Rx.
			cdbispTx = &(dsspDeviceState->rms.rsRtState.cdbisaSubaddressTxCommonCircularDataBlock[wSubaddress]);
			cdbispTx->bIsEnabled = TRUE;
			cdbispTx->dwAddress = hdbspDataBlock->dwAddress;
			cdbispTx->wActualSize = hdbspDataBlock->wActualSize;
		}
	}

	/// Loop over all message types:
	///		If current message type is included in given message types:
	///			Update the current data block location in the entry in the subaddress lookup table which is dedicated for current message type and given subaddress.
	///			Calculate the value of the section of the subaddress control word that contains the memory mode bits.
	///			Properly set the section of the subaddress control word that contains the interrupt enabler bits.
	///			Properly set the section of the current message type in the subaddress control word.
	///			Calculate the portion of the subaddress control word that should not be changed along a mapping operation for current message type.
	///			Map given data block with given subaddress for current message type.
	///			If it is not the default data block that's currently handled:
	///				Cancel the potential past mapping of the default data block with given subaddress for current message type.
	///			Properly set the double or common circular data block enabler field in the subaddress control word.
	///			Appropriately update the subaddress control word of given subaddress.
	static U16BIT s_waMessageType[rtMessageType_COUNT] = {sitalRtMessageType_RX, sitalRtMessageType_TX, sitalRtMessageType_BROADCAST};
	static U16BIT s_waMessageTypeLookupTableAddress[rtMessageType_COUNT] = {rtAddressMap_SUBADDRESS_LOOKUP_TABLE_RX, rtAddressMap_SUBADDRESS_LOOKUP_TABLE_TX, rtAddressMap_SUBADDRESS_LOOKUP_TABLE_BROADCAST};
	static U16BIT s_waSubaddressControlWordMessageTypeOffset[rtMessageType_COUNT] = {rtLookupTable_OFFSET_OF_SUBADDRESS_CONTROL_WORD_MESSAGE_TYPE_RX, rtLookupTable_OFFSET_OF_SUBADDRESS_CONTROL_WORD_MESSAGE_TYPE_TX, rtLookupTable_OFFSET_OF_SUBADDRESS_CONTROL_WORD_MESSAGE_TYPE_BROADCAST};
	static U16BIT s_waSubaddressControlWordUnchangedPortion[rtMessageType_COUNT] = {rtLookupTable_SUBADDRESS_CONTROL_WORD_MESSAGE_TYPE_RX_COMPLEMENT, rtLookupTable_SUBADDRESS_CONTROL_WORD_MESSAGE_TYPE_TX_COMPLEMENT, rtLookupTable_SUBADDRESS_CONTROL_WORD_MESSAGE_TYPE_BROADCAST_COMPLEMENT};
	S16BIT swResult; // Result of operation or function call.
	for (S32BIT iCurrentMessageType=0; iCurrentMessageType<(S32BIT)rtMessageType_COUNT; iCurrentMessageType++)
	{
		if (s_waMessageType[iCurrentMessageType] == (s_waMessageType[iCurrentMessageType] & wMessageTypes))
		{
			// Update the current data block location in the entry in the subaddress lookup table which is dedicated for current message type and given subaddress.
			// Set it to the start address of given data block.
			U16BIT wSubaddressMessageTypeLookupTableAddress; // The address of the entry in the subaddress lookup table which is dedicated for current message type and given subaddress.
			wSubaddressMessageTypeLookupTableAddress = (s_waMessageTypeLookupTableAddress[iCurrentMessageType] + wSubaddress);
			U16BIT wIoContents; // The variable into which the contents of a device word is read, or the variable whose contents are written to device.
			wIoContents = (U16BIT)hdbspDataBlock->dwAddress;
			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, wSubaddressMessageTypeLookupTableAddress, sitalDeviceMemorySection_Ram, 1U, &wIoContents);
			if (sitalReturnCode_SUCCESS != swResult)
			{
				return swResult;
			}

			// Calculate the value of the section of the subaddress control word that contains the memory mode bits.
			U16BIT wSubaddressControlWord; // Subaddress control word.
			if (((BOOLEAN)TRUE == dsspDeviceState->rms.rsRtState.bIsCommonCircularDataBlockUsed) && (dsspDeviceState->rms.rsRtState.wCommonCircularDataBlockId == (U16BIT)swDataBlockId))
			{
				// Given data block is the current common circular buffer, use suitable memory mode bits.
				wSubaddressControlWord = 7U;
			}
			else
			{
				// Given data block isn't the current common circular buffer, use given data block's predefined memory mode bits.
				wSubaddressControlWord = hdbspDataBlock->wSubaddresControlWordMemoryModeBits;
			}

			// Properly set the section of the subaddress control word that contains the interrupt enabler bits.
			wSubaddressControlWord |= (wIrqOptions << rtLookupTable_OFFSET_OF_MESSAGE_TYPE_INTERRUPT_ENABLER);

			// Properly set the section of the current message type in the subaddress control word.
			wSubaddressControlWord <<= s_waSubaddressControlWordMessageTypeOffset[iCurrentMessageType];

			// Calculate the portion of the subaddress control word that should not be changed along a mapping operation for current message type.
			U16BIT wSubaddressControlWordUnchangedPortion; // The portion of the subaddress control word that should not be changed along a mapping operation for current message type.
			wSubaddressControlWordUnchangedPortion = s_waSubaddressControlWordUnchangedPortion[iCurrentMessageType];

			// Map given data block with given subaddress for current message type.
			// If it is not the default data block that's currently handled, cancel the potential past mapping of the default data block with given subaddress for current message type.
			switch (iCurrentMessageType)
			{
			case rtMessageType_RX:
				hdbspDataBlock->dwRxSubaddressMapping |= dwSubaddressMask;
				if (FALSE == dsspDeviceState->rms.rsRtState.bIsHandlingTheDefaultDataBlock)
				{
					dsspDeviceState->rms.rsRtState.hdbsDefaultDataBlock.dwRxSubaddressMapping &= (~dwSubaddressMask);
				}

				// Properly set the double or common circular data block enabler field in the subaddress control word.
				if ((TRUE == dsspDeviceState->rms.rsRtState.bIsCommonCircularDataBlockUsed) || (bcMemoryObjectSize_DOUBLE_DATA_BLOCK == hdbspDataBlock->wActualSize))
				{
					wSubaddressControlWord |= rtLookupTable_SUBADDRESS_CONTROL_WORD_MESSAGE_DOUBLE_OR_COMMON_DATA_BLOCK;
				}

				break;

			case rtMessageType_TX:
				hdbspDataBlock->dwTxSubaddressMapping |= dwSubaddressMask;
				if (FALSE == dsspDeviceState->rms.rsRtState.bIsHandlingTheDefaultDataBlock)
				{
					dsspDeviceState->rms.rsRtState.hdbsDefaultDataBlock.dwTxSubaddressMapping &= (~dwSubaddressMask);
				}

				// Fix the portion of the subaddress control word that should not be changed along a mapping operation for current message type:
				// With Tx messages, the current value of the double or common circular data block field should not be changed.
				wSubaddressControlWordUnchangedPortion |= rtLookupTable_SUBADDRESS_CONTROL_WORD_MESSAGE_DOUBLE_OR_COMMON_DATA_BLOCK;

				break;

			case rtMessageType_BROADCAST:
				hdbspDataBlock->dwBroadcastSubaddressMapping |= dwSubaddressMask;
				if (FALSE == dsspDeviceState->rms.rsRtState.bIsHandlingTheDefaultDataBlock)
				{
					dsspDeviceState->rms.rsRtState.hdbsDefaultDataBlock.dwBroadcastSubaddressMapping &= (~dwSubaddressMask);
				}

				// Fix the portion of the subaddress control word that should not be changed along a mapping operation for current message type:
				// With Broadcast messages, the bits of the double or common circular data block field may only be set.
				wSubaddressControlWordUnchangedPortion |= rtLookupTable_SUBADDRESS_CONTROL_WORD_MESSAGE_DOUBLE_OR_COMMON_DATA_BLOCK;

				// Properly set the common circular data block enabler field in the subaddress control word.
				if (TRUE == dsspDeviceState->rms.rsRtState.bIsCommonCircularDataBlockUsed)
				{
					wSubaddressControlWord |= rtLookupTable_SUBADDRESS_CONTROL_WORD_MESSAGE_DOUBLE_OR_COMMON_DATA_BLOCK;
				}

				break;

			default:
				// Irrelevant: All possible cases were already handled.
				break;
			}

			// Appropriately update the subaddress control word of given subaddress.
			U16BIT wCurrentSubaddressControlWord; // The current value of the subaddress control word of given subaddress.
			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, wSubaddressControlWordAddress, sitalDeviceMemorySection_Ram, 1U, &wCurrentSubaddressControlWord);
			if (sitalReturnCode_SUCCESS != swResult)
			{
				return swResult;
			}
			wSubaddressControlWord |= (wCurrentSubaddressControlWord & wSubaddressControlWordUnchangedPortion);
			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, wSubaddressControlWordAddress, sitalDeviceMemorySection_Ram, 1U, &wSubaddressControlWord);
			if (sitalReturnCode_SUCCESS != swResult)
			{
				return swResult;
			}
		}
	}

	/// If the legalization of given subaddress is requested:
	///		Legalize given subaddress with all given message types (j.e., all relevant directions), all relevant word counts, and both mode codes.
	if ((U16BIT)0U != bIsSubaddressLegalizationRequested)
	{
		// Legalize given subaddress with all given message types.
		// With all message types legalize for given subaddress and also for both mode codes.
		// With broadcast messages use the broadcast address, and legalize for both directions.
		if (sitalRtMessageType_RX == (sitalRtMessageType_RX & wMessageTypes))
		{
			swResult = sitalRt_MessageLegality_Enable (swDevice, sitalRtAddressType_OWN, sitalMessageDirection_RX, wSubaddress, hdbspDataBlock->dwWordCountOrModeCodeMask);
			swResult = sitalRt_MessageLegality_Enable (swDevice, sitalRtAddressType_OWN, sitalMessageDirection_RX, sital1553_MODE_CODE1, sitalWordCountOrModeCodeMask_ALL);
			swResult = sitalRt_MessageLegality_Enable (swDevice, sitalRtAddressType_OWN, sitalMessageDirection_RX, sital1553_MODE_CODE2, sitalWordCountOrModeCodeMask_ALL);
		}

		if (sitalRtMessageType_TX == (sitalRtMessageType_TX & wMessageTypes))
		{
			swResult = sitalRt_MessageLegality_Enable (swDevice, sitalRtAddressType_OWN, sitalMessageDirection_TX, wSubaddress, hdbspDataBlock->dwWordCountOrModeCodeMask);
			swResult = sitalRt_MessageLegality_Enable (swDevice, sitalRtAddressType_OWN, sitalMessageDirection_TX, sital1553_MODE_CODE1, sitalWordCountOrModeCodeMask_ALL);
			swResult = sitalRt_MessageLegality_Enable (swDevice, sitalRtAddressType_OWN, sitalMessageDirection_TX, sital1553_MODE_CODE2, sitalWordCountOrModeCodeMask_ALL);
		}

		if (sitalRtMessageType_BROADCAST == (sitalRtMessageType_BROADCAST & wMessageTypes))
		{
			swResult = sitalRt_MessageLegality_Enable (swDevice, sitalRtAddressType_BROADCAST, sitalMessageDirection_RX, wSubaddress, hdbspDataBlock->dwWordCountOrModeCodeMask);
			swResult = sitalRt_MessageLegality_Enable (swDevice, sitalRtAddressType_BROADCAST, sitalMessageDirection_TX, wSubaddress, hdbspDataBlock->dwWordCountOrModeCodeMask);
			swResult = sitalRt_MessageLegality_Enable (swDevice, sitalRtAddressType_BROADCAST, sitalMessageDirection_RX, sital1553_MODE_CODE1, sitalWordCountOrModeCodeMask_ALL);
			swResult = sitalRt_MessageLegality_Enable (swDevice, sitalRtAddressType_BROADCAST, sitalMessageDirection_TX, sital1553_MODE_CODE1, sitalWordCountOrModeCodeMask_ALL);
			swResult = sitalRt_MessageLegality_Enable (swDevice, sitalRtAddressType_BROADCAST, sitalMessageDirection_RX, sital1553_MODE_CODE2, sitalWordCountOrModeCodeMask_ALL);
			swResult = sitalRt_MessageLegality_Enable (swDevice, sitalRtAddressType_BROADCAST, sitalMessageDirection_TX, sital1553_MODE_CODE2, sitalWordCountOrModeCodeMask_ALL);
		}
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Unmap given data block with given subaddress of given RT device for given message types.
///
/// Equivalent DDC definition: aceRTDataBlkUnmapFromSA
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param swDataBlockId (in)	A unique ID designating a data block (0-(sitalRtCounter_DATA_BLOCKS-1))
/// @param wSubaddress (in)	A RT subaddress (sitalRtSubaddress_1-sitalRtSubaddress_30)
/// @param wMessageTypes (in)	A set of message types(An or-ed combination of sitalRtMessageType_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRt_DataBlock_UnmapFromSubaddress (	S16BIT swDevice,
														S16BIT swDataBlockId,
														U16BIT wSubaddress,
														U16BIT wMessageTypes)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if ((sitalMode_RT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (((S16BIT)0U > swDataBlockId) || ((S16BIT)sitalRtCounter_DATA_BLOCKS <= swDataBlockId))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	HostDataBlockStructure* hdbspDataBlock; // A pointer to a host data block structure.
	hdbspDataBlock = &(dsspDeviceState->rms.rsRtState.hdbsaDataBlock[swDataBlockId]);
	if (TRUE == hdbspDataBlock->bIsFreeForUse)
	{
		return sitalReturnCode_UNDEFINED_NODE;
	}

	if ((0U > wSubaddress) || (ieee1553_SUBADDRESS_BORDER <= wSubaddress))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if ((0U >= wMessageTypes) || (rtMessageType_BORDER <= wMessageTypes))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Find the device memory address of the control word of given subaddress.
	U16BIT wSubaddressControlWordAddress; // The device memory address of the control word of given subaddress.
	wSubaddressControlWordAddress = ((U16BIT)rtAddressMap_SUBADDRESS_LOOKUP_TABLE_SUBADDRESS_CONTROL_WORDS + wSubaddress);

	/// Loop over all message types:
	///		If current message type is included in given message types:
	///			Update the current data block location in the entry in the subaddress lookup table which is dedicated for current message type and given subaddress.
	///			Calculate the portion of the subaddress control word that should not be changed along a mapping operation for current message type.
	///			Unmap given data block with given subaddress for current message type.
	///			Map the default data block with given subaddress for current message type.
	///			Properly set the double or common circular data block enabler field in the subaddress control word.
	///			Appropriately update the subaddress control word of given subaddress.
	static U16BIT s_waMessageType[rtMessageType_COUNT] = {sitalRtMessageType_RX, sitalRtMessageType_TX, sitalRtMessageType_BROADCAST};
	static U16BIT s_waMessageTypeLookupTableAddress[rtMessageType_COUNT] = {rtAddressMap_SUBADDRESS_LOOKUP_TABLE_RX, rtAddressMap_SUBADDRESS_LOOKUP_TABLE_TX, rtAddressMap_SUBADDRESS_LOOKUP_TABLE_BROADCAST};
	static U16BIT s_waSubaddressControlWordUnchangedPortion[rtMessageType_COUNT] = {rtLookupTable_SUBADDRESS_CONTROL_WORD_MESSAGE_TYPE_RX_COMPLEMENT, rtLookupTable_SUBADDRESS_CONTROL_WORD_MESSAGE_TYPE_TX_COMPLEMENT, rtLookupTable_SUBADDRESS_CONTROL_WORD_MESSAGE_TYPE_BROADCAST_COMPLEMENT};
	U32BIT dwSubaddressMask; // A mask designating a specific subaddress.
	dwSubaddressMask = (1U << wSubaddress);
	for (S32BIT iCurrentMessageType=0; iCurrentMessageType<(S16BIT)rtMessageType_COUNT; iCurrentMessageType++)
	{
		if (s_waMessageType[iCurrentMessageType] == (s_waMessageType[iCurrentMessageType] & wMessageTypes))
		{
			// Update the current data block location in the entry in the subaddress lookup table which is dedicated for current message type and given subaddress.
			// Set it to the start address of the default data block.
			U16BIT wSubaddressMessageTypeLookupTableAddress; // The address of the entry in the subaddress lookup table which is dedicated for current message type and given subaddress.
			wSubaddressMessageTypeLookupTableAddress = (s_waMessageTypeLookupTableAddress[iCurrentMessageType] + wSubaddress);
			U16BIT wIoContents; // The variable into which the contents of a device word is read, or the variable whose contents are written to device.
			wIoContents = ((U16BIT)(dsspDeviceState->rms.rsRtState.hdbsDefaultDataBlock.dwAddress));
			S16BIT swResult; // Result of operation or function call.
			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, wSubaddressMessageTypeLookupTableAddress, sitalDeviceMemorySection_Ram, 1U, &wIoContents);
			if (sitalReturnCode_SUCCESS != swResult)
			{
				return swResult;
			}

			// Calculate the portion of the subaddress control word that should not be changed along a mapping operation for current message type.
			U16BIT wSubaddressControlWordUnchangedPortion; // The portion of the subaddress control word that should not be changed along a mapping operation for current message type.
			wSubaddressControlWordUnchangedPortion = s_waSubaddressControlWordUnchangedPortion[iCurrentMessageType];

			// Unmap given data block with given subaddress for current message type.
			// Map the default data block with given subaddress for current message type.
			switch (iCurrentMessageType)
			{
			case rtMessageType_RX:
				hdbspDataBlock->dwRxSubaddressMapping &= (~dwSubaddressMask);
				dsspDeviceState->rms.rsRtState.hdbsDefaultDataBlock.dwRxSubaddressMapping |= dwSubaddressMask;

				break;

			case rtMessageType_TX:
				hdbspDataBlock->dwTxSubaddressMapping &= (~dwSubaddressMask);
				dsspDeviceState->rms.rsRtState.hdbsDefaultDataBlock.dwTxSubaddressMapping |= dwSubaddressMask;

				// Fix the portion of the subaddress control word that should not be changed along a mapping operation for current message type:
				// With Tx messages, the current value of the double or common circular data block field should not be changed.
				wSubaddressControlWordUnchangedPortion |= rtLookupTable_SUBADDRESS_CONTROL_WORD_MESSAGE_DOUBLE_OR_COMMON_DATA_BLOCK;

				break;

			case rtMessageType_BROADCAST:
				hdbspDataBlock->dwBroadcastSubaddressMapping &= (~dwSubaddressMask);
				dsspDeviceState->rms.rsRtState.hdbsDefaultDataBlock.dwBroadcastSubaddressMapping |= dwSubaddressMask;

				// Fix the portion of the subaddress control word that should not be changed along a mapping operation for current message type:
				// With Broadcast messages, the bits of the double or common circular data block field may only be set.
				wSubaddressControlWordUnchangedPortion |= rtLookupTable_SUBADDRESS_CONTROL_WORD_MESSAGE_DOUBLE_OR_COMMON_DATA_BLOCK;

				break;

			default:
				// Irrelevant: All possible cases were already handled.
				break;
			}

			// Appropriately update the subaddress control word of given subaddress.
			U16BIT wCurrentSubaddressControlWord; // The current value of the subaddress control word of given subaddress.
			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, wSubaddressControlWordAddress, sitalDeviceMemorySection_Ram, 1U, &wCurrentSubaddressControlWord);
			if (sitalReturnCode_SUCCESS != swResult)
			{
				return swResult;
			}
			U16BIT wSubaddressControlWord; // Subaddress control word.
			wSubaddressControlWord = (wCurrentSubaddressControlWord & wSubaddressControlWordUnchangedPortion);
			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, wSubaddressControlWordAddress, sitalDeviceMemorySection_Ram, 1U, &wSubaddressControlWord);
			if (sitalReturnCode_SUCCESS != swResult)
			{
				return swResult;
			}
		}
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Set given RT device to generate given interrupts upon reception of given mode codes messages.
///
/// Note:
/// - Entries in the mode code selective interrupt table are addressed by appending the 3-bit value formed by
///   broadcast, T/R* bit, and mode code bit 4 to the base address of the mode code selective interrupt table.
/// - The bit location within the addressed word-entry of the mode code selective interrupt table that determines
///   if the given mode command will generate an interrupt is specified by the 4-bit value formed by mode code bits 3-0.
/// - An interrupt bit that is set on will cause the device to generate an interrupt at the end of the trigerring message.
/// - Some of the possible command word combinations are invalid.
///   Though, as long as the command word meets the IEEE-1553 criteria for word validation, the interrupt will be generated,
///   even if the particular command is illegal or invalid.
///
/// Equivalent DDC definition: aceRTModeCodeIrqEnable
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wModeCodeType (in)	A type of mode code (sitalRtModeCodeType_*)
/// @param wModeCodeIrq (in)	A set of mode code interrupts (An or-ed combination of sitalRtModeCodeIrq_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRt_ModeCode_EnableIrq (S16BIT swDevice, U16BIT wModeCodeType, U16BIT wModeCodeIrq)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalMode_RT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((0U > wModeCodeType) || (rtModeCodeType_BORDER <= wModeCodeType))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if (0U > wModeCodeIrq)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Find the address of the entry of the mode code selective interrupt table that corresponds given type of mode code.
	U16BIT wModeCodeInterruptTableEntryAddress; // The address of the entry of the mode code selective interrupt table that corresponds given type of mode code.
	wModeCodeInterruptTableEntryAddress = ((U16BIT)rtAddressMap_MODE_CODE_SELECTIVE_INTERRUPT_TABLE + wModeCodeType);

	/// Appropriately update the mode code selective interrupt table.
	U16BIT wCurrentModeCodeInterruptTableEntry; // The current value of the entry of the mode code selective interrupt table that corresponds given type of mode code.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, wModeCodeInterruptTableEntryAddress, sitalDeviceMemorySection_Ram, 1U, &wCurrentModeCodeInterruptTableEntry);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	U16BIT wModeCodeInterruptTableEntry; // The value of the entry of the mode code selective interrupt table that corresponds given type of mode code.
	wModeCodeInterruptTableEntry = (wCurrentModeCodeInterruptTableEntry | wModeCodeIrq);
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, wModeCodeInterruptTableEntryAddress, sitalDeviceMemorySection_Ram, 1U, &wModeCodeInterruptTableEntry);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Set given RT device to stop the issue of given interrupts upon reception of given mode codes messages.
///
/// Note:
/// - Entries in the mode code selective interrupt table are addressed by appending the 3-bit value formed by
///   broadcast, T/R* bit, and mode code bit 4 to the base address of the mode code selective interrupt table.
/// - The bit location within the addressed word-entry of the mode code selective interrupt table that determines
///   if the given mode command will generate an interrupt is specified by the 4-bit value formed by mode code bits 3-0.
/// - An interrupt bit that is set off will cause the device to avoid the generation of an interrupt at the end of the trigerring message.
///
/// Equivalent DDC definition: aceRTModeCodeIrqDisable
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wModeCodeType (in)	A type of mode code (sitalRtModeCodeType_*)
/// @param wModeCodeIrq (in)	A set of mode code interrupts (An or-ed combination of sitalRtModeCodeIrq_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRt_ModeCode_DisableIrq (S16BIT swDevice, U16BIT wModeCodeType, U16BIT wModeCodeIrq)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalMode_RT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((0U > wModeCodeType) || (rtModeCodeType_BORDER <= wModeCodeType))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if (0U > wModeCodeIrq)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Find the address of the entry of the mode code selective interrupt table that corresponds given type of mode code.
	U16BIT wModeCodeInterruptTableEntryAddress; // The address of the entry of the mode code selective interrupt table that corresponds given type of mode code.
	wModeCodeInterruptTableEntryAddress = ((U16BIT)rtAddressMap_MODE_CODE_SELECTIVE_INTERRUPT_TABLE + wModeCodeType);

	/// Appropriately update the mode code selective interrupt table.
	U16BIT wCurrentModeCodeInterruptTableEntry; // The current value of the entry of the mode code selective interrupt table that corresponds given type of mode code.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, wModeCodeInterruptTableEntryAddress, sitalDeviceMemorySection_Ram, 1U, &wCurrentModeCodeInterruptTableEntry);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	U16BIT wModeCodeInterruptTableEntry; // The value of the entry of the mode code selective interrupt table that corresponds given type of mode code.
	wModeCodeInterruptTableEntry = (wCurrentModeCodeInterruptTableEntry & (~wModeCodeIrq));
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, wModeCodeInterruptTableEntryAddress, sitalDeviceMemorySection_Ram, 1U, &wModeCodeInterruptTableEntry);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Let know whether given RT device is currently configured to generate any interrupts upon reception of given mode codes messages.
///
/// Note:
/// - See the notes for function sitalRt_ModeCode_DisableIrq.
///
/// Equivalent DDC definition: aceRTModeCodeIrqStatus
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wModeCodeType (in)	A type of mode code (sitalRtModeCodeType_*)
/// @param wpModeCodeIrq (out)	A pointer to a variable in which the currently configured set of mode code interrupts is returned (An or-ed combination of sitalRtModeCodeIrq_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRt_ModeCode_GetIrq (S16BIT swDevice, U16BIT wModeCodeType, U16BIT* wpModeCodeIrq)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalMode_RT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((0U > wModeCodeType) || (rtModeCodeType_BORDER <= wModeCodeType))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if (((U16BIT*)NULL) == wpModeCodeIrq)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Find the address of the entry of the mode code selective interrupt table that corresponds given type of mode code.
	U16BIT wModeCodeInterruptTableEntryAddress; // The address of the entry of the mode code selective interrupt table that corresponds given type of mode code.
	wModeCodeInterruptTableEntryAddress = ((U16BIT)rtAddressMap_MODE_CODE_SELECTIVE_INTERRUPT_TABLE + wModeCodeType);

	/// Get the current value of the entry of the mode code selective interrupt table that corresponds given type of mode code.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, wModeCodeInterruptTableEntryAddress, sitalDeviceMemorySection_Ram, 1U, wpModeCodeIrq);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Read the data for given mode code from the mode code data locations table of given RT device.
///
/// Note:
/// - The data word that's received in mode code messages with data is stored both:
///   - At the suitable entry of the mode code table.
///   - Instead of a data pointer at the dedicated entry in the command stack.
///
/// Equivalent DDC definition: aceRTModeCodeReadData
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wDataContainingModeCode (in)	A data containing mode code (>=0, <sitalRtCounter_MODE_CODES)
/// @param wpData (out)	A pointer to a variable in which the data is returned
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRt_ModeCode_ReadData (S16BIT swDevice, U16BIT wDataContainingModeCode, U16BIT* wpData)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalMode_RT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((0U > wDataContainingModeCode) || (sitalRtCounter_MODE_CODES <= wDataContainingModeCode))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if (((U16BIT*)NULL) == wpData)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Find the address of the entry of the mode code selective interrupt table that corresponds given type of mode code.
	U16BIT wModeCodeDataTableEntryAddress; // The address of the entry of the mode code selective interrupt table that corresponds given type of mode code.
	wModeCodeDataTableEntryAddress = ((U16BIT)rtAddressMap_MODE_CODE_DATA_TABLE + wDataContainingModeCode);

	/// Get the data currently stored in the entry of the mode code data table that corresponds given type of data containing mode code.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, wModeCodeDataTableEntryAddress, sitalDeviceMemorySection_Ram, 1U, wpData);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Write given data for given mode code in the mode code data locations table of given RT device.
///
/// Equivalent DDC definition: aceRTModeCodeWriteData
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wDataContainingModeCode (in)	A data-containing mode code (>=0, <sitalRtCounter_MODE_CODES)
/// @param wData (in)	The data word to write
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRt_ModeCode_WriteData (S16BIT swDevice, U16BIT wDataContainingModeCode, U16BIT wData)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalMode_RT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((0U > wDataContainingModeCode) || (sitalRtCounter_MODE_CODES <= wDataContainingModeCode))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Find the address of the entry of the mode code selective interrupt table that corresponds given type of mode code.
	U16BIT wModeCodeDataTableEntryAddress; // The address of the entry of the mode code selective interrupt table that corresponds given type of mode code.
	wModeCodeDataTableEntryAddress = ((U16BIT)rtAddressMap_MODE_CODE_DATA_TABLE + wDataContainingModeCode);

	/// Get the data currently stored in the entry of the mode code data table that corresponds given type of data containing mode code.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, wModeCodeDataTableEntryAddress, sitalDeviceMemorySection_Ram, 1U, &wData);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Legalize messages received by given RT device if they suit given criteria.
///
/// Note:
/// - The command illegalization table is a 256-word area in device memory.
///   It allows any subset of the 4096 possible combinations of broadcast / own address, Tx / Rx bit, subaddress, and word count / mode code to be either legalized or illegalized.
/// - Function sitalRt_Initialize illegalizes upon RT initialization messages for all address type, direction, subaddress, and word-count-or-mode-code combinations.
///   To legalize a specific combination, either of the following functions may be used, as appropriate: sitalRt_DataBlock_MapToSubaddress, sitalRt_MessageLegality_Enable.
/// - Message legalization should be configured using either functions sitalRt_MessageLegality_Enable/sitalRt_MessageLegality_Disable *OR* function sitalRt_DataBlock_MapToSubaddress, not both!
///   Using both to legalize/illegalize messages will disrupt the message legalization lookup table of the target RT!
///
/// Equivalent DDC definition: aceRTMsgLegalityEnable
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wOwnAddressOrBroadcast (in)	Message destination selection set (An or-ed combination of sitalRtAddressType_*)
/// @param wMessageDirection (in)	RT-related message direction (sitalMessageDirection_*)
/// @param wSubaddress (in)	Subaddress (sitalRtSubaddress_*)
/// @param dwWordCountOrModeCodeMask (in)	Word count or mode code mask (A bitwise mask in which bit-0 / bit-j>0 is on for messages containing 32 / j data words, respectively)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRt_MessageLegality_Enable (	S16BIT swDevice,
												U16BIT wOwnAddressOrBroadcast,
												U16BIT wMessageDirection,
												U16BIT wSubaddress,
												U32BIT dwWordCountOrModeCodeMask)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalMode_RT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	BOOLEAN bIsLegalParameter; // A flag that says whether an input parameter is legal.
	switch (wOwnAddressOrBroadcast)
	{
	case sitalRtAddressType_BROADCAST:
	case sitalRtAddressType_OWN:
	case sitalRtAddressType_BOTH:
		bIsLegalParameter = TRUE;
		break;
	default:
		bIsLegalParameter = FALSE;
		break;
	}
	if (FALSE == bIsLegalParameter)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	switch (wMessageDirection)
	{
	case sitalMessageDirection_RX:
	case sitalMessageDirection_TX:
	case sitalMessageDirection_BOTH:
		bIsLegalParameter = TRUE;
		break;
	default:
		bIsLegalParameter = FALSE;
		break;
	}
	if (FALSE == bIsLegalParameter)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if ((0U > wSubaddress) || ((rtSubaddress_BORDER <= wSubaddress) && (sitalRtSubaddress_ALL != wSubaddress)))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Set loop delimiters for the direction, address type, and subaddress loops.
	U16BIT wDirectionLoopBase; // Base value of direction loop.
	U16BIT wDirectionLoopBorder; // Border value of direction loop.
	if (sitalMessageDirection_BOTH == wMessageDirection)
	{
		wDirectionLoopBase = 0U;
		wDirectionLoopBorder = messageDirection_BORDER;
	}
	else
	{
		wDirectionLoopBase = wMessageDirection;
		wDirectionLoopBorder = (wMessageDirection + (U16BIT)1U);
	}

	U16BIT wAddressLoopBase; // Base value of address loop.
	U16BIT wAddressLoopBorder; // Border value of address loop.
	if (sitalRtAddressType_BOTH == wOwnAddressOrBroadcast)
	{
		wAddressLoopBase = 0U;
		wAddressLoopBorder = rtAddressType_BORDER;
	}
	else
	{
		wAddressLoopBase = wOwnAddressOrBroadcast;
		wAddressLoopBorder = (wOwnAddressOrBroadcast + (U16BIT)1U);
	}

	U16BIT wSubaddressLoopBase; // Base value of subaddress loop.
	U16BIT wSubaddressLoopBorder; // Border value of subaddress loop.
	if (sitalRtSubaddress_ALL == wSubaddress)
	{
		wSubaddressLoopBase = 0U;
		wSubaddressLoopBorder = rtSubaddress_BORDER;
	}
	else
	{
		wSubaddressLoopBase = wSubaddress;
		wSubaddressLoopBorder = (wSubaddress + (U16BIT)1U);
	}

	/// Loop over all given combinations of direction, address type, and subaddress:
	///		Update each combination's illegalization specifications.
	for (S32BIT iDirection=(S32BIT)wDirectionLoopBase; iDirection<(S32BIT)wDirectionLoopBorder; iDirection++)
	{
		for (S32BIT iAddress=(S32BIT)wAddressLoopBase; iAddress<(S32BIT)wAddressLoopBorder; iAddress++)
		{
			for (S32BIT iSubaddress=(S32BIT)wSubaddressLoopBase; iSubaddress<(S32BIT)wSubaddressLoopBorder; iSubaddress++)
			{
				// Find the address of the entry of the target table that corresponds current combination.
				U16BIT wTableEntryAddress; // The address of an entry in the target table.
				wTableEntryAddress = ((U16BIT)rtAddressMap_COMMAND_ILLEGALIZATION_TABLE | (U16BIT)(iDirection << rtCommandIllegalizationTable_OFFSET_OF_DIRECTION) | (U16BIT)(iAddress << rtCommandIllegalizationTable_OFFSET_OF_ADDRESS_TYPE) | (U16BIT)(iSubaddress << rtCommandIllegalizationTable_OFFSET_OF_SUBADDRESS));

				// Calculate the new mask.
				U16BIT wMaskLowWord; // The value of the least significant word of the new mask.
				U16BIT wMaskHighWord; // The value of the most significant word of the new mask.
				U32BIT dwNewMask; // The value of the new illegalization mask.
				S16BIT swResult; // Result of operation or function call.
				swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, wTableEntryAddress, sitalDeviceMemorySection_Ram, 1U, &wMaskLowWord);
				if (sitalReturnCode_SUCCESS != swResult)
				{
					return swResult;
				}
				swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, (wTableEntryAddress + 1U), sitalDeviceMemorySection_Ram, 1U, &wMaskHighWord);
				if (sitalReturnCode_SUCCESS != swResult)
				{
					return swResult;
				}
				dwNewMask = wMaskHighWord;
				dwNewMask = ((dwNewMask << 16U) | wMaskLowWord);
				dwNewMask &= (~dwWordCountOrModeCodeMask);

				// Write the new mask in the entry of the target table that corresponds current combination.
				wMaskLowWord = (U16BIT)(dwNewMask & 0xFFFFU);
				wMaskHighWord = (U16BIT)(dwNewMask >> 16U);
				swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, wTableEntryAddress, sitalDeviceMemorySection_Ram, 1U, &wMaskLowWord);
				if (sitalReturnCode_SUCCESS != swResult)
				{
					return swResult;
				}
				swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, (wTableEntryAddress + 1U), sitalDeviceMemorySection_Ram, 1U, &wMaskHighWord);
				if (sitalReturnCode_SUCCESS != swResult)
				{
					return swResult;
				}
			}
		}
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Illegalize messages received by given RT device if they suit given criteria.
///
/// Note:
/// - The command illegalization table is a 256-word area in device memory.
///   It allows any subset of the 4096 possible combinations of broadcast / own address, Tx / Rx bit, subaddress, and word count / mode code to be illegalized.
/// - Function sitalRt_Initialize illegalizes upon RT initialization messages for all address type, direction, subaddress, and word-count-or-mode-code combinations.
///   To legalize a specific combination, either of the following functions may be used, as appropriate: sitalRt_DataBlock_MapToSubaddress, sitalRt_MessageLegality_Enable.
/// - Message legalization should be configured using either functions sitalRt_MessageLegality_Enable/sitalRt_MessageLegality_Disable *OR* function sitalRt_DataBlock_MapToSubaddress, not both!
///   Using both to legalize/illegalize messages will disrupt the message legalization lookup table of the target RT!
///
/// Equivalent DDC definition: aceRTMsgLegalityDisable
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wOwnAddressOrBroadcast (in)	Message destination selection set (An or-ed combination of sitalRtAddressType_*)
/// @param wMessageDirection (in)	RT-related message direction (sitalMessageDirection_*)
/// @param wSubaddress (in)	Subaddress (sitalRtSubaddress_*)
/// @param dwWordCountOrModeCodeMask (in)	Word count or mode code mask (A bitwise mask in which bit-0 / bit-j>0 is on for messages containing 32 / j data words, respectively)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRt_MessageLegality_Disable (	S16BIT swDevice,
												U16BIT wOwnAddressOrBroadcast,
												U16BIT wMessageDirection,
												U16BIT wSubaddress,
												U32BIT dwWordCountOrModeCodeMask)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalMode_RT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	BOOLEAN bIsLegalParameter; // A flag that says whether an input parameter is legal.
	switch (wOwnAddressOrBroadcast)
	{
	case sitalRtAddressType_BROADCAST:
	case sitalRtAddressType_OWN:
	case sitalRtAddressType_BOTH:
		bIsLegalParameter = TRUE;
		break;
	default:
		bIsLegalParameter = FALSE;
		break;
	}
	if (FALSE == bIsLegalParameter)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	switch (wMessageDirection)
	{
	case sitalMessageDirection_RX:
	case sitalMessageDirection_TX:
	case sitalMessageDirection_BOTH:
		bIsLegalParameter = TRUE;
		break;
	default:
		bIsLegalParameter = FALSE;
		break;
	}
	if (FALSE == bIsLegalParameter)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if ((0U > wSubaddress) || ((rtSubaddress_BORDER <= wSubaddress) && (sitalRtSubaddress_ALL != wSubaddress)))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Set loop delimiters for the direction, address type, and subaddress illegalization loops.
	U16BIT wDirectionLoopBase; // Base value of direction loop.
	U16BIT wDirectionLoopBorder; // Border value of direction loop.
	if (sitalMessageDirection_BOTH == wMessageDirection)
	{
		wDirectionLoopBase = 0U;
		wDirectionLoopBorder = messageDirection_BORDER;
	}
	else
	{
		wDirectionLoopBase = wMessageDirection;
		wDirectionLoopBorder = (wMessageDirection + (U16BIT)1U);
	}

	U16BIT wAddressLoopBase; // Base value of address loop.
	U16BIT wAddressLoopBorder; // Border value of address loop.
	if (sitalRtAddressType_BOTH == wOwnAddressOrBroadcast)
	{
		wAddressLoopBase = 0U;
		wAddressLoopBorder = rtAddressType_BORDER;
	}
	else
	{
		wAddressLoopBase = wOwnAddressOrBroadcast;
		wAddressLoopBorder = (wOwnAddressOrBroadcast + (U16BIT)1U);
	}

	U16BIT wSubaddressLoopBase; // Base value of subaddress loop.
	U16BIT wSubaddressLoopBorder; // Border value of subaddress loop.
	if (sitalRtSubaddress_ALL == wSubaddress)
	{
		wSubaddressLoopBase = 0U;
		wSubaddressLoopBorder = rtSubaddress_BORDER;
	}
	else
	{
		wSubaddressLoopBase = wSubaddress;
		wSubaddressLoopBorder = (wSubaddress + (U16BIT)1U);
	}

	/// Loop over all given combinations of direction, address type, and subaddress:
	///		Update each combination's illegalization specifications.
	for (S32BIT iDirection=(S32BIT)wDirectionLoopBase; iDirection<(S32BIT)wDirectionLoopBorder; iDirection++)
	{
		for (S32BIT iAddress=(S32BIT)wAddressLoopBase; iAddress<(S32BIT)wAddressLoopBorder; iAddress++)
		{
			for (U16BIT uiSubaddress=(S32BIT)wSubaddressLoopBase; uiSubaddress<(S32BIT)wSubaddressLoopBorder; uiSubaddress++)
			{
				// Find the address of the entry of the target table that corresponds current combination.
				U16BIT wTableEntryAddress; // The address of an entry in the target table.
				wTableEntryAddress = ((U16BIT)rtAddressMap_COMMAND_ILLEGALIZATION_TABLE | (U16BIT)(iDirection << rtCommandIllegalizationTable_OFFSET_OF_DIRECTION) | (U16BIT)(iAddress << rtCommandIllegalizationTable_OFFSET_OF_ADDRESS_TYPE) | (U16BIT)(uiSubaddress << rtCommandIllegalizationTable_OFFSET_OF_SUBADDRESS));

				// Calculate the new mask.
				U16BIT wMaskLowWord; // The value of the least significant word of the new mask.
				U16BIT wMaskHighWord; // The value of the most significant word of the new mask.
				U32BIT dwNewMask; // The value of the new illegalization mask.
				S16BIT swResult; // Result of operation or function call.
				swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, wTableEntryAddress, sitalDeviceMemorySection_Ram, 1U, &wMaskLowWord);
				if (sitalReturnCode_SUCCESS != swResult)
				{
					return swResult;
				}
				swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, (wTableEntryAddress + 1U), sitalDeviceMemorySection_Ram, 1U, &wMaskHighWord);
				if (sitalReturnCode_SUCCESS != swResult)
				{
					return swResult;
				}
				dwNewMask = wMaskHighWord;
				dwNewMask = ((dwNewMask << 16U) | wMaskLowWord);
				dwNewMask |= dwWordCountOrModeCodeMask;

				// Write the new mask in the entry of the target table that corresponds current combination.
				wMaskLowWord = (U16BIT)(dwNewMask & 0xFFFFU);
				wMaskHighWord = (U16BIT)(dwNewMask >> 16U);
				swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, wTableEntryAddress, sitalDeviceMemorySection_Ram, 1U, &wMaskLowWord);
				if (sitalReturnCode_SUCCESS != swResult)
				{
					return swResult;
				}
				swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, (wTableEntryAddress + 1U), sitalDeviceMemorySection_Ram, 1U, &wMaskHighWord);
				if (sitalReturnCode_SUCCESS != swResult)
				{
					return swResult;
				}
			}
		}
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Get the current legalization state of messages received by given RT device if they suit given criteria.
///
/// Note:
/// - The command illegalization table is a 256-word area in device memory.
///   It allows any subset of the 4096 possible combinations of broadcast / own address, Tx / Rx bit, subaddress, and word count / mode code to be illegalized.
///
/// Equivalent DDC definition: aceRTMsgLegalityStatus
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wOwnAddressOrBroadcast (in)	Message destination selection set (sitalRtAddressType_BROADCAST or sitalRtAddressType_OWN)
/// @param wMessageDirection (in)	RT-related message direction (sitalMessageDirection_RX or sitalMessageDirection_TX)
/// @param wSubaddress (in)	Subaddress (0-31)
/// @param dwWordCountOrModeCodeMask (in)	Word count or mode code mask (A bitwise mask in which bit-0 / bit-j>0 is on for messages containing 32 / j data words, respectively)
/// @param dwpMessageLegality (out)	A pointer to a variable in which the value of the message legality is returned
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRt_MessageLegality_GetStatus (	S16BIT swDevice,
													U16BIT wOwnAddressOrBroadcast,
													U16BIT wMessageDirection,
													U16BIT wSubaddress,
													U32BIT* dwpMessageLegality)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalMode_RT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((0U > wOwnAddressOrBroadcast) || (rtAddressType_BORDER <= wOwnAddressOrBroadcast))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if ((0U > wMessageDirection) || (messageDirection_BORDER <= wMessageDirection))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if ((0U > wSubaddress) || (rtSubaddress_BORDER <= wSubaddress))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if (((U32BIT*)NULL) == dwpMessageLegality)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Find the address of the entry of the target table that corresponds given combination.
	U16BIT wTableEntryAddress; // The address of an entry in the target table.
	wTableEntryAddress = ((U16BIT)rtAddressMap_COMMAND_ILLEGALIZATION_TABLE | (wMessageDirection << (U16BIT)rtCommandIllegalizationTable_OFFSET_OF_DIRECTION) | (wOwnAddressOrBroadcast << (U16BIT)rtCommandIllegalizationTable_OFFSET_OF_ADDRESS_TYPE) | (wSubaddress << (U16BIT)rtCommandIllegalizationTable_OFFSET_OF_SUBADDRESS));

	/// Read current word count or mode code mask.
	U16BIT wMaskLowWord; // The value of the least significant word of the new mask.
	U16BIT wMaskHighWord; // The value of the most significant word of the new mask.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, wTableEntryAddress, sitalDeviceMemorySection_Ram, 1U, &wMaskLowWord);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, (wTableEntryAddress + 1U), sitalDeviceMemorySection_Ram, 1U, &wMaskHighWord);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	(*dwpMessageLegality) = wMaskHighWord;
	(*dwpMessageLegality) = (((*dwpMessageLegality) << 16U) | wMaskLowWord);

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Make messages received by given RT device raise the busy bit in their status responses if they suit given criteria.
///
/// Note:
/// - The busy lookup table is a 4-double-word area in device memory.
///   It allows any subset of the 128 possible combinations of broadcast / own address, Tx / Rx bit, and subaddress to be configured to have the busy bit set in corresponding responses.
///   It is arranged in a way that the offset of a word from the beginning of the table enables to deduce the related address, direction, and subaddress triplet, as follows:
///   - Bit #2 in the binary representation of that offset is 0 / 1 for own address / broadcast, respectively.
///   - Bit #1 in the binary representation of that offset is 0 / 1 for receive / transmit, respectively.
///   Then in each double-word entry in the table bit #0...#31 is the busy bit set flag for subaddresses 0...31, respectively.
///
/// Equivalent DDC definition: aceRTBusyBitsTblSet
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wOwnAddressOrBroadcast (in)	Message destination selection set (An or-ed combination of sitalRtAddressType_*)
/// @param wMessageDirection (in)	RT-related message direction (sitalMessageDirection_*)
/// @param dwSubaddressMask (in)	Mask of affected subaddresses, 0-31, where bit #i corresponds subaddress #i (An or-ed combination of sitalRtSubaddressMask_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRt_MessageBusyBit_Set (	S16BIT swDevice,
											U16BIT wOwnAddressOrBroadcast,
											U16BIT wMessageDirection,
											U32BIT dwSubaddressMask)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	return sitalReturnCode_NOT_SUPPORTED; // By the device.

	//if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	//{
	//	return sitalReturnCode_INVALID_DEVICE_NUMBER;
	//}

	//const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
	//							= &(s_dssaDevices[swDevice]);
	//if ((sitalMode_RT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	//{
	//	return sitalReturnCode_INVALID_MODE;
	//}

	//if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	//{
	//	return sitalReturnCode_INVALID_STATE;
	//}

	//BOOLEAN bIsLegalParameter; // A flag that says whether an input parameter is legal.
	//switch (wOwnAddressOrBroadcast)
	//{
	//case sitalRtAddressType_BROADCAST:
	//case sitalRtAddressType_OWN:
	//case sitalRtAddressType_BOTH:
	//	bIsLegalParameter = TRUE;
	//	break;
	//default:
	//	bIsLegalParameter = FALSE;
	//	break;
	//}
	//if (FALSE == bIsLegalParameter)
	//{
	//	return sitalReturnCode_INVALID_PARAMETER;
	//}

	//switch (wMessageDirection)
	//{
	//case sitalMessageDirection_RX:
	//case sitalMessageDirection_TX:
	//case sitalMessageDirection_BOTH:
	//	bIsLegalParameter = TRUE;
	//	break;
	//default:
	//	bIsLegalParameter = FALSE;
	//	break;
	//}
	//if (FALSE == bIsLegalParameter)
	//{
	//	return sitalReturnCode_INVALID_PARAMETER;
	//}

	///// Set loop delimiters for the direction and address type loops.
	//U16BIT wDirectionLoopBase; // Base value of direction loop.
	//U16BIT wDirectionLoopBorder; // Border value of direction loop.
	//if (sitalMessageDirection_BOTH == wMessageDirection)
	//{
	//	wDirectionLoopBase = 0U;
	//	wDirectionLoopBorder = messageDirection_BORDER;
	//}
	//else
	//{
	//	wDirectionLoopBase = wMessageDirection;
	//	wDirectionLoopBorder = (wMessageDirection + (U16BIT)1U);
	//}

	//U16BIT wAddressLoopBase; // Base value of address loop.
	//U16BIT wAddressLoopBorder; // Border value of address loop.
	//if (sitalRtAddressType_BOTH == wOwnAddressOrBroadcast)
	//{
	//	wAddressLoopBase = 0U;
	//	wAddressLoopBorder = rtAddressType_BORDER;
	//}
	//else
	//{
	//	if (sitalRtAddressType_BROADCAST == wOwnAddressOrBroadcast)
	//	{
	//		wAddressLoopBase = rtBusyLookupTable_OFFSET_OF_ADDRESS_BIT_FOR_BROADCAST;
	//		wAddressLoopBorder = (rtBusyLookupTable_OFFSET_OF_ADDRESS_BIT_FOR_BROADCAST + 1U);
	//	}
	//	else // sitalRtAddressType_OWN
	//	{
	//		wAddressLoopBase = rtBusyLookupTable_OFFSET_OF_ADDRESS_BIT_FOR_OWN_ADDRESS;
	//		wAddressLoopBorder = (rtBusyLookupTable_OFFSET_OF_ADDRESS_BIT_FOR_OWN_ADDRESS + 1U);
	//	}
	//}

	///// Loop over all given combinations of direction and address type:
	/////		Update each combination's busy specification.
	//for (S32BIT iDirection=(S32BIT)wDirectionLoopBase; iDirection<(S32BIT)wDirectionLoopBorder; iDirection++)
	//{
	//	for (S32BIT iAddress=(S32BIT)wAddressLoopBase; iAddress<(S32BIT)wAddressLoopBorder; iAddress++)
	//	{
	//		// Find the address of the entry of the target table that corresponds current combination.
	//		U16BIT wTableEntryAddress; // The address of an entry in the target table.
	//		wTableEntryAddress = ((U16BIT)rtAddressMap_BUSY_LOOKUP_TABLE | (U16BIT)(iDirection << rtBusyLookupTable_OFFSET_OF_DIRECTION_BIT) | (U16BIT)(iAddress << rtBusyLookupTable_OFFSET_OF_ADDRESS_BIT));

	//		// Calculate the new mask.
	//		U16BIT wMaskLowWord; // The value of the least significant word of the subaddress busy mask.
	//		U16BIT wMaskHighWord; // The value of the most significant word of the subaddress busy mask.
	//		U32BIT dwNewMask; // The value of the new subaddress busy mask.
	//		S16BIT swResult; // Result of operation or function call.
	//		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, wTableEntryAddress, sitalDeviceMemorySection_Ram, 1U, &wMaskLowWord);
	//		if (sitalReturnCode_SUCCESS != swResult)
	//		{
	//			return swResult;
	//		}
	//		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, (wTableEntryAddress + 1U), sitalDeviceMemorySection_Ram, 1U, &wMaskHighWord);
	//		if (sitalReturnCode_SUCCESS != swResult)
	//		{
	//			return swResult;
	//		}
	//		dwNewMask = wMaskHighWord;
	//		dwNewMask = ((dwNewMask << 16U) | wMaskLowWord);
	//		dwNewMask |= dwSubaddressMask;

	//		// Write the new mask in the entry of the target table that corresponds current combination.
	//		wMaskLowWord = (U16BIT)(dwNewMask & 0xFFFFU);
	//		wMaskHighWord = (U16BIT)(dwNewMask >> 16U);
	//		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, wTableEntryAddress, sitalDeviceMemorySection_Ram, 1U, &wMaskLowWord);
	//		if (sitalReturnCode_SUCCESS != swResult)
	//		{
	//			return swResult;
	//		}
	//		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, (wTableEntryAddress + 1U), sitalDeviceMemorySection_Ram, 1U, &wMaskHighWord);
	//		if (sitalReturnCode_SUCCESS != swResult)
	//		{
	//			return swResult;
	//		}
	//	}
	//}

	//return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Make messages received by given RT device not raise the busy bit in their status responses if they suit given criteria.
///
/// Note:
/// - The busy lookup table is a 4-double-word area in device memory.
///   It allows any subset of the 128 possible combinations of broadcast / own address, Tx / Rx bit, and subaddress to be configured to have the busy bit set in corresponding responses.
///   It is arranged in a way that the offset of a word from the beginning of the table enables to deduce the related address, direction, and subaddress triplet, as follows:
///   - Bit #2 in the binary representation of that offset is 0 / 1 for own address / broadcast, respectively.
///   - Bit #1 in the binary representation of that offset is 0 / 1 for receive / transmit, respectively.
///   Then in each double-word entry in the table bit #0...#31 is the busy bit set flag for subaddresses 0...31, respectively..
///
/// Equivalent DDC definition: aceRTBusyBitsTblClear
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wOwnAddressOrBroadcast (in)	Message destination selection set (An or-ed combination of sitalRtAddressType_*)
/// @param wMessageDirection (in)	RT-related message direction (sitalMessageDirection_*)
/// @param dwSubaddressMask (in)	Mask of affected subaddresses, 0-31, where bit #i corresponds subaddress #i (An or-ed combination of sitalRtSubaddressMask_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRt_MessageBusyBit_Clear (	S16BIT swDevice,
											U16BIT wOwnAddressOrBroadcast,
											U16BIT wMessageDirection,
											U32BIT dwSubaddressMask)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	return sitalReturnCode_NOT_SUPPORTED; // By the device.

	//if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	//{
	//	return sitalReturnCode_INVALID_DEVICE_NUMBER;
	//}

	//const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
	//							= &(s_dssaDevices[swDevice]);
	//if ((sitalMode_RT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	//{
	//	return sitalReturnCode_INVALID_MODE;
	//}

	//if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	//{
	//	return sitalReturnCode_INVALID_STATE;
	//}

	//BOOLEAN bIsLegalParameter; // A flag that says whether an input parameter is legal.
	//switch (wOwnAddressOrBroadcast)
	//{
	//case sitalRtAddressType_BROADCAST:
	//case sitalRtAddressType_OWN:
	//case sitalRtAddressType_BOTH:
	//	bIsLegalParameter = TRUE;
	//	break;
	//default:
	//	bIsLegalParameter = FALSE;
	//	break;
	//}
	//if (FALSE == bIsLegalParameter)
	//{
	//	return sitalReturnCode_INVALID_PARAMETER;
	//}

	//switch (wMessageDirection)
	//{
	//case sitalMessageDirection_RX:
	//case sitalMessageDirection_TX:
	//case sitalMessageDirection_BOTH:
	//	bIsLegalParameter = TRUE;
	//	break;
	//default:
	//	bIsLegalParameter = FALSE;
	//	break;
	//}
	//if (FALSE == bIsLegalParameter)
	//{
	//	return sitalReturnCode_INVALID_PARAMETER;
	//}

	///// Set loop delimiters for the direction and address type loops.
	//U16BIT wDirectionLoopBase; // Base value of direction loop.
	//U16BIT wDirectionLoopBorder; // Border value of direction loop.
	//if (sitalMessageDirection_BOTH == wMessageDirection)
	//{
	//	wDirectionLoopBase = 0U;
	//	wDirectionLoopBorder = messageDirection_BORDER;
	//}
	//else
	//{
	//	wDirectionLoopBase = wMessageDirection;
	//	wDirectionLoopBorder = (wMessageDirection + (U16BIT)1U);
	//}

	//U16BIT wAddressLoopBase; // Base value of address loop.
	//U16BIT wAddressLoopBorder; // Border value of address loop.
	//if (sitalRtAddressType_BOTH == wOwnAddressOrBroadcast)
	//{
	//	wAddressLoopBase = 0U;
	//	wAddressLoopBorder = rtAddressType_BORDER;
	//}
	//else
	//{
	//	if (sitalRtAddressType_BROADCAST == wOwnAddressOrBroadcast)
	//	{
	//		wAddressLoopBase = rtBusyLookupTable_OFFSET_OF_ADDRESS_BIT_FOR_BROADCAST;
	//		wAddressLoopBorder = (rtBusyLookupTable_OFFSET_OF_ADDRESS_BIT_FOR_BROADCAST + 1U);
	//	}
	//	else // sitalRtAddressType_OWN
	//	{
	//		wAddressLoopBase = rtBusyLookupTable_OFFSET_OF_ADDRESS_BIT_FOR_OWN_ADDRESS;
	//		wAddressLoopBorder = (rtBusyLookupTable_OFFSET_OF_ADDRESS_BIT_FOR_OWN_ADDRESS + 1U);
	//	}
	//}

	///// Loop over all given combinations of direction and address type:
	/////		Update each combination's busy specification.
	//for (S32BIT iDirection=(S32BIT)wDirectionLoopBase; iDirection<(S32BIT)wDirectionLoopBorder; iDirection++)
	//{
	//	for (S32BIT iAddress=(S32BIT)wAddressLoopBase; iAddress<(S32BIT)wAddressLoopBorder; iAddress++)
	//	{
	//		// Find the address of the entry of the target table that corresponds current combination.
	//		U16BIT wTableEntryAddress; // The address of an entry in the target table.
	//		wTableEntryAddress = ((U16BIT)rtAddressMap_BUSY_LOOKUP_TABLE | (U16BIT)(iDirection << (U16BIT)rtBusyLookupTable_OFFSET_OF_DIRECTION_BIT) | (U16BIT)(iAddress << (U16BIT)rtBusyLookupTable_OFFSET_OF_ADDRESS_BIT));

	//		// Calculate the new mask.
	//		U16BIT wMaskLowWord; // The value of the least significant word of the subaddress busy mask.
	//		U16BIT wMaskHighWord; // The value of the most significant word of the subaddress busy mask.
	//		U32BIT dwNewMask; // The value of the new subaddress busy mask.
	//		S16BIT swResult; // Result of operation or function call.
	//		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, wTableEntryAddress, sitalDeviceMemorySection_Ram, 1U, &wMaskLowWord);
	//		if (sitalReturnCode_SUCCESS != swResult)
	//		{
	//			return swResult;
	//		}
	//		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, (wTableEntryAddress + 1U), sitalDeviceMemorySection_Ram, 1U, &wMaskHighWord);
	//		if (sitalReturnCode_SUCCESS != swResult)
	//		{
	//			return swResult;
	//		}
	//		dwNewMask = wMaskHighWord;
	//		dwNewMask = ((dwNewMask << 16U) | wMaskLowWord);
	//		dwNewMask &= (~dwSubaddressMask);

	//		// Write the new mask in the entry of the target table that corresponds current combination.
	//		wMaskLowWord = (U16BIT)(dwNewMask & 0xFFFFU);
	//		wMaskHighWord = (U16BIT)(dwNewMask >> 16U);
	//		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, wTableEntryAddress, sitalDeviceMemorySection_Ram, 1U, &wMaskLowWord);
	//		if (sitalReturnCode_SUCCESS != swResult)
	//		{
	//			return swResult;
	//		}
	//		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, (wTableEntryAddress + 1U), sitalDeviceMemorySection_Ram, 1U, &wMaskHighWord);
	//		if (sitalReturnCode_SUCCESS != swResult)
	//		{
	//			return swResult;
	//		}
	//	}
	//}

	//return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Get the current busy bit state of messages received by given RT device if they suit given criteria.
///
/// Note:
/// - The busy lookup table is a 4-double-word area in device memory.
///   It allows any subset of the 128 possible combinations of broadcast / own address, Tx / Rx bit, and subaddress to be configured to have the busy bit set in corresponding responses.
///   It is arranged in a way that the offset of a word from the beginning of the table enables to deduce the related address, direction, and subaddress triplet, as follows:
///   - Bit #2 in the binary representation of that offset is 0 / 1 for own address / broadcast, respectively.
///   - Bit #1 in the binary representation of that offset is 0 / 1 for receive / transmit, respectively.
///   Then in each double-word entry in the table bit #0...#31 is the busy bit set flag for subaddresses 0...31, respectively..
///
/// Equivalent DDC definition: aceRTBusyBitsTblStatus
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wOwnAddressOrBroadcast (in)	Message destination selection set (sitalRtAddressType_BROADCAST or sitalRtAddressType_OWN)
/// @param wMessageDirection (in)	RT-related message direction (sitalMessageDirection_RX or sitalMessageDirection_TX)
/// @param dwpSubaddressMask (out)	A pointer to a variable within which a busy bit mask of subaddresses, 0-31, where bit #i corresponds subaddress #i, is returned, what forms an or-ed combination of sitalRtSubaddressMask_*
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRt_MessageBusyBit_GetStatus (	S16BIT swDevice,
												U16BIT wOwnAddressOrBroadcast,
												U16BIT wMessageDirection,
												U32BIT* dwpSubaddressMask)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	return sitalReturnCode_NOT_SUPPORTED; // By the device.

	//if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	//{
	//	return sitalReturnCode_INVALID_DEVICE_NUMBER;
	//}

	//const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
	//							= &(s_dssaDevices[swDevice]);
	//if ((sitalMode_RT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	//{
	//	return sitalReturnCode_INVALID_MODE;
	//}

	//if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	//{
	//	return sitalReturnCode_INVALID_STATE;
	//}

	//if ((0U > wOwnAddressOrBroadcast) || (rtAddressType_BORDER <= wOwnAddressOrBroadcast))
	//{
	//	return sitalReturnCode_INVALID_PARAMETER;
	//}

	//if ((0U > wMessageDirection) || (messageDirection_BORDER <= wMessageDirection))
	//{
	//	return sitalReturnCode_INVALID_PARAMETER;
	//}

	//if (((U32BIT*)NULL) == dwpSubaddressMask)
	//{
	//	return sitalReturnCode_INVALID_PARAMETER;
	//}

	///// Calculate the address type bit in the offset of the entry of the target table that corresponds given combination.
	//if (sitalRtAddressType_BROADCAST == wOwnAddressOrBroadcast)
	//{
	//	wOwnAddressOrBroadcast = rtBusyLookupTable_OFFSET_OF_ADDRESS_BIT_FOR_BROADCAST;
	//}
	//else // sitalRtAddressType_OWN
	//{
	//	wOwnAddressOrBroadcast = rtBusyLookupTable_OFFSET_OF_ADDRESS_BIT_FOR_OWN_ADDRESS;
	//}

	///// Find the address of the entry of the target table that corresponds given combination.
	//U16BIT wTableEntryAddress; // The address of an entry in the target table.
	//wTableEntryAddress = ((U16BIT)rtAddressMap_BUSY_LOOKUP_TABLE | (wMessageDirection << (U16BIT)rtBusyLookupTable_OFFSET_OF_DIRECTION_BIT) | (wOwnAddressOrBroadcast << (U16BIT)rtBusyLookupTable_OFFSET_OF_ADDRESS_BIT));

	///// Read current word count or mode code mask.
	//U16BIT wMaskLowWord; // The value of the least significant word of the new mask.
	//U16BIT wMaskHighWord; // The value of the most significant word of the new mask.
	//S16BIT swResult; // Result of operation or function call.
	//swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, wTableEntryAddress, sitalDeviceMemorySection_Ram, 1U, &wMaskLowWord);
	//if (sitalReturnCode_SUCCESS != swResult)
	//{
	//	return swResult;
	//}
	//swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, (wTableEntryAddress + 1U), sitalDeviceMemorySection_Ram, 1U, &wMaskHighWord);
	//if (sitalReturnCode_SUCCESS != swResult)
	//{
	//	return swResult;
	//}
	//(*dwpSubaddressMask) = wMaskHighWord;
	//(*dwpSubaddressMask) = (((*dwpSubaddressMask) << 16U) | wMaskLowWord);

	//return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Configure given status enabler bits in order to control status responses made by given RT device.
/// In case given RT device has been configured to be with/without alternate status mode, given bits are set/cleared, respectively.
/// This configuration of alternate status mode also affects the set of the relevant status bits.
///
/// Note:
/// - An interrupt is issued whenever an interrupt condition occurs, if both the respective enabler bit and the respective bit of the interrupt mask register are set.
/// - Only bits of given wStatusEnablerMask that really serve as status enabler bits in configuration register #1 are taken in account.
///   Irrelevant bits are ignored.
///
/// Equivalent DDC definition: aceRTStatusBitsSet
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wStatusEnablerMask (in)	Status enabler bit mask to update in configuration register #1 with (An or-ed combination of sitalRtStatusWordBit_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRt_ResponseStatusBits_Set (S16BIT swDevice, U16BIT wStatusEnablerMask)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalMode_RT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	/// If the RT device is currently ready (idle):
	///		If RT configured to alternate status mode:
	///			Set the relevant status enabler bits in the image of the registers.
	///		Else:
	///			Clear the relevant status enabler bits in the image of the registers.
	/// If the RT device is currently running:
	///		If RT configured to alternate status mode:
	///			Set the relevant status enabler bits in the device registers themselves.
	///		Else:
	///			Clear the relevant status enabler bits in the device registers themselves.
	U16BIT wRegisterValue; // The current value of a target register, or the value to set for a target register.
	if (TRUE == dsspDeviceState->rms.rsRtState.bIsAlternateStatusMode)
	{
		wStatusEnablerMask &= (U16BIT)configurationRegister1_RT_STATUS_ENABLER_BITS;
		wRegisterValue = (U16BIT)registerMask_ALL_BITS_ON;
	}
	else
	{
		wStatusEnablerMask &= (U16BIT)configurationRegister1_RT_PARTIAL_STATUS_ENABLER_BITS;
		wRegisterValue = (U16BIT)registerMask_ALL_BITS_OFF;
	}

	S16BIT swResult; // Result of operation or function call.
	switch (dsspDeviceState->wCurrentState)
	{
	case sitalDeviceState_RUN:
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, sitalRegisterAddress_CONFIGURATION_1, sitalDeviceMemorySection_Registers, wStatusEnablerMask, &wRegisterValue);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
		break;

	case sitalDeviceState_READY:
		swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_1, wStatusEnablerMask, wRegisterValue);
		break;

	default:
		return sitalReturnCode_INVALID_STATE;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Reverse configure given status enabler bits in order to control status responses made by given RT device.
/// In case given RT device has been configured to be with/without alternate status mode, given bits are cleared/set, respectively.
/// This configuration of alternate status mode also affects the set of the relevant status bits.
///
/// Note:
/// - An interrupt is issued whenever an interrupt condition occurs, if both the respective enabler bit and the respective bit of the interrupt mask register are set.
/// - Only bits of given wStatusEnablerMask that really serve as status enabler bits in configuration register #1 are taken in account.
///   Irrelevant bits are ignored.
///
/// Equivalent DDC definition: aceRTStatusBitsClear
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wStatusEnablerMask (in)	Status enabler bit mask to update in configuration register #1 with (An or-ed combination of sitalRtStatusWordBit_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRt_ResponseStatusBits_Unset (S16BIT swDevice, U16BIT wStatusEnablerMask)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalMode_RT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	/// If the RT device is currently ready (idle):
	///		If RT configured to alternate status mode:
	///			Set the relevant status enabler bits in the image of the registers.
	///		Else:
	///			Clear the relevant status enabler bits in the image of the registers.
	/// If the RT device is currently running:
	///		If RT configured to alternate status mode:
	///			Set the relevant status enabler bits in the device registers themselves.
	///		Else:
	///			Clear the relevant status enabler bits in the device registers themselves.
	U16BIT wRegisterValue; // The current value of a target register, or the value to set for a target register.
	if (TRUE == dsspDeviceState->rms.rsRtState.bIsAlternateStatusMode)
	{
		wStatusEnablerMask &= (U16BIT)configurationRegister1_RT_STATUS_ENABLER_BITS;
		wRegisterValue = (U16BIT)registerMask_ALL_BITS_OFF;
	}
	else
	{
		wStatusEnablerMask &= (U16BIT)configurationRegister1_RT_PARTIAL_STATUS_ENABLER_BITS;
		wRegisterValue = (U16BIT)registerMask_ALL_BITS_ON;
	}

	S16BIT swResult; // Result of operation or function call.
	switch (dsspDeviceState->wCurrentState)
	{
	case sitalDeviceState_RUN:
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, sitalRegisterAddress_CONFIGURATION_1, sitalDeviceMemorySection_Registers, wStatusEnablerMask, &wRegisterValue);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
		break;

	case sitalDeviceState_READY:
		swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_1, wStatusEnablerMask, wRegisterValue);
		break;

	default:
		return sitalReturnCode_INVALID_STATE;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Get the current configuration of status enabler bits, which are the configuration bits that control status responses made by given RT device.
/// Whether given RT device is configured with/without alternate status mode affects the set of the relevant status bits.
///
/// Note:
/// - An interrupt is issued whenever an interrupt condition occurs, if both the respective enabler bit and the respective bit of the interrupt mask register are set.
///
/// Equivalent DDC definition: aceRTStatusBitsStatus
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wpStatusEnablerMask (out)	A pointer to a variable within which the status enabler bit mask in configuration register #1 are returned as an or-ed combination of sitalRtStatusWordBit_*
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRt_ResponseStatusBits_Get (S16BIT swDevice, U16BIT* wpStatusEnablerMask)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalMode_RT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (((U16BIT*)NULL) == wpStatusEnablerMask)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// If the RT device is currently ready (idle):
	///		Get the relevant status enabler bits from the image of the registers.
	/// If the RT device is currently running:
	///		Get the relevant status enabler bits from the device registers themselves.
	U16BIT wRegisterValue; // The current value of a target register, or the value to set for a target register.
	S16BIT swResult; // Result of operation or function call.
	switch (dsspDeviceState->wCurrentState)
	{
	case sitalDeviceState_RUN:
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, sitalRegisterAddress_CONFIGURATION_1, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
		break;

	case sitalDeviceState_READY:
		swResult = device_Register_GetImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_1, (U16BIT)registerMask_ALL_BITS_ON, &wRegisterValue);
		break;

	default:
		return sitalReturnCode_INVALID_STATE;
	}

	/// Use the configuration of the alternate status mode to seclude the status enabler bits.
	U16BIT wStatusEnablerMask; // The mask of all status enabler bits that are relevant with the configuration of alternate status mode of given RT device.
	if (TRUE == dsspDeviceState->rms.rsRtState.bIsAlternateStatusMode)
	{
		wStatusEnablerMask = configurationRegister1_RT_STATUS_ENABLER_BITS;
		(*wpStatusEnablerMask) = (wRegisterValue & wStatusEnablerMask);
	}
	else
	{
		wStatusEnablerMask = configurationRegister1_RT_PARTIAL_STATUS_ENABLER_BITS;
		(*wpStatusEnablerMask) = (~(wRegisterValue & wStatusEnablerMask));
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Read from the RT stack of given RT device into given buffer as many currently available raw messages as possible (that is, as the size of given buffer permits).
/// Remove from the stack the messages that were read.
///
/// Note:
/// - Given buffer is first zeroed, and then filled with available messages, where each message is stored as follows:
///   - A number of sitalRtMaximum_MESSAGE_SIZE memory words is dedicated per message, never mind its actual size.
///   - The target RT stack entry is copied into given buffer.
///   - The data stack pointer is replaced with a word whose:
///     - MSByte contains the count of data words for the message that was read.
///     - LSByte contains the type of the message that was read (sitalMessageType_*).
///   - The data words are stored right after the stack entry, that is, starting at offset sitalRtMemoryObjectSize_COMMAND_STACK_ENTRY.
///     In case of a mode code message with data, this data word is returned as the first (actually the single) data word.
/// - In case a host buffer is assigned to a device, then right after any new message is recorded in this host buffer, that message is purged from the stack.
///   In other words, the usage of a host buffer and the usage of sital*_Message_Get* functions is basically mutually exclussive.
///
/// Equivalent DDC definition: aceRTGetStkMsgsRaw
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wapBuffer (out)	A pointer to a buffer in which the raw messages are stored
/// @param wBufferSize (in)	The size (in words) of the data buffer that is pointed by wapBuffer (>=sitalRtMaximum_MESSAGE_SIZE)
/// @return Non-negative integer	The number of messages that were read
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRt_Message_GetFromStackRaw (S16BIT swDevice, U16BIT* wapBuffer, U16BIT wBufferSize)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalMode_RT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (((U16BIT*)NULL) == wapBuffer)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if (sitalRtMaximum_MESSAGE_SIZE > wBufferSize)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Read the target command stack pointer.
	U16BIT wAddressOfMessageToWrite; // The current value of the stack pointer.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, rtAddressMap_COMMAND_STACK_POINTER, sitalDeviceMemorySection_Ram, 1U, &wAddressOfMessageToWrite);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Update the target command stack pointer.
	// Note: In order to save CPU time, no ISR is set with RT devices while no host buffer is installed, so in such case the current stack pointer and stack statistics are updated only when the user calls functions sitalRt_Message_GetFromStackRaw, sitalRt_Message_GetFromStackDecoded, or sitalRt_HostBuffer_Message_Record.
	RtStackStateStructure* rssspTargetStackState; // A pointer to the state structure of the target stack.
	rssspTargetStackState = (RtStackStateStructure*)&(dsspDeviceState->rms.rsRtState.rsssStackState);
	rssspTargetStackState->dwAddressOfMessageToWrite = wAddressOfMessageToWrite;

	///	If configured to collect operational statistics for given device:
	///		Update stack fullness statistics for given device.
	if (TRUE == dsspDeviceState->bIsOperationalStatisticsCollected)
	{
		rssspTargetStackState->wFullnessPercentage = (U16BIT)( (double)100.0 * (((rssspTargetStackState->dwAddressOfMessageToRead > rssspTargetStackState->dwAddressOfMessageToWrite) ? rssspTargetStackState->wCommandStackSize : 0U) + rssspTargetStackState->dwAddressOfMessageToWrite - rssspTargetStackState->dwAddressOfMessageToRead) / rssspTargetStackState->wCommandStackSize );
		rssspTargetStackState->wMaximumFullnessPercentage = ( (rssspTargetStackState->wMaximumFullnessPercentage < rssspTargetStackState->wFullnessPercentage) ? rssspTargetStackState->wFullnessPercentage : rssspTargetStackState->wMaximumFullnessPercentage );
	}

	/// While there are more unread messages in the stack and there's still place for another message in given buffer and reading succeeds:
	///		Point to the place in given buffer where the next message should be stored.
	///		Decrement the size of the buffer to reflect the remaining size.
	///		Increment the count of raw messages that have been copied.
	U16BIT wReadMessagesCount = 0U; // The number of messages that were read.
	wReadMessagesCount = 0U;
	swResult = 1;
	while	(
				(dsspDeviceState->rms.rsRtState.rsssStackState.dwAddressOfMessageToRead != wAddressOfMessageToWrite)
				&&
				(sitalRtMaximum_MESSAGE_SIZE <= wBufferSize)
				&&
				(1 == swResult)
			)
	{
		swResult = rt_Message_GetFromStackRaw (swDevice, wapBuffer, ((U16BIT*)NULL), (BOOLEAN)TRUE, (BOOLEAN)TRUE);
		if ((S16BIT)1U == swResult)
		{
			wapBuffer += sitalRtMaximum_MESSAGE_SIZE;
			wBufferSize -= sitalRtMaximum_MESSAGE_SIZE;
			wReadMessagesCount++;
		}
	}

	if ((S16BIT)0U > swResult)
	{
		return swResult;
	}

	return (S16BIT)wReadMessagesCount;
}


/// <summary>
/// Read from the stack of given RT device the message at given location, decode it into given structure, and purge it if so required.
///
/// Note:
/// - In case of a mode code message with data, this data word is returned as the first (actually the single) data word.
/// - In case a host buffer is assigned to a device, then right after any new message is recorded in this host buffer, that message is purged from the stack.
///   In other words, the usage of a host buffer and the usage of sital*_Message_Get* functions is basically mutually exclussive.
///
/// Equivalent DDC definition: aceRTGetStkMsgDecoded
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param dmspDecodedMessage (out)	A pointer to a structure into which a message is decoded
/// @param wMessageLocationAndRemoval (in)	The location in the stack or host buffer of the message to read, and removal instructions (sitalMessageLocationAndRemoval_*)
/// @return One (1)	The [single] requested message was read and decoded
/// @return Zero (0)	No message available, though no error occurred
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRt_Message_GetFromStackDecoded (S16BIT swDevice, sitalDecodedMessageStructure* dmspDecodedMessage, U16BIT wMessageLocationAndRemoval)
{
	/// @pseudocode
	//printf("\n\r start of decode function ");

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		//printf("\n\r 1 error ");

		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalMode_RT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		//printf("\n\r 2 error ");
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		//printf("\n\r 3 error ");
		return sitalReturnCode_INVALID_STATE;
	}

	if (((sitalDecodedMessageStructure*)NULL) == dmspDecodedMessage)
	{
		//printf("\n\r 4 error ");
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if ((0U > wMessageLocationAndRemoval) || (messageLocationAndRemoval_BORDER <= wMessageLocationAndRemoval))
	{
		//printf("\n\r 5 error ");
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Read the target command stack pointer.
	U16BIT wAddressOfMessageToWrite; // The current value of the stack pointer.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, rtAddressMap_COMMAND_STACK_POINTER, sitalDeviceMemorySection_Ram, 1U, &wAddressOfMessageToWrite);

	if (sitalReturnCode_SUCCESS != swResult)
	{
		//printf("\n\r 6 error ");

		printf("%x\n  hrere : ",swResult);
		return swResult;
	}

	/// Update the target command stack pointer.
	// Note: In order to save CPU time, no ISR is set with RT devices while no host buffer is installed, so in such case the current stack pointer and stack statistics are updated only when the user calls functions sitalRt_Message_GetFromStackRaw, sitalRt_Message_GetFromStackDecoded, or sitalRt_HostBuffer_Message_Record.
	RtStackStateStructure* rssspTargetStackState; // A pointer to the state structure of the target stack.
	rssspTargetStackState = (RtStackStateStructure*)&(dsspDeviceState->rms.rsRtState.rsssStackState);
	rssspTargetStackState->dwAddressOfMessageToWrite = wAddressOfMessageToWrite;

	///	If configured to collect operational statistics for given device:
	///		Update stack fullness statistics for given device.
	if (TRUE == dsspDeviceState->bIsOperationalStatisticsCollected)
	{
		rssspTargetStackState->wFullnessPercentage = (U16BIT)( (double)100.0 * (((rssspTargetStackState->dwAddressOfMessageToRead > rssspTargetStackState->dwAddressOfMessageToWrite) ? rssspTargetStackState->wCommandStackSize : 0U) + rssspTargetStackState->dwAddressOfMessageToWrite - rssspTargetStackState->dwAddressOfMessageToRead) / rssspTargetStackState->wCommandStackSize );
		rssspTargetStackState->wMaximumFullnessPercentage = ( (rssspTargetStackState->wMaximumFullnessPercentage < rssspTargetStackState->wFullnessPercentage) ? rssspTargetStackState->wFullnessPercentage : rssspTargetStackState->wMaximumFullnessPercentage );
	}

	/// Interpret given message location directive.
	BOOLEAN bIsNextMessageRequired; // A flag that says whether to read the stack record of the next message (or, otherwise, of the last message).
	bIsNextMessageRequired = (BOOLEAN)((U16BIT)sitalMessageLocation_NEXT == ((U16BIT)messageLocationAndRemoval_LOCATION & wMessageLocationAndRemoval));

	/// Interpret given message removal directive.
	BOOLEAN bIsMessagePurgeRequired; // A flag that says whether to delete the record of the message that's read.
	bIsMessagePurgeRequired = (BOOLEAN)((U16BIT)sitalMessageRemoval_PURGE == ((U16BIT)messageLocationAndRemoval_REMOVAL & wMessageLocationAndRemoval));

	/// Get the requested stack message in its raw state.
	U16BIT waBuffer[sitalRtMaximum_MESSAGE_SIZE]; // A temporary buffer to store within a message in its raw state.
	swResult = rt_Message_GetFromStackRaw (swDevice, waBuffer, ((U16BIT*)NULL), (BOOLEAN)bIsNextMessageRequired, (BOOLEAN)bIsMessagePurgeRequired);
	if (1 != swResult)
	{
//		printf("\n\r error 7 ");
//		printf("\n\rswResult: %0x",swResult);
		return swResult;
	}

	/// Decode the requested stack message from its raw state.
	swResult = sitalRt_Message_DecodeRaw (swDevice, waBuffer, dmspDecodedMessage);
	//printf("\n\r end of decode masages function");

	return 1;
}


/// <summary>
/// Decode given message of given RT device into given structure.
///
/// Note:
/// - This function does not really require the logical number of the relevant device, which isn't removed only in order to stay compatible with DDC.
///   (DDC use this parameter to verify the given device is a RT at state READY or RUN, which is a non really required restriction.)
/// - This function assumes that given buffer is at least sitalRtMaximum_MESSAGE_SIZE words long.
/// - This function assumes that given buffer has been previously filled by function sitalRt_Message_GetFromStackRaw.
///   See the documentation for this function for information on the contents of its returned buffer.
/// - In case given buffer contains a mode code message with data, this data word is returned as the first (actually the single) data word of the decoded message.
///
/// Equivalent DDC definition: aceRTDecodeRawMsg
/// @param swDevice (in)	Logical number of device (0-31, unused)
/// @param wapBuffer (in)	A pointer to a buffer in which a raw message is stored
/// @param dmspDecodedMessage (out)	A pointer to a structure into which a message is decoded
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRt_Message_DecodeRaw (S16BIT swDevice, U16BIT* wapBuffer, sitalDecodedMessageStructure* dmspDecodedMessage)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((sitalDecodedMessageStructure*)NULL) == dmspDecodedMessage)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if (((U16BIT*)NULL) == wapBuffer)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Extricate the type of given message and its number of data words.
	// Within given raw message block the data block address field has been overridden with a combined word value whose:
	// - LSByte contains the type of given message.
	// - MSByte contains the count of data words of given message.
	U16BIT wMessageType; // The type of given message.
	wMessageType = ((U16BIT)0xFFU & wapBuffer[rtCommandStackEntry_OFFSET_OF_DATA_BLOCK_ADDRESS]);
	U16BIT wDataWordCount; // The principally expected number of data words with messages of same type as given message.
	wDataWordCount = ((U16BIT)0x7FU & (wapBuffer[rtCommandStackEntry_OFFSET_OF_DATA_BLOCK_ADDRESS] >> 8U));
	if ((U16BIT)0U == wDataWordCount)
	{
		wDataWordCount = (U16BIT)32U;
	}

	/// Initialize given message structure.
	memset (dmspDecodedMessage, 0, sizeof(sitalDecodedMessageStructure));

	/// Decode message information from given raw message into given message structure.
	dmspDecodedMessage->wType = wMessageType;
	dmspDecodedMessage->wDataWordCount = wDataWordCount;
	dmspDecodedMessage->wCommandWord1 = wapBuffer[rtCommandStackEntry_OFFSET_OF_COMMAND];
	dmspDecodedMessage->bIsCommandWord1Relevant = TRUE;
	dmspDecodedMessage->wBlockStatus = wapBuffer[rtCommandStackEntry_OFFSET_OF_BLOCK_STATUS_WORD];
	dmspDecodedMessage->wTimeTag = wapBuffer[rtCommandStackEntry_OFFSET_OF_TIME_TAG];

	/// Copy the actual data words.
	memcpy (((void*)(dmspDecodedMessage->waData)), ((void*)&(wapBuffer[sitalRtMemoryObjectSize_COMMAND_STACK_ENTRY])), (size_t)(dmspDecodedMessage->wDataWordCount << 1U));

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Configure the built-in test of given RT device to use the word in given source and to inhibit/permit the built-in test if the RT is busy, as required.
///
/// Equivalent DDC definition: aceRTBITWrdConfig
/// @param swDevice (in)	Logical number of device (0-31, unused)
/// @param wWordLocation (in)	The source where to read the built-in test word from (sitalRtBuiltInTestWordSource_*)
/// @param wPermitOrInihibitIfRtBusy (in)	A flag that says whether to permit/inhibit the built-in test if the RT is busy (sitalRtBuiltInTestPermitOnBusy_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRt_BuiltInTestWord_Configure (S16BIT swDevice, U16BIT wWordLocation, U16BIT wPermitOrInihibitIfRtBusy)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalMode_RT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((0U > wWordLocation) || (rtBuiltInTestWordSource_BORDER <= wWordLocation))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if ((0U > wPermitOrInihibitIfRtBusy) || (rtBuiltInTestPermitOnBusy_BORDER <= wPermitOrInihibitIfRtBusy))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Configure given device to use the required location.
	U16BIT wRegisterMask; // A register mask to use in write-masked operations.
	wRegisterMask = sitalConfigurationRegister4_RT_EXTERNAL_BUILT_IN_TEST_WORD;
	U16BIT wRegisterValue; // The current value of a target register, or the value to set for a target register.
	wRegisterValue = (U16BIT)( (sitalRtBuiltInTestWordSource_REGISTER == wWordLocation) ? 0x0000 : sitalConfigurationRegister4_RT_EXTERNAL_BUILT_IN_TEST_WORD );
	S16BIT swResult; // Result of operation or function call.

	if (sitalDeviceState_READY == dsspDeviceState->wCurrentState)
	{
		swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_4, wRegisterMask, wRegisterValue);
	}
	else // sitalDeviceState_RUN
	{
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, sitalRegisterAddress_CONFIGURATION_4, sitalDeviceMemorySection_Registers, wRegisterMask, &wRegisterValue);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
	}

	/// Configure given device to use the required condition.
	wRegisterMask = sitalConfigurationRegister4_RT_INHIBIT_BUILT_IN_TEST_WORD_IF_BUSY;
	wRegisterValue = (U16BIT)( (sitalRtBuiltInTestPermitOnBusy_ENABLED == wPermitOrInihibitIfRtBusy) ? 0x0000 : sitalConfigurationRegister4_RT_INHIBIT_BUILT_IN_TEST_WORD_IF_BUSY );

	if (sitalDeviceState_READY == dsspDeviceState->wCurrentState)
	{
		swResult = device_Register_UpdateImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_4, wRegisterMask, wRegisterValue);
	}
	else // sitalDeviceState_RUN
	{
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, sitalRegisterAddress_CONFIGURATION_4, sitalDeviceMemorySection_Registers, wRegisterMask, &wRegisterValue);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Read the built-in test word of given RT device that is stored at given location.
///
/// Equivalent DDC definition: aceRTBITWrdRead
/// @param swDevice (in)	Logical number of device (0-31, unused)
/// @param wWordLocation (in)	The source where to read the built-in test word from (sitalRtBuiltInTestWordSource_*)
/// @param wpWord (out)	A pointer to a variable in which the test word is written into
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRt_BuiltInTestWord_Read (S16BIT swDevice, U16BIT wWordLocation, U16BIT* wpWord)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalMode_RT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((0U > wWordLocation) || (rtBuiltInTestWordSource_BORDER <= wWordLocation))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if (((U16BIT*)NULL) == wpWord)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Read the built-in test word of given RT device that is stored at given location.
	S16BIT swResult; // Result of operation or function call.
	if (sitalRtBuiltInTestWordSource_MEMORY == wWordLocation)
	{
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, rtAddressMap_ModeCodeWord_TRANSMIT_BUILT_IN_TEST, sitalDeviceMemorySection_Ram, 1U, wpWord);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
	}
	else // sitalRtBuiltInTestWordSource_REGISTER
	{
		if (sitalDeviceState_READY == dsspDeviceState->wCurrentState)
		{
			swResult = device_Register_GetImage (swDevice, (U16BIT)sitalRegisterAddress_RT_BUILT_IN_TEST_WORD, (U16BIT)registerMask_ALL_BITS_ON, wpWord);
		}
		else // sitalDeviceState_RUN
		{
			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, sitalRegisterAddress_RT_BUILT_IN_TEST_WORD, sitalDeviceMemorySection_Registers, 1U, wpWord);
			if (sitalReturnCode_SUCCESS != swResult)
			{
				return swResult;
			}
		}
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Write given built-in test word at the appropriate predefined memory address of given RT device.
///
/// Equivalent DDC definition: aceRTBITWrdWrite
/// @param swDevice (in)	Logical number of device (0-31, unused)
/// @param wWord (in)	The word to write into RT memory as the built-in test word
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRt_BuiltInTestWord_Write (S16BIT swDevice, U16BIT wWord)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalMode_RT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	/// If given device is currently configured to use the built-in test word that's written in device memory:
	///		Write given word to the designated entry in the mode code word table.
	U16BIT wRegisterValue; // The current value of a target register, or the value to set for a target register.
	S16BIT swResult; // Result of operation or function call.
	if (sitalDeviceState_READY == dsspDeviceState->wCurrentState)
	{
		swResult = device_Register_GetImage (swDevice, (U16BIT)sitalRegisterAddress_CONFIGURATION_4, (U16BIT)registerMask_ALL_BITS_ON, &wRegisterValue);
	}
	else // sitalDeviceState_RUN
	{
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, sitalRegisterAddress_CONFIGURATION_4, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
	}

	if (sitalConfigurationRegister4_RT_EXTERNAL_BUILT_IN_TEST_WORD != (sitalConfigurationRegister4_RT_EXTERNAL_BUILT_IN_TEST_WORD & wRegisterValue))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, rtAddressMap_ModeCodeWord_TRANSMIT_BUILT_IN_TEST, sitalDeviceMemorySection_Ram, 1U, &wWord);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Initialize (or re-initialize) given RT device's host buffer.
///
/// Note:
/// - Given size of host buffer must be large enough to contain sitalRtMinimum_COMMAND_STACKS_IN_HOST_BUFFER times the number of raw messages that the command stack of given RT device may contain.
///   The number of messages that may be contained by the command stack (N) is its configured size in words divided by sitalRtMemoryObjectSize_COMMAND_STACK_ENTRY.
///   As the maximum possible size of message is allocated for each message in the host buffer, the corresponding size (in words) is (N / sitalRtMaximum_MESSAGE_SIZE).
///   Therefore, given size must be not less than (sitalRtMinimum_COMMAND_STACKS_IN_HOST_BUFFER * (N / sitalRtMaximum_MESSAGE_SIZE)).
///
/// Equivalent DDC definition: aceRTInstallHBuf
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param dwHostBufferSize (in)	The desired size (in words) of the host buffer (<above-defined-minimum-size-of-RT-host-buffer>-sitalMaximum_SIZE_OF_HOST_BUFFER)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
S16BIT _DECL sitalRt_HostBuffer_Initialize (S16BIT swDevice, U32BIT dwHostBufferSize)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if ((sitalMode_RT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((((sitalRtMinimum_COMMAND_STACKS_IN_HOST_BUFFER * ((U32BIT)(dsspDeviceState->rms.rsRtState.rsssStackState.wCommandStackSize) / sitalRtMemoryObjectSize_COMMAND_STACK_ENTRY) * sitalRtMaximum_MESSAGE_SIZE)) > dwHostBufferSize) || (sitalMaximum_SIZE_OF_HOST_BUFFER < dwHostBufferSize))
	{
		return sitalReturnCode_INVALID_HOST_BUFFER_SIZE;
	}

	/// If given device's host buffer is currently in use:
	///		Reset given device's host buffer.
	HostBufferStructure* hbspHostBuffer; // A host buffer structure.
	hbspHostBuffer = &(dsspDeviceState->rms.rsRtState.hbsHostBuffer);
	S16BIT swResult; // Result of operation or function call.
	if (0U != hbspHostBuffer->dwHostBufferSize)
	{
		swResult = sitalRt_HostBuffer_Free (swDevice);
	}

	///	Properly set given device's host buffer.
	hbspHostBuffer->dwHostBufferSize = ( dwHostBufferSize - (dwHostBufferSize % sitalRtMaximum_MESSAGE_SIZE) );
	hbspHostBuffer->dwLastMessageTimeTag = 0U;
	hbspHostBuffer->dwOffsetOfNextMessageToRead = 0U;
	hbspHostBuffer->dwOffsetOfNextMessageToWrite = 0U;
	hbspHostBuffer->dwMessageCount = 0U;
	hbspHostBuffer->dwLostMessageCount = 0U;
	hbspHostBuffer->wFullnessPercentage = 0U;
	hbspHostBuffer->wMaximumFullnessPercentage = 0U;

	/// In case of a real device:
	///		Set a suitable ISR for given device.
	///		Configure the user's interrupt mask pseudo register to issue those interrupts that are relevant while recording messages in given device's host buffer.
	if (sitalAccess_CARD == dsspDeviceState->wAccess)
	{
		swResult = sitalProcess_SetInterruptServiceRoutine ( (ISR_FUNCTION)((sitalMode_RT == dsspDeviceState->wMode) ? rt_HandleInterrupt : /* sitalMode_RT_AND_MT */ rtmt_HandleInterrupt) );

		dsspDeviceState->dwInternalImr |= (sitalInterruptRegister2_RT_COMMAND_STACK_HALF_ROLLOVER | sitalInterruptRegister1_BC_RT_COMMAND_STACK_ROLLOVER | sitalInterruptRegister1_TIME_TAG_ROLLOVER | sitalInterruptRegister1_END_OF_MESSAGE);
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Free given RT device's host buffer.
///
/// Note:
/// - See the documentation of function sitalRtMt_HostBuffer_Initialize for more information on using functions sitalRt_HostBuffer_* or sitalMt_HostBuffer_* combined with functions sitalRtMt_HostBuffer_*.
///
/// Equivalent DDC definition: aceRTUninstallHBuf
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
S16BIT _DECL sitalRt_HostBuffer_Free (S16BIT swDevice)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if ((sitalMode_RT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	HostBufferStructure* hbspHostBuffer; // A host buffer structure.
	hbspHostBuffer = &(dsspDeviceState->rms.rsRtState.hbsHostBuffer);
	if (0U == hbspHostBuffer->dwHostBufferSize)
	{
		return sitalReturnCode_HOST_BUFFER_NOT_INSTALLED;
	}

	///	Free given device's host buffer.
	hbspHostBuffer->dwHostBufferSize = 0U;
	hbspHostBuffer->dwLastMessageTimeTag = 0U;
	hbspHostBuffer->dwOffsetOfNextMessageToRead = 0U;
	hbspHostBuffer->dwOffsetOfNextMessageToWrite = 0U;
	hbspHostBuffer->dwMessageCount = 0U;
	hbspHostBuffer->dwLostMessageCount = 0U;
	hbspHostBuffer->wFullnessPercentage = 0U;
	hbspHostBuffer->wMaximumFullnessPercentage = 0U;

	/// In case of a real device:
	///		Set a suitable ISR for given device.
	///		Configure the user's interrupt mask pseudo register to avoid raising those host buffer filling interrupts which are not required anymore.
	// Note:
	// - With a RTMT device:
	//   - The RTMT ISR is set as long as at least one of the RT and MT host buffers is installed.
	//   - Interrupts that are relevant while recording messages in a host buffer of a RT device are passed to the user's ISR (if one is defined at all) as long as the RT host buffer is installed.
	//   - Interrupts that are relevant while recording messages in a host buffer of a MT device are passed to the user's ISR (if one is defined at all) as long as the MT host buffer is installed.
	S16BIT swResult; // Result of operation or function call.
	if (sitalAccess_CARD == dsspDeviceState->wAccess)
	{
		if (sitalMode_RT_AND_MT == dsspDeviceState->wMode)
		{
			if (0U == dsspDeviceState->rms.msMtState.hbsHostBuffer.dwHostBufferSize)
			{
				swResult = sitalProcess_SetInterruptServiceRoutine ((ISR_FUNCTION)NULL);
				dsspDeviceState->dwInternalImr &= ( ~ (sitalInterruptRegister2_RT_COMMAND_STACK_HALF_ROLLOVER | sitalInterruptRegister2_MT_COMMAND_STACK_HALF_ROLLOVER | sitalInterruptRegister2_MT_DATA_STACK_HALF_ROLLOVER | sitalInterruptRegister1_BC_RT_COMMAND_STACK_ROLLOVER | sitalInterruptRegister1_MT_COMMAND_STACK_ROLLOVER | sitalInterruptRegister1_MT_DATA_STACK_ROLLOVER | sitalInterruptRegister1_TIME_TAG_ROLLOVER | sitalInterruptRegister1_END_OF_MESSAGE) );
			}
			else // MT host buffer still installed for given RT&MT device:
			{
				dsspDeviceState->dwInternalImr &= ( ~ (sitalInterruptRegister2_RT_COMMAND_STACK_HALF_ROLLOVER | sitalInterruptRegister1_BC_RT_COMMAND_STACK_ROLLOVER | sitalInterruptRegister1_END_OF_MESSAGE) );
			}
		}
		else // sitalMode_RT
		{
			swResult = sitalProcess_SetInterruptServiceRoutine ((ISR_FUNCTION)NULL);
			dsspDeviceState->dwInternalImr &= ( ~ (sitalInterruptRegister2_RT_COMMAND_STACK_HALF_ROLLOVER | sitalInterruptRegister1_BC_RT_COMMAND_STACK_ROLLOVER | sitalInterruptRegister1_TIME_TAG_ROLLOVER | sitalInterruptRegister1_END_OF_MESSAGE) );
		}
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Record the newly received messages from the command stack of given RT device into its host buffer.
///
/// Note:
/// - User applications should not principally use this function, as it is automatically called by this library whenever a relevant interrupt occurs.
///   This function has been originally exported only in order to enable working with operating systems that does not support interrupts.
/// - Messages are recorded in the host buffer only as long that it isn't full, that is, there's no override of old messages by new ones.
///   The user must repeatedly get messages from the host buffer in order to empty it.
///
/// Equivalent DDC definition: aceRTMTStkToHBuf
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRt_HostBuffer_Message_Record (S16BIT swDevice)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalMode_RT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	/// Read the target command stack pointer.
	U16BIT wAddressOfMessageToWrite; // The current value of the stack pointer.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, rtAddressMap_COMMAND_STACK_POINTER, sitalDeviceMemorySection_Ram, 1U, &wAddressOfMessageToWrite);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Update the target command stack pointer.
	// Note: In order to save CPU time, no ISR is set with RT devices while no host buffer is installed, so in such case the current stack pointer and stack statistics are updated only when the user calls functions sitalRt_Message_GetFromStackRaw, sitalRt_Message_GetFromStackDecoded, or sitalRt_HostBuffer_Message_Record.
	RtStackStateStructure* rssspTargetStackState; // A pointer to the state structure of the target stack.
	rssspTargetStackState = (RtStackStateStructure*)&(dsspDeviceState->rms.rsRtState.rsssStackState);
	rssspTargetStackState->dwAddressOfMessageToWrite = wAddressOfMessageToWrite;

	///	If configured to collect operational statistics for given device:
	///		Update stack fullness statistics for given device.
	if (TRUE == dsspDeviceState->bIsOperationalStatisticsCollected)
	{
		rssspTargetStackState->wFullnessPercentage = (U16BIT)( (double)100.0 * (((rssspTargetStackState->dwAddressOfMessageToRead > rssspTargetStackState->dwAddressOfMessageToWrite) ? rssspTargetStackState->wCommandStackSize : 0U) + rssspTargetStackState->dwAddressOfMessageToWrite - rssspTargetStackState->dwAddressOfMessageToRead) / rssspTargetStackState->wCommandStackSize );
		rssspTargetStackState->wMaximumFullnessPercentage = ( (rssspTargetStackState->wMaximumFullnessPercentage < rssspTargetStackState->wFullnessPercentage) ? rssspTargetStackState->wFullnessPercentage : rssspTargetStackState->wMaximumFullnessPercentage );
	}

	HostBufferStructure* hbspHostBuffer; // A host buffer structure.
	hbspHostBuffer = (HostBufferStructure*)&(dsspDeviceState->rms.rsRtState.hbsHostBuffer);
	if (0U == hbspHostBuffer->dwHostBufferSize)
	{
		return sitalReturnCode_HOST_BUFFER_NOT_INSTALLED;
	}

	/// Cyclically calculate the device memory address of the command stack entry where the previously read message was read from.
	/// Re-read the BSW of the previously read command stack message.
	/// If the BSW of the previously read command stack message isn't anymore reset to zero:
	///		Count all stack message entries from the next to read until then currently written into (including) as lost messages.
	///		Promote the address of the next stack entry to read to the entry that cyclically follows the one currently written into.
	// Note:
	// - The RT device does not save invalid messages in its stack, so the BSW (block status word), which is the first word in each stack message entry, may not be zero, as zero is an invalid value for the BSW.
	// - The BSW is set zero only when purged by this library. Therefore, if the BSW of the previously read message isn't zero anymore, it says that the device refilled this stack message entry after its last purge.
	// - If the previously read message entry has been refilled by the device, then the device also refilled all the stack message entries from the next one to read to the currently written one (included). All these messages are considered lost.
	// - This library should in this case quickly move to the stack entry next to the one that's currently written into, and cyclically read all the messages from this entry and on, until getting to the stack entry that's currently written into.
	U32BIT dwAddressOfPreviouslyReadMessage; // The device memory address of the command stack entry where the previously read message was read from.
	if (rssspTargetStackState->dwCommandStackBaseAddress == rssspTargetStackState->dwAddressOfMessageToRead)
	{
		dwAddressOfPreviouslyReadMessage = (rssspTargetStackState->dwCommandStackBorderAddress - sitalRtMemoryObjectSize_COMMAND_STACK_ENTRY);
	}
	else
	{
		dwAddressOfPreviouslyReadMessage = (rssspTargetStackState->dwAddressOfMessageToRead - sitalRtMemoryObjectSize_COMMAND_STACK_ENTRY);
	}

	U16BIT wBlockStatusWord; // Message block status.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, dwAddressOfPreviouslyReadMessage, sitalDeviceMemorySection_Ram, 1U, &wBlockStatusWord);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	if (0U != wBlockStatusWord)
	{
		rssspTargetStackState->dwLostMessageCount += ( ( (((rssspTargetStackState->dwAddressOfMessageToRead > rssspTargetStackState->dwAddressOfMessageToWrite) ? rssspTargetStackState->wCommandStackSize : 0U) + rssspTargetStackState->dwAddressOfMessageToWrite - rssspTargetStackState->dwAddressOfMessageToRead) / sitalRtMemoryObjectSize_COMMAND_STACK_ENTRY ) + 1 );

		rssspTargetStackState->dwAddressOfMessageToRead += sitalRtMemoryObjectSize_COMMAND_STACK_ENTRY;
		rssspTargetStackState->dwAddressOfMessageToRead = ( (rssspTargetStackState->dwCommandStackBorderAddress == rssspTargetStackState->dwAddressOfMessageToRead) ? rssspTargetStackState->dwCommandStackBaseAddress : rssspTargetStackState->dwAddressOfMessageToRead );
	}

	/// While there are more unread messages in the target command stack of given RT device:
	///		If the host buffer of given device isn't full:
	///			Copy another unread message from the target command stack of given RT device into its host buffer.
	///			Cyclically update the offset where to record the next message in the host buffer of given device.
	///			If configured to collect operational statistics for given device:
	///				Update host buffer fullness statistics for the host buffer given device.
	///		Else:
	///			Copy another unread message from the target command stack of given MT device into a temporary buffer.
	///			Increment the number of lost messages for the host buffer of given device.
	U16BIT* wpNextMessage; // A pointer to the place in the currently filled host buffer where the next message should be written.
	wpNextMessage = (hbspHostBuffer->waBuffer + hbspHostBuffer->dwOffsetOfNextMessageToWrite);
	U16BIT* wpNextTimeTagRolloverCount; // A pointer to the place in the time tag rollover count array of the currently filled host buffer where the time tag rollover count next message should be written.
	wpNextTimeTagRolloverCount = (hbspHostBuffer->waTimeTagRolloverCount + (hbspHostBuffer->dwOffsetOfNextMessageToWrite / sitalRtMaximum_MESSAGE_SIZE));
	U16BIT waBuffer[sitalRtMaximum_MESSAGE_SIZE]; // A temporary buffer to store within a message in its raw state.
	while (rssspTargetStackState->dwAddressOfMessageToRead != rssspTargetStackState->dwAddressOfMessageToWrite)
	{
		if ((hbspHostBuffer->dwOffsetOfNextMessageToWrite != hbspHostBuffer->dwOffsetOfNextMessageToRead) || (0U == hbspHostBuffer->dwMessageCount))
		{
			swResult = rt_Message_GetFromStackRaw (swDevice, wpNextMessage, wpNextTimeTagRolloverCount, TRUE, TRUE);
			if (1 == swResult)
			{
				hbspHostBuffer->dwOffsetOfNextMessageToWrite += sitalRtMaximum_MESSAGE_SIZE;
				wpNextMessage += sitalRtMaximum_MESSAGE_SIZE;
				wpNextTimeTagRolloverCount++;
				if (hbspHostBuffer->dwHostBufferSize == hbspHostBuffer->dwOffsetOfNextMessageToWrite)
				{
					hbspHostBuffer->dwOffsetOfNextMessageToWrite = 0U;
					wpNextMessage = hbspHostBuffer->waBuffer;
					wpNextTimeTagRolloverCount = hbspHostBuffer->waTimeTagRolloverCount;
				}

				hbspHostBuffer->dwMessageCount = ( (((hbspHostBuffer->dwOffsetOfNextMessageToRead > hbspHostBuffer->dwOffsetOfNextMessageToWrite) ? hbspHostBuffer->dwHostBufferSize : 0U) + hbspHostBuffer->dwOffsetOfNextMessageToWrite - hbspHostBuffer->dwOffsetOfNextMessageToRead) / sitalRtMaximum_MESSAGE_SIZE );

				if (TRUE == dsspDeviceState->bIsOperationalStatisticsCollected)
				{
					hbspHostBuffer->wFullnessPercentage = (U16BIT)( (double)100.0 * (double)(((hbspHostBuffer->dwOffsetOfNextMessageToRead > hbspHostBuffer->dwOffsetOfNextMessageToWrite) ? hbspHostBuffer->dwHostBufferSize : 0U) + hbspHostBuffer->dwOffsetOfNextMessageToWrite - hbspHostBuffer->dwOffsetOfNextMessageToRead) / ((double)(hbspHostBuffer->dwHostBufferSize)) );
					hbspHostBuffer->wMaximumFullnessPercentage = ( (hbspHostBuffer->wMaximumFullnessPercentage < hbspHostBuffer->wFullnessPercentage) ? hbspHostBuffer->wFullnessPercentage : hbspHostBuffer->wMaximumFullnessPercentage );
				}
			}
		}
		else
		{
			hbspHostBuffer->dwLostMessageCount++;
			swResult = rt_Message_GetFromStackRaw (swDevice, waBuffer, ((U16BIT*)NULL), (BOOLEAN)TRUE, (BOOLEAN)TRUE);
		}

		if ((S16BIT)0U > swResult)
		{
			return swResult;
		}
		else
		if ((S16BIT)0U == swResult)
		{
			return sitalReturnCode_SUCCESS;
		}
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Get the number of messages that are currently available in the host buffer that is assigned with given RT device.
///
/// Equivalent DDC definition: aceRTGetHBufMsgCount
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @return Non-negative integer	The number of messages that are currently available in the host buffer that is assigned with given device
/// @return Negative sitalReturnCode_*	Error condition or function failed
S16BIT _DECL sitalRt_HostBuffer_Message_GetCount (S16BIT swDevice)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalMode_RT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	HostBufferStructure* hbspHostBuffer; // A host buffer structure.
	hbspHostBuffer = (HostBufferStructure*)&(dsspDeviceState->rms.rsRtState.hbsHostBuffer);
	if (0U == hbspHostBuffer->dwHostBufferSize)
	{
		return sitalReturnCode_HOST_BUFFER_NOT_INSTALLED;
	}

	return (S16BIT)hbspHostBuffer->dwMessageCount;
}


/// <summary>
/// Read from the host buffer of given RT device the message at given location, decode it into given structure, and purge it if so required.
/// Also get the number of retrieved messages (actually only 0 or 1), the host buffer's current number of lost messages, and the current number of lost messages for given RT device's RT stack.
///
/// Note:
/// - In case of a mode code message with data, this data word is returned as the first (actually the single) data word.
/// - In case a host buffer is assigned to a device, then right after any new message is recorded in this host buffer, that message is purged from the stack.
///   In other words, the usage of a host buffer and the usage of sital*_Message_Get* functions is basically mutually exclussive.
///
/// Equivalent DDC definition: aceRTGetStkMsgDecoded
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param dmspDecodedMessage (out)	A pointer to a structure into which a message is decoded
/// @param dwpMessageCount (out)	A pointer to a variable in which the number of retrieved messages (actually only 0 or 1) is returned
/// @param dwpStackLostMessageCount (out)	A pointer to a variable in which given device stack's current number of lost messages is returned
/// @param dwpHostBufferLostMessageCount (out)	A pointer to a variable in which the host buffer's current number of lost messages is returned
/// @param wMessageLocationAndRemoval (in)	The location in the stack or host buffer of the message to read, and removal instructions (sitalMessageLocationAndRemoval_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
S16BIT _DECL sitalRt_HostBuffer_Message_GetDecoded (	S16BIT swDevice,
														sitalDecodedMessageStructure* dmspDecodedMessage,
														U32BIT* dwpMessageCount,
														U32BIT* dwpStackLostMessageCount,
														U32BIT* dwpHostBufferLostMessageCount,
														U16BIT wMessageLocationAndRemoval)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalMode_RT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((((sitalDecodedMessageStructure*)NULL) == dmspDecodedMessage) || (((U32BIT*)NULL) == dwpMessageCount) || (((U32BIT*)NULL) == dwpHostBufferLostMessageCount) || (((U32BIT*)NULL) == dwpStackLostMessageCount))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if ((0U > wMessageLocationAndRemoval) || (messageLocationAndRemoval_BORDER <= wMessageLocationAndRemoval))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	HostBufferStructure* hbspHostBuffer; // A host buffer structure.
	hbspHostBuffer = (HostBufferStructure*)&(dsspDeviceState->rms.rsRtState.hbsHostBuffer);
	if (0U == hbspHostBuffer->dwHostBufferSize)
	{
		return sitalReturnCode_HOST_BUFFER_NOT_INSTALLED;
	}

	///	Set the returned counts of lost messages.
	(*dwpHostBufferLostMessageCount) = hbspHostBuffer->dwLostMessageCount;
	(*dwpStackLostMessageCount) = dsspDeviceState->rms.rsRtState.rsssStackState.dwLostMessageCount;

	/// If no messages are available in the host buffer of given device:
	///		Properly set the returned count of messages.
	///		Return.
	if ((0U == hbspHostBuffer->dwMessageCount) || (hbspHostBuffer->dwOffsetOfNextMessageToRead == hbspHostBuffer->dwOffsetOfNextMessageToWrite))
	{
		(*dwpMessageCount) = 0U;
		return sitalReturnCode_SUCCESS;
	}

	/// Interpret given message location directive.
	BOOLEAN bIsNextMessageRequired; // A flag that says whether to read the next available message (or, else, the last available one).
	bIsNextMessageRequired = (BOOLEAN)((U16BIT)sitalMessageLocation_NEXT == ((U16BIT)messageLocationAndRemoval_LOCATION & wMessageLocationAndRemoval));

	/// Interpret given message removal directive.
	BOOLEAN bIsMessagePurgeRequired; // A flag that says whether to delete the record of the message that's read.
	bIsMessagePurgeRequired = (BOOLEAN)((U16BIT)sitalMessageRemoval_PURGE == ((U16BIT)messageLocationAndRemoval_REMOVAL & wMessageLocationAndRemoval));

	/// Use given message location and purge directives to:
	///		Point the place in host buffer of given device where the requested message is presumably stored.
	///		If the returned message should be purged:
	///			Purge returned message.
	// With all above operations the possibility of an interim rollover is, of course, taken in account below.
	// Note that here 'Purge' solely means a proper update of the host buffer's internal offsets, not an actual zeroing of the message, so it still may be later on decoded (see below).
	U16BIT* wapBuffer; // A pointer to the place in the host buffer in which the requested raw message is stored.
	if (bIsNextMessageRequired)
	{
		wapBuffer = (hbspHostBuffer->waBuffer + hbspHostBuffer->dwOffsetOfNextMessageToRead);

		if (bIsMessagePurgeRequired)
		{
			hbspHostBuffer->dwOffsetOfNextMessageToRead += sitalRtMaximum_MESSAGE_SIZE;
			hbspHostBuffer->dwOffsetOfNextMessageToRead = ( (hbspHostBuffer->dwHostBufferSize == hbspHostBuffer->dwOffsetOfNextMessageToRead) ? 0 : hbspHostBuffer->dwOffsetOfNextMessageToRead );

			hbspHostBuffer->dwMessageCount--;
		}
	}
	else // Last message required
	{
		U32BIT dwOffsetOfLatestWrittenMessage; // The offset (in words) from the beginning of the host buffer of the location where the latest message has been written.
		dwOffsetOfLatestWrittenMessage = ( ((0U == hbspHostBuffer->dwOffsetOfNextMessageToWrite) ? hbspHostBuffer->dwHostBufferSize : hbspHostBuffer->dwOffsetOfNextMessageToWrite) - sitalRtMaximum_MESSAGE_SIZE );
		wapBuffer = (hbspHostBuffer->waBuffer + dwOffsetOfLatestWrittenMessage);

		if (bIsMessagePurgeRequired)
		{
			hbspHostBuffer->dwOffsetOfNextMessageToRead = hbspHostBuffer->dwOffsetOfNextMessageToWrite;
			hbspHostBuffer->dwMessageCount = 0U;
		}
	}

	///	If the returned message should be purged and configured to collect operational statistics for given device:
	///		Update the fullness statistics for given device.
	if ((TRUE == bIsMessagePurgeRequired) && (TRUE == dsspDeviceState->bIsOperationalStatisticsCollected))
	{
		hbspHostBuffer->wFullnessPercentage = (U16BIT)( (double)100.0 * (double)(((hbspHostBuffer->dwOffsetOfNextMessageToRead > hbspHostBuffer->dwOffsetOfNextMessageToWrite) ? hbspHostBuffer->dwHostBufferSize : 0U) + hbspHostBuffer->dwOffsetOfNextMessageToWrite - hbspHostBuffer->dwOffsetOfNextMessageToRead) / ((double)(hbspHostBuffer->dwHostBufferSize)) );
	}

	/// If succeeds to decode a new message starting at the pointed place in host buffer of given device:
	///		Properly set the returned count of messages.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalRt_Message_DecodeRaw (swDevice, wapBuffer, dmspDecodedMessage);
	(*dwpMessageCount) = ( (sitalReturnCode_SUCCESS == swResult) ? 1U : 0U );

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Read from the host buffer of given RT device as many currently available raw messages as possible (that is, as the size of given buffer permits).
/// Remove from the host buffer the messages that were read.
///
/// Note:
/// - Given buffer is first zeroed, and then filled with available messages, where each message is stored as follows:
///   - A number of sitalRtMaximum_MESSAGE_SIZE memory words is dedicated per message, never mind its actual size.
///   - The target RT stack entry is copied into given buffer.
///   - The data stack pointer is replaced with a word whose:
///     - MSByte contains the count of data words for the message that was read.
///     - LSByte contains the type of the message that was read (sitalMessageType_*).
///   - The data words are stored right after the stack entry, that is, starting at offset sitalRtMemoryObjectSize_COMMAND_STACK_ENTRY.
///     In case of a mode code message with data, this data word is returned as the first (actually the single) data word.
/// - In case a host buffer is assigned to a device, then right after any new message is recorded in this host buffer, that message is purged from the stack.
///   In other words, the usage of a host buffer and the usage of sital*_Message_Get* functions is basically mutually exclussive.
///
/// Equivalent DDC definition: aceRTGetHBufMsgsRaw
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wapBuffer (out)	A pointer to a buffer in which the raw messages are stored
/// @param wBufferSize (in)	The size (in words) of the data buffer that is pointed by wapBuffer (>0)
/// @param dwpMessageCount (out)	A pointer to a variable in which the number of retrieved messages (>=0) is returned
/// @param dwpStackLostMessageCount (out)	A pointer to a variable in which given device stack's current number of lost messages is returned
/// @param dwpHostBufferLostMessageCount (out)	A pointer to a variable in which the host buffer's current number of lost messages is returned
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
S16BIT _DECL sitalRt_HostBuffer_Message_GetRaw (	S16BIT swDevice,
													U16BIT* wapBuffer,
													U16BIT wBufferSize,
													U32BIT* dwpMessageCount,
													U32BIT* dwpStackLostMessageCount,
													U32BIT* dwpHostBufferLostMessageCount)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalMode_RT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((((U16BIT*)NULL) == wapBuffer) || (((U32BIT*)NULL) == dwpMessageCount) || (((U32BIT*)NULL) == dwpHostBufferLostMessageCount) || (((U32BIT*)NULL) == dwpStackLostMessageCount))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if (sitalRtMaximum_MESSAGE_SIZE > wBufferSize)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	HostBufferStructure* hbspHostBuffer; // A host buffer structure.
	hbspHostBuffer = (HostBufferStructure*)&(dsspDeviceState->rms.rsRtState.hbsHostBuffer);
	if (0U == hbspHostBuffer->dwHostBufferSize)
	{
		return sitalReturnCode_HOST_BUFFER_NOT_INSTALLED;
	}

	/// Zero given buffer.
	memset (((void*)wapBuffer), (int)0, (size_t)(wBufferSize << 1U));

	///	Set the returned counts of lost messages.
	(*dwpHostBufferLostMessageCount) = hbspHostBuffer->dwLostMessageCount;
	(*dwpStackLostMessageCount) = dsspDeviceState->rms.rsRtState.rsssStackState.dwLostMessageCount;

	/// Zero the count of returned messages.
	/// While there are more unread messages in the host buffer and there's still place for another message in given buffer:
	///		Copy another message from the host buffer to given buffer.
	///		Point to the place in given buffer where the next message should be stored, if at all.
	///		Decrement the size of the buffer to reflect the remaining size.
	///		Increment the count of raw messages that have been copied.
	///		Purge the message that was just read from the host buffer.
	///		Increment the count of returned messages.
	(*dwpMessageCount) = 0U;
	while ((0U < hbspHostBuffer->dwMessageCount) && (sitalRtMaximum_MESSAGE_SIZE <= wBufferSize))
	{
		void* vp; // A pointer to a void.
		vp = memcpy (((void*)wapBuffer), ((void*)(hbspHostBuffer->waBuffer + hbspHostBuffer->dwOffsetOfNextMessageToWrite)), (size_t)(sitalRtMaximum_MESSAGE_SIZE << 1U));

		wapBuffer += sitalRtMaximum_MESSAGE_SIZE;
		wBufferSize -= sitalRtMaximum_MESSAGE_SIZE;

		hbspHostBuffer->dwOffsetOfNextMessageToRead += sitalRtMaximum_MESSAGE_SIZE;
		hbspHostBuffer->dwOffsetOfNextMessageToRead = ( (hbspHostBuffer->dwHostBufferSize == hbspHostBuffer->dwOffsetOfNextMessageToRead) ? 0 : hbspHostBuffer->dwOffsetOfNextMessageToRead );

		hbspHostBuffer->dwMessageCount--;

		(*dwpMessageCount)++;
	}

	///	If the returned message should be purged and configured to collect operational statistics for given device:
	///		Update the fullness statistics for given device.
	if ((0U < (*dwpMessageCount)) && (TRUE == dsspDeviceState->bIsOperationalStatisticsCollected))
	{
		hbspHostBuffer->wFullnessPercentage = (U16BIT)( (double)100.0 * (double)(((hbspHostBuffer->dwOffsetOfNextMessageToRead > hbspHostBuffer->dwOffsetOfNextMessageToWrite) ? hbspHostBuffer->dwHostBufferSize : 0U) + hbspHostBuffer->dwOffsetOfNextMessageToWrite - hbspHostBuffer->dwOffsetOfNextMessageToRead) / ((double)(hbspHostBuffer->dwHostBufferSize)) );
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Return performance information about the host buffer of given RT device.
///
/// Equivalent DDC definition: aceRTGetHBufMetric
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param hbosspHostBufferOperationalStatistics (out)	A pointer to the host buffer operational statistics structure into which the required operational statistics are written
/// @param bIsResetOfHighestRecordedPercentageRequired (in)	A flag that says whether the record of the highest percentage reached by now should be reset
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRt_HostBuffer_GetOperationalStatistics (S16BIT swDevice, sitalHostBufferOperationalStatisticsStructure* hbosspHostBufferOperationalStatistics, U16BIT bIsResetOfHighestRecordedPercentageRequired)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalMode_RT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (((sitalHostBufferOperationalStatisticsStructure*)NULL) == hbosspHostBufferOperationalStatistics)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if (FALSE == dsspDeviceState->bIsOperationalStatisticsCollected)
	{
		return sitalReturnCode_OPERATIONAL_STATISTICS_NOT_ENABLED;
	}

	HostBufferStructure* hbspHostBuffer; // A host buffer structure.
	hbspHostBuffer = (HostBufferStructure*)&(dsspDeviceState->rms.rsRtState.hbsHostBuffer);
	if (0U == hbspHostBuffer->dwHostBufferSize)
	{
		return sitalReturnCode_HOST_BUFFER_NOT_INSTALLED;
	}

	hbosspHostBufferOperationalStatistics->dwMessageCount = hbspHostBuffer->dwMessageCount;
	hbosspHostBufferOperationalStatistics->dwLostMessageCount = hbspHostBuffer->dwLostMessageCount;
	hbosspHostBufferOperationalStatistics->dwFullnessPercentage = hbspHostBuffer->wFullnessPercentage;
	hbosspHostBufferOperationalStatistics->dwMaximumFullnessPercentage = hbspHostBuffer->wMaximumFullnessPercentage;

	if ((U16BIT)0U != bIsResetOfHighestRecordedPercentageRequired)
	{
		hbspHostBuffer->wMaximumFullnessPercentage = 0U;
	}

	return sitalReturnCode_SUCCESS;
}

/// <summary>
/// Return performance information about the RT command stack.
///
/// Equivalent DDC definition: aceRTGetStkMetric
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param sosspStackOperationalStatistics (out)	A pointer to the stack operational statistics structure into which the required operational statistics are written
/// @param bIsResetOfHighestRecordedPercentageRequired (in)	A flag that says whether the record of the highest percentage reached by now should be reset
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRt_Stack_GetOperationalStatistics (S16BIT swDevice, sitalStackOperationalStatisticsStructure* sosspStackOperationalStatistics, U16BIT bIsResetOfHighestRecordedPercentageRequired)
{
	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if ((sitalMode_RT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (((sitalStackOperationalStatisticsStructure*)NULL) == sosspStackOperationalStatistics)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}
	
	if (FALSE == dsspDeviceState->bIsOperationalStatisticsCollected)
	{
		return sitalReturnCode_OPERATIONAL_STATISTICS_NOT_ENABLED;
	}
	
	sosspStackOperationalStatistics->dwMaximumFullnessPercentage = dsspDeviceState->rms.rsRtState.rsssStackState.wMaximumFullnessPercentage;
	sosspStackOperationalStatistics->dwLostMessageCount = dsspDeviceState->rms.rsRtState.rsssStackState.dwLostMessageCount;
	sosspStackOperationalStatistics->dwFullnessPercentage = dsspDeviceState->rms.rsRtState.rsssStackState.wFullnessPercentage;

	if(bIsResetOfHighestRecordedPercentageRequired)
	{
		dsspDeviceState->rms.rsRtState.rsssStackState.wMaximumFullnessPercentage = 0;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Initialize given device as a MT in accordance with given initialization options.
/// Release any past allocations of device memory.
///
/// Note:
/// - This function assumes that function sitalDevice_Initialize has already been called, initialized given device, and inquired its capabilities.
///   This function then lets the user reinitialize given device with a non default configuration.
/// - Both MT stacks, command and data, must be aligned in the device memory to their size (e.g., a 4096 word stack may be placed only at an address of  the form 4096xN where N=0,1,2,...).
/// - In case the caller specifies stack sizes that the memory of given device is too small to contain, the function call will be rejected.
///
/// Equivalent DDC definition: aceMTConfigure
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wStackMode (in)	Stack mode (sitalMtStackOption_*)
/// @param wCommandStackSize (in)	Size of command stack (sitalMtCommandStackSize_*)
/// @param wDataStackSize (in)	Size of data stack (sitalMtDataStackSize_*)
/// @param dwOptions (in)	Initialization options (An or-ed combination of sitalMtSetupOption_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalMt_Initialize (	S16BIT swDevice,
									U16BIT wStackMode,
									U16BIT wCommandStackSize,
									U16BIT wDataStackSize,
									U32BIT dwOptions)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_MT != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (mtStackOption_BORDER <= wStackMode)
	{
		return sitalReturnCode_MT_INVALID_STACK_OPTION;
	}

	if (0U != ((~mtCommandStackSize_MASK) & wCommandStackSize))
	{
		return sitalReturnCode_MT_INVALID_COMMAND_STACK_SIZE;
	}

	if ( (0U == wDataStackSize) || (0U != ((~mtDataStackSize_MASK) & wDataStackSize)) )
	{
		return sitalReturnCode_MT_INVALID_DATA_STACK_SIZE;
	}

	/// Clear device memory.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Zero, (U32BIT)0U, sitalDeviceMemorySection_Ram, dsspDeviceState->dcsDeviceCapabilities.dwRamSize, ((U16BIT*)NULL));
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Initialize device memory management.
	swResult = Device_Memory_Initialize (&(dsspDeviceState->hdmmsDeviceMemoryMap), dsspDeviceState->dcsDeviceCapabilities.dwRamSize);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Catch any permanently allocated regions of device memory.
	swResult = Device_Memory_TopSection_CatchRegion (&(dsspDeviceState->hdmmsDeviceMemoryMap), 0, (mtAddressMap_FREE_MEMORY - 1U));

	/// Initialize MT.
	swResult = mt_Initialize (swDevice, wStackMode, wCommandStackSize, wDataStackSize, dwOptions);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// In case of a real device:
	///		Set a suitable internal ISR.
	///		Configure the user's interrupt mask pseudo register.
	if (sitalAccess_CARD == dsspDeviceState->wAccess)
	{
		swResult = sitalProcess_SetInterruptServiceRoutine ((ISR_FUNCTION)mt_HandleInterrupt);
		dsspDeviceState->dwInternalImr = 0U;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Swap between the active and inactive stacks of given MT device.
///
/// Equivalent DDC definition: aceMTSwapStks
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @return sitalMtActiveStack_*	Indication of the new active stack
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalMt_Stack_Swap (S16BIT swDevice)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalMode_MT != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalMtStackOption_DOUBLE != dsspDeviceState->rms.msMtState.wStackMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_RUN != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	/// Read the current value of configuration register #1.
	/// If the currently used stack is stack A:
	///		Turn to use stack B.
	/// Else:
	///		Turn to use stack A.
	/// Wait for the new configuration to take effect.
	// In case the active area/stack is changed during the reception and processing of messages, the value that's returned when the area/stack bit is read
	// continues to be the old value. Only when that BC frame or RT/MT message is  completed, the newly configured value will be read.
	U16BIT wRegisterValue; // The current value of a target register, or the value to set for a target register.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, sitalRegisterAddress_CONFIGURATION_1, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	U16BIT wActivatedStack; // The currently activated stack.
	wActivatedStack = (U16BIT)( ((U16BIT)sitalMtStackSelector_STACK_A == ((U16BIT)sitalConfigurationRegister1_MT_ACTIVE_STACK & wRegisterValue)) ? sitalMtStackSelector_STACK_B : sitalMtStackSelector_STACK_A );
	wRegisterValue = wActivatedStack;
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, sitalRegisterAddress_CONFIGURATION_1, sitalDeviceMemorySection_Registers, sitalConfigurationRegister1_MT_ACTIVE_STACK, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	do
	{
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, sitalRegisterAddress_CONFIGURATION_1, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
	}
	while (wActivatedStack != (sitalConfigurationRegister1_MT_ACTIVE_STACK & wRegisterValue));

	return (S16BIT)wActivatedStack;
}


/// <summary>
/// Return performance information about the command stack of given MT device.
///
/// Equivalent DDC definition: aceMTGetStkMetric
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param sosspStackOperationalStatistics (out)	A pointer to the stack operational statistics structure into which the required operational statistics are written
/// @param wStackSelector (in)	A selector that specifies the stack[s] whose information is required (sitalMtStackSelector_*)
/// @param bIsResetOfHighestRecordedPercentageRequired (in)	A flag that says whether the record of the highest percentage reached by now should be reset
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalMt_Stack_GetOperationalStatistics (	S16BIT swDevice,
														sitalStackOperationalStatisticsStructure* sosspStackOperationalStatistics,
														U16BIT wStackSelector,
														U16BIT bIsResetOfHighestRecordedPercentageRequired)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if ((sitalMode_MT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (sitalMtStackOption_DOUBLE != dsspDeviceState->rms.msMtState.wStackMode)
	{
		if ((sitalMtStackSelector_STACK_B == wStackSelector) || (sitalMtStackSelector_STACK_COMBINED == wStackSelector))
		{
			return sitalReturnCode_INVALID_PARAMETER;
		}
	}

	if (((sitalStackOperationalStatisticsStructure*)NULL) == sosspStackOperationalStatistics)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if (FALSE == dsspDeviceState->bIsOperationalStatisticsCollected)
	{
		return sitalReturnCode_OPERATIONAL_STATISTICS_NOT_ENABLED;
	}

	switch (wStackSelector)
	{
	case sitalMtStackSelector_STACK_A:
		sosspStackOperationalStatistics->dwMaximumFullnessPercentage = dsspDeviceState->rms.msMtState.msssStackStateA.wMaximumFullnessPercentage;
		sosspStackOperationalStatistics->dwLostMessageCount = dsspDeviceState->rms.msMtState.msssStackStateA.dwLostMessageCount;
		sosspStackOperationalStatistics->dwFullnessPercentage = (U32BIT)dsspDeviceState->rms.msMtState.msssStackStateA.wFullnessPercentage;

		if (bIsResetOfHighestRecordedPercentageRequired)
		{
			dsspDeviceState->rms.msMtState.msssStackStateA.wMaximumFullnessPercentage = 0U;
		}
		break;

	case sitalMtStackSelector_STACK_B:
		sosspStackOperationalStatistics->dwMaximumFullnessPercentage = dsspDeviceState->rms.msMtState.msssStackStateB.wMaximumFullnessPercentage;
		sosspStackOperationalStatistics->dwLostMessageCount = dsspDeviceState->rms.msMtState.msssStackStateB.dwLostMessageCount;
		sosspStackOperationalStatistics->dwFullnessPercentage = (U32BIT)(dsspDeviceState->rms.msMtState.msssStackStateB.wFullnessPercentage);

		if (bIsResetOfHighestRecordedPercentageRequired)
		{
			dsspDeviceState->rms.msMtState.msssStackStateB.wMaximumFullnessPercentage = 0U;
		}
		break;

	case sitalMtStackSelector_STACK_COMBINED:
		sosspStackOperationalStatistics->dwMaximumFullnessPercentage = (U32BIT)( (dsspDeviceState->rms.msMtState.msssStackStateA.wMaximumFullnessPercentage + dsspDeviceState->rms.msMtState.msssStackStateB.wMaximumFullnessPercentage) / (U16BIT)2U );
		sosspStackOperationalStatistics->dwLostMessageCount = (dsspDeviceState->rms.msMtState.msssStackStateA.dwLostMessageCount + dsspDeviceState->rms.msMtState.msssStackStateB.dwLostMessageCount);
		sosspStackOperationalStatistics->dwFullnessPercentage = (U32BIT)( (dsspDeviceState->rms.msMtState.msssStackStateA.wFullnessPercentage + dsspDeviceState->rms.msMtState.msssStackStateB.wFullnessPercentage) / (U16BIT)2U );

		if (bIsResetOfHighestRecordedPercentageRequired)
		{
			dsspDeviceState->rms.msMtState.msssStackStateA.wMaximumFullnessPercentage = 0U;
			dsspDeviceState->rms.msMtState.msssStackStateB.wMaximumFullnessPercentage = 0U;
		}
		break;

	default:
		return sitalReturnCode_INVALID_PARAMETER;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Return information about the configuration of given MT device.
///
/// Equivalent DDC definition: aceMTGetInfo
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param mispMtInformation (out)	A pointer to a structure within which the required configuration information is written
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalMt_GetInformation (S16BIT swDevice, sitalMtInformationStructure* mispMtInformation)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalMode_MT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (((sitalMtInformationStructure*)NULL) == mispMtInformation)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	mispMtInformation->wStackMode = dsspDeviceState->rms.msMtState.wStackMode;
	mispMtInformation->bIsProtocol1553aSupported = dsspDeviceState->bIsProtocol1553aSupported;
	mispMtInformation->wCommandStackSize = dsspDeviceState->rms.msMtState.msssStackStateA.wCommandStackSize;
	mispMtInformation->wDataStackSize = dsspDeviceState->rms.msMtState.msssStackStateA.wDataStackSize;
	mispMtInformation->dwHostBufferSize = dsspDeviceState->rms.msMtState.hbsHostBuffer.dwHostBufferSize;

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Make given MT device start capturing messages.
///
/// Equivalent DDC definition: aceMTStart
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalMt_Start (S16BIT swDevice)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_MT != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((sitalAccess_CARD != dsspDeviceState->wAccess) && (sitalAccess_USER != dsspDeviceState->wAccess))
	{
		return sitalReturnCode_INVALID_ACCESS;
	}

	/// Virtually configure given MT device to be able to start capturing messages.
	S16BIT swResult; // Result of operation or function call.
	swResult = mt_Start (swDevice);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Copy the registers from host to device memory.
	swResult = device_Register_UpdateDevice (swDevice);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Actually start the device.
	U16BIT wRegisterValue; // The current value of a target register, or the value to set for a target register.
	wRegisterValue = sitalStartResetRegister_BC_MT_START;
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_START_OR_RESET, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Update the state of given device.
	//swResult = sitalProcess_Log_PrintLine ("#StldDll.Device.State.Change: device - %i, old - %i, new - %i\n", swDevice, dsspDeviceState->wCurrentState, sitalDeviceState_RUN);
	dsspDeviceState->wCurrentState = sitalDeviceState_RUN;

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Make given MT device stop capturing messages.
///
/// Equivalent DDC definition: aceMTStop
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalMt_Stop (S16BIT swDevice)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_MT != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_RUN != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((sitalAccess_CARD != dsspDeviceState->wAccess) && (sitalAccess_USER != dsspDeviceState->wAccess))
	{
		return sitalReturnCode_INVALID_ACCESS;
	}

	/// Disable interrupts for given MT device.
	U16BIT wRegisterValue; // The current value of a target register, or the value to set for a target register.
	S16BIT swResult; // Result of operation or function call.
	wRegisterValue = registerMask_ALL_BITS_OFF;
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, sitalRegisterAddress_INTERRUPT_MASK_1, sitalDeviceMemorySection_Registers, registerMask_ALL_BITS_ON, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Stop given MT device.
	wRegisterValue = sitalStartResetRegister_BC_MT_STOP_AT_END_OF_MESSAGE;
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_START_OR_RESET, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	//swResult = sitalProcess_Log_PrintLine ("#StldDll.Device.State.Change: device - %i, old - %i, new - %i\n", swDevice, dsspDeviceState->wCurrentState, sitalDeviceState_READY);
	dsspDeviceState->wCurrentState = sitalDeviceState_READY;

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Make given MT device temporarily stop capturing messages.
///
/// Equivalent DDC definition: aceMTPause
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalMt_Pause (S16BIT swDevice)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalMode_MT != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_RUN != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((sitalAccess_CARD != dsspDeviceState->wAccess) && (sitalAccess_USER != dsspDeviceState->wAccess))
	{
		return sitalReturnCode_INVALID_ACCESS;
	}

	/// Pause given MT device.
	U16BIT wRegisterValue; // The current value of a target register, or the value to set for a target register.
	S16BIT swResult; // Result of operation or function call.
	wRegisterValue = sitalStartResetRegister_BC_MT_STOP_AT_END_OF_MESSAGE;
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_START_OR_RESET, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Make given MT device continue capturing messages after a temporary pause.
/// The message capturing activity will continue from the same internal state as at the moment of pausing.
///
/// Equivalent DDC definition: aceMTContinue
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalMt_Continue (S16BIT swDevice)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalMode_MT != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_RUN != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((sitalAccess_CARD != dsspDeviceState->wAccess) && (sitalAccess_USER != dsspDeviceState->wAccess))
	{
		return sitalReturnCode_INVALID_ACCESS;
	}

	/// Make given MT device continue resume its monitoring activity.
	U16BIT wRegisterValue; // The current value of a target register, or the value to set for a target register.
	S16BIT swResult; // Result of operation or function call.
	wRegisterValue = sitalStartResetRegister_BC_MT_START;
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, sitalRegisterAddress_START_OR_RESET, sitalDeviceMemorySection_Registers, 1U, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Configure given MT device to monitor commands that suits given combinations of RT address, RT-related message direction, and subaddress.
///
/// Equivalent DDC definition: aceMTEnableRTFilter
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wRtAddress (in)	A RT address (sitalRtAddress_*)
/// @param wMessageDirection (in)	RT-related message direction (sitalMessageDirection_*)
/// @param dwRtSubaddressMask (in)	Mask of affected subaddresses, 0-31, where bit #i corresponds subaddress #i (An or-ed combination of sitalRtSubaddressMask_0-sitalRtSubaddressMask_31)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalMt_MessageMonitoring_Enable (	S16BIT swDevice,
												U16BIT wRtAddress,
												U16BIT wMessageDirection,
												U32BIT dwRtSubaddressMask)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalMode_MT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ( (sitalRtAddress_ALL != wRtAddress) && ((0U > wRtAddress) || (rtAddress_BORDER <= wRtAddress)) )
	{
		return sitalReturnCode_INVALID_RT_ADDRESS;
	}

	if ( (sitalMessageDirection_BOTH != wMessageDirection) && ((0U > wMessageDirection) || (messageDirection_BORDER <= wMessageDirection)) )
	{
		return sitalReturnCode_INVALID_DIRECTION_BIT;
	}

	/// Set loop delimiters for the address and direction loops.
	U16BIT wAddressLoopBase; // Base value of address loop.
	U16BIT wAddressLoopBorder; // Border value of address loop.
	if (sitalRtAddress_ALL == wRtAddress)
	{
		wAddressLoopBase = 0U;
		wAddressLoopBorder = rtAddress_BORDER;
	}
	else
	{
		wAddressLoopBase = wRtAddress;
		wAddressLoopBorder = (wRtAddress + (U16BIT)1U);
	}
	U16BIT wDirectionLoopBase; // Base value of direction loop.
	U16BIT wDirectionLoopBorder; // Border value of direction loop.
	if (sitalMessageDirection_BOTH == wMessageDirection)
	{
		wDirectionLoopBase = 0U;
		wDirectionLoopBorder = messageDirection_BORDER;
	}
	else
	{
		wDirectionLoopBase = wMessageDirection;
		wDirectionLoopBorder = (wMessageDirection + 1U);
	}

	/// Loop over all given combinations of address and direction:
	///		Update each combination's monitoring specifications.
	for (S16BIT iAddress=(S16BIT)wAddressLoopBase; iAddress<(S16BIT)wAddressLoopBorder; iAddress++)
	{
		for (S16BIT iDirection=(S16BIT)wDirectionLoopBase; iDirection<(S16BIT)wDirectionLoopBorder; iDirection++)
		{
			// Find the device address of the entry of the target table that corresponds current combination.
			U32BIT dwTableEntryAddress; // The device address of an entry in the target table.
			dwTableEntryAddress = ((U32BIT)mtAddressMap_MONITOR_LOOKUP_TABLE | (U32BIT)(iAddress << mtMonitoringLookupTable_OFFSET_OF_ADDRESS_BIT) | (U32BIT)(iDirection << mtMonitoringLookupTable_OFFSET_OF_DIRECTION_BIT));

			// Calculate the new mask.
			U16BIT wMaskLowWord; // The value of the least significant word of the new mask.
			U16BIT wMaskHighWord; // The value of the most significant word of the new mask.
			U32BIT dwNewMask; // The value of the new illegalization mask.
			S16BIT swResult; // Result of operation or function call.
			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, dwTableEntryAddress, sitalDeviceMemorySection_Ram, 1U, &wMaskLowWord);
			if (sitalReturnCode_SUCCESS != swResult)
			{
				return swResult;
			}
			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, (dwTableEntryAddress + 1U), sitalDeviceMemorySection_Ram, 1U, &wMaskHighWord);
			if (sitalReturnCode_SUCCESS != swResult)
			{
				return swResult;
			}
			dwNewMask = wMaskHighWord;
			dwNewMask = ((dwNewMask << 16U) | wMaskLowWord);
			dwNewMask |= dwRtSubaddressMask;

			// Write the new mask in the entry of the target table that corresponds current combination.
			wMaskLowWord = (U16BIT)(dwNewMask & 0xFFFFU);
			wMaskHighWord = (U16BIT)(dwNewMask >> 16U);
			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, dwTableEntryAddress, sitalDeviceMemorySection_Ram, 1U, &wMaskLowWord);
			if (sitalReturnCode_SUCCESS != swResult)
			{
				return swResult;
			}
			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, (dwTableEntryAddress + 1U), sitalDeviceMemorySection_Ram, 1U, &wMaskHighWord);
			if (sitalReturnCode_SUCCESS != swResult)
			{
				return swResult;
			}
		}
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Configure given HOO9 MT device to monitor commands that suits given combinations of RT address, RT-related message direction, and subaddress.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wRtAddress (in)	A RT address (sitalRtAddress_0-sitalRtAddress_15 or sitalRtAddress_ALL)
/// @param wMessageDirection (in)	RT-related message direction/bus (sitalMessageDirection_*)
/// @param qwRtSubaddressMask (in)	Mask of affected subaddresses, 0-63, where bit #i corresponds subaddress #i (An or-ed combination of sitalHoo9RtSubaddressMask_0-sitalHoo9RtSubaddressMask_63)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalHoo9_Mt_MessageMonitoring_Enable (	S16BIT swDevice,
														U16BIT wRtAddress,
														U16BIT wMessageDirection,
														U64BIT qwRtSubaddressMask)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.

	return hoo9_Mt_MessageMonitoring_Configure (swDevice, wRtAddress, wMessageDirection, qwRtSubaddressMask, true);
}


/// <summary>
/// Configure given PP194 MT device to monitor commands that suits given combinations of RT address, RT-related message direction/bus, and subaddress.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wRtAddress (in)	A RT address (sitalRtAddress_0-sitalRtAddress_15 or sitalRtAddress_ALL)
/// @param wMessageDirection (in)	RT-related message direction/bus (sitalMessageDirection_*)
/// @param dwRtSubaddressMask (in)	Mask of affected subaddresses, 0-15, where bit #i corresponds subaddress #i (An or-ed combination of sitalRtSubaddressMask_0-sitalRtSubaddressMask_15)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalPp194_Mt_MessageMonitoring_Enable (	S16BIT swDevice,
														U16BIT wRtAddress,
														U16BIT wMessageDirection,
														U32BIT dwRtSubaddressMask)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if ( (sitalRtAddress_ALL != wRtAddress) && ((0U > wRtAddress) || (sitalRtAddress_16 <= wRtAddress)) )
	{
		return sitalReturnCode_INVALID_RT_ADDRESS;
	}

	if (((U32BIT)sitalRtSubaddressMask_ALL) != (((U32BIT)sitalRtSubaddressMask_ALL) | dwRtSubaddressMask))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Use the 1553 MT message monitoring enabler function.
	return sitalMt_MessageMonitoring_Enable (swDevice, wRtAddress, wMessageDirection, dwRtSubaddressMask);
}


/// <summary>
/// Configure given MT device to avoid monitoring commands that suits given combinations of RT address, RT-related message direction/bus, and subaddress.
///
/// Equivalent DDC definition: aceMTDisableRTFilter
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wRtAddress (in)	A RT address (sitalRtAddress_*)
/// @param wMessageDirection (in)	RT-related message direction (sitalMessageDirection_*)
/// @param dwRtSubaddressMask (in)	Mask of affected subaddresses, 0-31, where bit #i corresponds subaddress #i (An or-ed combination of sitalRtSubaddressMask_0-sitalRtSubaddressMask_31)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalMt_MessageMonitoring_Disable (	S16BIT swDevice,
													U16BIT wRtAddress,
													U16BIT wMessageDirection,
													U32BIT dwRtSubaddressMask)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalMode_MT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ( (sitalRtAddress_ALL != wRtAddress) && ((0U > wRtAddress) || (rtAddress_BORDER <= wRtAddress)) )
	{
		return sitalReturnCode_INVALID_RT_ADDRESS;
	}

	if ( (sitalMessageDirection_BOTH != wMessageDirection) && ((0U > wMessageDirection) || (messageDirection_BORDER <= wMessageDirection)) )
	{
		return sitalReturnCode_INVALID_DIRECTION_BIT;
	}

	/// Set loop delimiters for the address and direction loops.
	U16BIT wAddressLoopBase; // Base value of address loop.
	U16BIT wAddressLoopBorder; // Border value of address loop.
	if (sitalRtAddress_ALL == wRtAddress)
	{
		wAddressLoopBase = 0U;
		wAddressLoopBorder = rtAddress_BORDER;
	}
	else
	{
		wAddressLoopBase = wRtAddress;
		wAddressLoopBorder = (wRtAddress + (U16BIT)1U);
	}
	U16BIT wDirectionLoopBase; // Base value of direction loop.
	U16BIT wDirectionLoopBorder; // Border value of direction loop.
	if (sitalMessageDirection_BOTH == wMessageDirection)
	{
		wDirectionLoopBase = 0U;
		wDirectionLoopBorder = messageDirection_BORDER;
	}
	else
	{
		wDirectionLoopBase = wMessageDirection;
		wDirectionLoopBorder = (wMessageDirection + (U16BIT)1U);
	}

	/// Loop over all given combinations of address and direction:
	///		Update each combination's monitoring specifications.
	for (S16BIT iAddress=(S16BIT)wAddressLoopBase; iAddress<(S16BIT)wAddressLoopBorder; iAddress++)
	{
		for (S16BIT iDirection=(S16BIT)wDirectionLoopBase; iDirection<(S16BIT)wDirectionLoopBorder; iDirection++)
		{
			// Find the address of the entry of the target table that corresponds current combination.
			U32BIT dwTableEntryAddress; // The address of an entry in the target table.
			dwTableEntryAddress = (U32BIT)((U32BIT)mtAddressMap_MONITOR_LOOKUP_TABLE | (U32BIT)(iAddress << mtMonitoringLookupTable_OFFSET_OF_ADDRESS_BIT) | (U32BIT)(iDirection << mtMonitoringLookupTable_OFFSET_OF_DIRECTION_BIT));

			// Calculate the new mask.
			U16BIT wMaskLowWord; // The value of the least significant word of the new mask.
			U16BIT wMaskHighWord; // The value of the most significant word of the new mask.
			U32BIT dwNewMask; // The value of the new illegalization mask.
			S16BIT swResult; // Result of operation or function call.
			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, dwTableEntryAddress, sitalDeviceMemorySection_Ram, 1U, &wMaskLowWord);
			if (sitalReturnCode_SUCCESS != swResult)
			{
				return swResult;
			}
			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, (dwTableEntryAddress + 1U), sitalDeviceMemorySection_Ram, 1U, &wMaskHighWord);
			if (sitalReturnCode_SUCCESS != swResult)
			{
				return swResult;
			}
			dwNewMask = wMaskHighWord;
			dwNewMask = ((dwNewMask << 16U) | wMaskLowWord);
			dwNewMask &= (~dwRtSubaddressMask);

			// Write the new mask in the entry of the target table that corresponds current combination.
			wMaskLowWord = (U16BIT)(dwNewMask & 0xFFFFU);
			wMaskHighWord = (U16BIT)(dwNewMask >> 16U);
			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, dwTableEntryAddress, sitalDeviceMemorySection_Ram, 1U, &wMaskLowWord);
			if (sitalReturnCode_SUCCESS != swResult)
			{
				return swResult;
			}
			swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Write, (dwTableEntryAddress + 1U), sitalDeviceMemorySection_Ram, 1U, &wMaskHighWord);
			if (sitalReturnCode_SUCCESS != swResult)
			{
				return swResult;
			}
		}
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Configure given HOO9 MT device to avoid monitoring commands that suits given combinations of RT address, RT-related message direction, and subaddress.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wRtAddress (in)	A RT address (sitalRtAddress_0-sitalRtAddress_15 or sitalRtAddress_ALL)
/// @param wMessageDirection (in)	RT-related message direction/bus (sitalMessageDirection_*)
/// @param qwRtSubaddressMask (in)	Mask of affected subaddresses, 0-63, where bit #i corresponds subaddress #i (An or-ed combination of sitalHoo9RtSubaddressMask_0-sitalHoo9RtSubaddressMask_63)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalHoo9_Mt_MessageMonitoring_Disable (	S16BIT swDevice,
														U16BIT wRtAddress,
														U16BIT wMessageDirection,
														U64BIT qwRtSubaddressMask)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.

	return hoo9_Mt_MessageMonitoring_Configure (swDevice, wRtAddress, wMessageDirection, qwRtSubaddressMask, false);
}


/// <summary>
/// Configure given PP194 MT device to avoid monitoring commands that suits given combinations of RT address, RT-related message direction/bus, and subaddress.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wRtAddress (in)	A RT address (sitalRtAddress_0-sitalRtAddress_15 or sitalRtAddress_ALL)
/// @param wMessageDirection (in)	RT-related message direction/bus (sitalMessageDirection_*)
/// @param dwRtSubaddressMask (in)	Mask of affected subaddresses, 0-15, where bit #i corresponds subaddress #i (An or-ed combination of sitalRtSubaddressMask_0-sitalRtSubaddressMask_15)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalPp194_Mt_MessageMonitoring_Disable (	S16BIT swDevice,
														U16BIT wRtAddress,
														U16BIT wMessageDirection,
														U32BIT dwRtSubaddressMask)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if ( (sitalRtAddress_ALL != wRtAddress) && ((0U > wRtAddress) || (sitalRtAddress_16 <= wRtAddress)) )
	{
		return sitalReturnCode_INVALID_RT_ADDRESS;
	}

	if (((U32BIT)sitalRtSubaddressMask_ALL) != (((U32BIT)sitalRtSubaddressMask_ALL) | dwRtSubaddressMask))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Use the 1553 MT message monitoring enabler function.
	return sitalMt_MessageMonitoring_Disable (swDevice, wRtAddress, wMessageDirection, dwRtSubaddressMask);
}


/// <summary>
/// Get for given MT device and combination of RT address and RT-related message direction a mask specifying the monitored subaddresses.
///
/// Note:
/// - In case no subaddress is monitored for given RT device address and direction, the returned subaddress mask will be zero.
///
/// Equivalent DDC definition: aceMTGetRTFilter
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wRtAddress (in)	A RT address (sitalRtAddress_0-sitalRtAddress_31)
/// @param wMessageDirection (in)	RT-related message direction (sitalMessageDirection_RX or sitalMessageDirection_TX)
/// @param dwpRtSubaddressMask (out)	A pointer to a variable within which a mask of monitored subaddresses, 0-31, where bit #i corresponds subaddress #i, is returned, what forms an or-ed combination of sitalRtSubaddressMask_*
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalMt_MessageMonitoring_GetStatus (	S16BIT swDevice,
													U16BIT wRtAddress,
													U16BIT wMessageDirection,
													U32BIT* dwpRtSubaddressMask)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalMode_MT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((0U > wRtAddress) || (rtAddress_BORDER <= wRtAddress))
	{
		return sitalReturnCode_INVALID_RT_ADDRESS;
	}

	if ((0U > wMessageDirection) || (messageDirection_BORDER <= wMessageDirection))
	{
		return sitalReturnCode_INVALID_DIRECTION_BIT;
	}

	if (((U32BIT*)NULL) == dwpRtSubaddressMask)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Find the address of the entry of the target table that corresponds given combination.
	U32BIT dwTableEntryAddress; // The address of an entry in the target table.
	dwTableEntryAddress = (U32BIT)((U16BIT)mtAddressMap_MONITOR_LOOKUP_TABLE | (U16BIT)(wRtAddress << mtMonitoringLookupTable_OFFSET_OF_ADDRESS_BIT) | (U16BIT)(wMessageDirection << mtMonitoringLookupTable_OFFSET_OF_DIRECTION_BIT));

	/// Read current word count or mode code mask.
	U16BIT wMaskLowWord; // The value of the least significant word of the new mask.
	U16BIT wMaskHighWord; // The value of the most significant word of the new mask.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, dwTableEntryAddress, sitalDeviceMemorySection_Ram, 1U, &wMaskLowWord);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, (dwTableEntryAddress + 1U), sitalDeviceMemorySection_Ram, 1U, &wMaskHighWord);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	(*dwpRtSubaddressMask) = wMaskHighWord;
	(*dwpRtSubaddressMask) = (((*dwpRtSubaddressMask) << 16U) | wMaskLowWord);

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Get for given HOO9 MT device and combination of RT address and RT-related message direction a mask specifying the monitored subaddresses.
///
/// Note:
/// - In case no subaddress is monitored for given RT device address and direction, the returned subaddress mask will be zero.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wRtAddress (in)	A RT address (sitalRtAddress_0-sitalRtAddress_31)
/// @param wMessageDirection (in)	RT-related message direction (sitalMessageDirection_RX or sitalMessageDirection_TX)
/// @param qwpRtSubaddressMask (out)	A pointer to a variable within which a mask of monitored subaddresses, 0-63, where bit #i corresponds subaddress #i, is returned, what forms an or-ed combination of sitalHoo9RtSubaddressMask_*
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalHoo9_Mt_MessageMonitoring_GetStatus (	S16BIT swDevice,
														U16BIT wRtAddress,
														U16BIT wMessageDirection,
														U64BIT* qwpRtSubaddressMask)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.

	if ((0U > wRtAddress) || (sitalRtAddress_16 <= wRtAddress))
	{
		return sitalReturnCode_INVALID_RT_ADDRESS;
	}

	if (((U64BIT*)NULL) == qwpRtSubaddressMask)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// First use the 1553 MT message monitoring enabler function twice, one in order to get the monitoring state of the lower 32 RT subaddresses.
	U16BIT wFakeRtAddress; // A fake 5-bits RT address whose 4 MSbits are set to given RT address and 1 LSbit is set to given direction; used in order to adapt to the structure of the monitoring lookup table of a HOO9-MT.
	wFakeRtAddress = ( (wRtAddress << 1U) | wMessageDirection );
	U16BIT wFakeMessageDirection; // A fake message direction that really flags whether the lower or higher 32 RT addresses are to be handled in this turn; used in order to adapt to the structure of the monitoring lookup table of a HOO9-MT.
	wFakeMessageDirection = sitalMessageDirection_RX;
	U32BIT dwRtSubaddressMask; // A mask of monitored subaddresses, 0-31, where bit #i corresponds subaddress #i, what forms an or-ed combination of sitalRtSubaddressMask_*.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalMt_MessageMonitoring_GetStatus (swDevice, wRtAddress, wMessageDirection, &dwRtSubaddressMask);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	(*qwpRtSubaddressMask) = dwRtSubaddressMask;

	/// Then use the 1553 MT message monitoring enabler function twice, one in order to get the monitoring state of the higher 32 RT subaddresses.
	wFakeMessageDirection = sitalMessageDirection_TX;
	swResult = sitalMt_MessageMonitoring_GetStatus (swDevice, wRtAddress, wMessageDirection, &dwRtSubaddressMask);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}
	(*qwpRtSubaddressMask) |= (((U64BIT)dwRtSubaddressMask) << 32U);

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Get for given PP194 MT device and combination of RT address and RT-related message direction/bus a mask specifying the monitored subaddresses.
///
/// Note:
/// - In case no subaddress is monitored for given RT device address and direction, the returned subaddress mask will be zero.
///
/// Equivalent DDC definition: aceMTGetRTFilter
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wRtAddress (in)	A RT address (sitalRtAddress_0-sitalRtAddress_31)
/// @param wMessageDirection (in)	RT-related message direction/bus (sitalMessageDirection_RX or sitalMessageDirection_TX)
/// @param dwpRtSubaddressMask (out)	A pointer to a variable within which a mask of monitored subaddresses, 0-15, where bit #i corresponds subaddress #i, is returned, what forms an or-ed combination of sitalRtSubaddressMask_0-sitalRtSubaddressMask_15
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalPp194_Mt_MessageMonitoring_GetStatus (	S16BIT swDevice,
															U16BIT wRtAddress,
															U16BIT wMessageDirection,
															U32BIT* dwpRtSubaddressMask)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if ( (sitalRtAddress_ALL != wRtAddress) && ((0U > wRtAddress) || (sitalRtAddress_16 <= wRtAddress)) )
	{
		return sitalReturnCode_INVALID_RT_ADDRESS;
	}

	/// Use the function that gets the status of 1553 MT message monitoring.
	return sitalMt_MessageMonitoring_GetStatus (swDevice, wRtAddress, wMessageDirection, dwpRtSubaddressMask);
}


/// <summary>
/// Decode given message of given MT device into given structure.
///
/// Note:
/// - This function does not really require the logical number of the relevant device, which isn't removed only in order to stay compatible with DDC.
///   (DDC use this parameter to verify the given device is a MT at state READY or RUN, which is a non really required restriction.)
/// - This function assumes that given buffer is at least sitalMtMaximum_MESSAGE_SIZE words long.
/// - This function assumes that given buffer has been previously filled by function sitalMt_Message_GetFromStackRaw.
///   See the documentation for this function for information on the contents of its returned buffer.
/// - In case given buffer contains a mode code message with data, this data word is returned as the first (actually the single) data word.
/// - Unless given message is a RT-to-RT message, then no more than a single RT is involved with it. In such a non-RT-to-RT message that involves a
///   single RT, if this RT isn't currently monitored by the monitoring MT device, the message isn't recorded at all.
///   In case of a RT-to-RT message there are two RTs involved. If both RTs aren't currently monitored by the monitoring MT device, the message isn't
///   recorded at all. If only one of them is currently monitored by the monitoring MT device, the message is recorded in the command and data stacks
///   in a somewhat distorted way. Now, since this function may be called even a long time after given raw message has been recorded, and the list of
///   monitored RTs may have changed in the while, this function has no way to determine if and how given raw message has been distorted. Therefore,
///   this function does not take in account such situations, what entails in an incorrect decoding of raw RT-to-RT messages that have been recorded
///   while any of their involved RTs wasn't monitored by the monitoring MT. This function behaves this way also in order to stay compatible with DDC.
///
/// Equivalent DDC definition: aceMTDecodeRawMsg
/// @param swDevice (in)	Logical number of device (0-31, unused)
/// @param wapBuffer (in)	A pointer to a buffer in which a raw message is stored
/// @param dmspDecodedMessage (out)	A pointer to a structure into which a message is decoded
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalMt_Message_DecodeRaw (S16BIT swDevice, U16BIT* wapBuffer, sitalDecodedMessageStructure* dmspDecodedMessage)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((sitalDecodedMessageStructure*)NULL) == dmspDecodedMessage)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if (((U16BIT*)NULL) == wapBuffer)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	/// Extricate the type of given message.
	/// Extricate the actual number of data words in given message.
	/// Calculate the principal number of data words for a message of this type.
	// Within given raw message block the data block address field has been overridden with a combined word value whose:
	// - LSByte contains the type of given message.
	// - The MSbit (bit #7) of the MSByte is set in case an error has been discovered with the data words.
	// - The rest of the bits (bits #0-6) of the MSByte contain the actual count of data words of given message.
	//   This actual count of data words includes:
	//   - The second command (in case of a RT-to-RT message).
	//   - The actual net number data words.
	//   - Any involved statuses.
	U16BIT wRawMessageType; // The raw value of the field that contains the type of given message.
	wRawMessageType = wapBuffer[mtCommandStackEntry_OFFSET_OF_DATA_BLOCK_ADDRESS];
	U16BIT wMessageType; // The type of given message.
	wMessageType = ((U16BIT)0xFFU & wRawMessageType);
	BOOLEAN bIsErrorInData; // A flag that says whether there was any error with the data words.
	bIsErrorInData = (BOOLEAN)( ((U16BIT)0U == ((U16BIT)0x8000U & wRawMessageType)) ? FALSE : TRUE );
	U16BIT wActualDataWordCount; // The number of data words that were actually received in given message.
	wActualDataWordCount = ((U16BIT)0x7FU & (wRawMessageType >> 8U));
	if (0U == wActualDataWordCount)
	{
		wActualDataWordCount = 32U;
	}
	U16BIT wCommandWord1; // Given message's command word 1.
	wCommandWord1 = wapBuffer[mtCommandStackEntry_OFFSET_OF_COMMAND];
	U16BIT wCommandWordCount; // The number of data words as decoded in the command of given message.
	wCommandWordCount = (((U16BIT)commandWord_WORD_COUNT_OR_MODE_CODE & wCommandWord1) >> commandWord_OFFSET_OF_WORD_COUNT_OR_MODE_CODE);
	if (0U == wCommandWordCount)
	{
		wCommandWordCount = 32U;
	}

	/// Find the minimum of the actual and principal numbers of data words.
	// The actual number of data words not only counts actual net number data words, but rather the whole number of words in the data stack entry of
	// given message. The principal number of data words should be therefore used instead. Yet, it may happen that the actual net number of received
	// data words was lower than the principally required number. So the conclusion of all this is that their minimum should be specified as given
	// message's word count.
	U16BIT wMinimalWordCount; // The minimum of the principal and actual numbers of given message's data words.
	wMinimalWordCount = ( (wActualDataWordCount < wCommandWordCount) ? wActualDataWordCount : wCommandWordCount );
	U16BIT* wpDataStackSection; // A pointer to the section of given buffer where the data words will be stored.
	wpDataStackSection = &(wapBuffer[sitalMtMemoryObjectSize_COMMAND_STACK_ENTRY]);

	/// Initialize given message structure.
	memset (dmspDecodedMessage, 0, sizeof(sitalDecodedMessageStructure));

	/// Decode message information from given raw message into given message structure.
	dmspDecodedMessage->wType = wMessageType;
	dmspDecodedMessage->wCommandWord1 = wCommandWord1;
	dmspDecodedMessage->bIsCommandWord1Relevant = TRUE;
	dmspDecodedMessage->wBlockStatus = wapBuffer[mtCommandStackEntry_OFFSET_OF_BLOCK_STATUS_WORD];
	dmspDecodedMessage->wTimeTag = wapBuffer[mtCommandStackEntry_OFFSET_OF_TIME_TAG];

	switch (dmspDecodedMessage->wType)
	{
	/// If the type of given message is BC-to-RT:
	///		If good data received or data error occurred:
	///			If the actual number of data words isn't zero:
	///				Set status-1 of the decoded message to the last available data word.
	///			Set data-word-count of the decoded message to the minimum number of data words.
	///			Copy the rest of the data words to the decoded message.
	case sitalMessageType_BC_TO_RT:
		// For such a message the data stack contains: data, status.
		if ( (sitalMtBlockStatusWord_GOOD_DATA == (sitalMtBlockStatusWord_GOOD_DATA & dmspDecodedMessage->wBlockStatus)) || (TRUE == bIsErrorInData) )
		{
			if (((U16BIT)0U < wActualDataWordCount) && ((U16BIT)0U == ((U16BIT)sitalMtBlockStatusWord_NO_RESPONSE & dmspDecodedMessage->wBlockStatus)))
			{
				dmspDecodedMessage->wStatus1 = (*(wpDataStackSection + wMinimalWordCount));
				dmspDecodedMessage->bIsStatus1Relevant = TRUE;
				wActualDataWordCount--;
			}

			dmspDecodedMessage->wDataWordCount = wMinimalWordCount;
			void* vp; // A pointer to a void.
			vp = memcpy (((void*)(dmspDecodedMessage->waData)), ((void*)wpDataStackSection), (size_t)(wMinimalWordCount << 1U));
		}
		break;

	/// If the type of given message is RT-to-BC:
	///		If the actual number of data words isn't zero and a response has been identified with given message:
	///			Set status-1 of the decoded message to the first available data word.
	///			If good data received or data error occurred:
	///			If the actual number of data words isn't zero:
	///				Set data-word-count of the decoded message to the minimum number of data words.
	///				Copy the rest of the data words to the decoded message.
	case sitalMessageType_RT_TO_BC:
		// For such a message the data stack contains: status, data.
		if ( ((U16BIT)0U < wActualDataWordCount) && ((U16BIT)0U == ((U16BIT)sitalMtBlockStatusWord_NO_RESPONSE & dmspDecodedMessage->wBlockStatus)) )
		{
			dmspDecodedMessage->wStatus1 = (*wpDataStackSection);
			dmspDecodedMessage->bIsStatus1Relevant = TRUE;
			wActualDataWordCount--;

			if ( (sitalMtBlockStatusWord_GOOD_DATA == (sitalMtBlockStatusWord_GOOD_DATA & dmspDecodedMessage->wBlockStatus)) || (TRUE == bIsErrorInData) )
			{
				dmspDecodedMessage->wDataWordCount = wMinimalWordCount;
				void* vp; // A pointer to a void.
				vp = memcpy (((void*)(dmspDecodedMessage->waData)), ((void*)(wpDataStackSection + (U16BIT)1U)), (size_t)(wMinimalWordCount << 1U));
			}
		}
		break;

	/// If the type of given message is RT-to-RT:
	///		If the actual number of data words isn't zero and a RT-to-RT command error wasn't identified:
	///			Set command-2 of the decoded message to the first available data word.
	///			If there are any more data words:
	///				If good data received or data error occurred:
	///					If a response has been identified with given message:
	///						Set status-2 of the decoded message to the last available data word.
	///					If there are any more data words:
	///						Set status-1 of the decoded message to the second available data word.
	///					Set data-word-count of the decoded message to the minimum number of data words.
	///					Copy the rest of the data words to the decoded message.
	///				Else:
	///					If a response has been identified with given message:
	///						Set status-1 of the decoded message to the second available data word.
	case sitalMessageType_RT_TO_RT:
		// For such a message the command stack contains the Rx command, which is the first of the two command that together compose these messages.
		// For such a message the data stack contains: Tx command, Tx status, data, Rx status.
		// See a note about the way RT-to-RT messages are treated above in the documentation of this function.
		if ( ((U16BIT)0U < wActualDataWordCount) && ((U16BIT)0U == ((U16BIT)sitalRtBlockStatusWord_RT_TO_RT_COMMAND_ERROR & dmspDecodedMessage->wBlockStatus)) )
		{
			dmspDecodedMessage->wCommandWord2 = (*wpDataStackSection);
			dmspDecodedMessage->bIsCommandWord2Relevant = TRUE;
			wActualDataWordCount--;

			if (0U < wActualDataWordCount)
			{
				if (sitalMtBlockStatusWord_GOOD_DATA == (sitalMtBlockStatusWord_GOOD_DATA & dmspDecodedMessage->wBlockStatus))
				{
					if ((U16BIT)0U == ((U16BIT)sitalMtBlockStatusWord_NO_RESPONSE & dmspDecodedMessage->wBlockStatus))
					{
						dmspDecodedMessage->wStatus2 = (*(wpDataStackSection + wMinimalWordCount - 1U));
						dmspDecodedMessage->bIsStatus2Relevant = TRUE;
						wActualDataWordCount--;
					}

					if (0U < wActualDataWordCount)
					{
						dmspDecodedMessage->wStatus1 = (*(wpDataStackSection + 1U));
						dmspDecodedMessage->bIsStatus1Relevant = TRUE;
						wActualDataWordCount--;
					}

					dmspDecodedMessage->wDataWordCount = wMinimalWordCount;
					void* vp; // A pointer to a void.
					vp = memcpy (((void*)(dmspDecodedMessage->waData)), ((void*)(wpDataStackSection + (U16BIT)2U)), (size_t)(wMinimalWordCount << 1U));
				}
				else
				if ((U16BIT)0U == ((U16BIT)sitalMtBlockStatusWord_NO_RESPONSE & dmspDecodedMessage->wBlockStatus))
				{
					dmspDecodedMessage->wStatus1 = (*(wpDataStackSection + 1U));
					dmspDecodedMessage->bIsStatus1Relevant = TRUE;
					wActualDataWordCount--;
				}
			}
		}
		break;

	/// If the type of given message is mode-no-data:
	///		If the actual number of data words isn't zero and a response has been identified with given message:
	///			Set status-1 of the decoded message to the first available data word.
	case sitalMessageType_MODE_NO_DATA:
		// For such a message the data stack contains: status.
		if (((U16BIT)0U < wActualDataWordCount) && ((U16BIT)0U == ((U16BIT)sitalMtBlockStatusWord_NO_RESPONSE & dmspDecodedMessage->wBlockStatus)) )
		{
			dmspDecodedMessage->wStatus1 = (*wpDataStackSection);
			dmspDecodedMessage->bIsStatus1Relevant = TRUE;
			wActualDataWordCount--;
		}
		break;

	/// If the type of given message is mode-data-Rx:
	///		If the actual number of data words isn't zero and good data received:
	///			If a response has been identified with given message:
	///				Set status-1 of the decoded message to the second available data word.
	///			If there are any more data words:
	///				Set data-word-count of the decoded message to 1.
	///				Copy a single data word to the decoded message.
	case sitalMessageType_MODE_DATA_RX:
		// For such a message the data stack contains: data (1 word), status.
		if ( (0U < wActualDataWordCount) && (sitalMtBlockStatusWord_GOOD_DATA == (sitalMtBlockStatusWord_GOOD_DATA & dmspDecodedMessage->wBlockStatus)) )
		{
			if ((U16BIT)0U == ((U16BIT)sitalMtBlockStatusWord_NO_RESPONSE & dmspDecodedMessage->wBlockStatus))
			{
				dmspDecodedMessage->wStatus1 = (*(wpDataStackSection + 1U));
				dmspDecodedMessage->bIsStatus1Relevant = TRUE;
				wActualDataWordCount--;
			}

			if (0U < wActualDataWordCount)
			{
				dmspDecodedMessage->wDataWordCount = 1U;
				dmspDecodedMessage->waData[0] = (*wpDataStackSection);
			}
		}
		break;

	/// If the type of given message is mode-data-Tx:
	///		If the actual number of data words isn't zero and a response has been identified with given message:
	///			Set status-1 of the decoded message to the first available data word.
	///			If there are any more data words and good data received:
	///				Set data-word-count of the decoded message to 1.
	///				Copy a single data word to the decoded message.
	case sitalMessageType_MODE_DATA_TX:
		// For such a message the data stack contains: status, data (1 word).
		if (((U16BIT)0U < wActualDataWordCount) && ((U16BIT)0U == ((U16BIT)sitalMtBlockStatusWord_NO_RESPONSE & dmspDecodedMessage->wBlockStatus)) )
		{
			dmspDecodedMessage->wStatus1 = (*wpDataStackSection);
			dmspDecodedMessage->bIsStatus1Relevant = TRUE;
			wActualDataWordCount--;

			if ( (0U < wActualDataWordCount) && (sitalMtBlockStatusWord_GOOD_DATA == (sitalMtBlockStatusWord_GOOD_DATA & dmspDecodedMessage->wBlockStatus)) )
			{
				dmspDecodedMessage->wDataWordCount = 1U;
				dmspDecodedMessage->waData[0] = (*(wpDataStackSection + 1U));
			}
		}
		break;

	/// If the type of given message is BC-broadcast:
	///		If good data received or data error occurred:
	///			Set data-word-count of the decoded message to the minimum number of data words.
	///			Copy all the data words to the decoded message.
	case sitalMessageType_BROADCAST:
		// For such a message the data stack contains: data.
		if ( (sitalMtBlockStatusWord_GOOD_DATA == (sitalMtBlockStatusWord_GOOD_DATA & dmspDecodedMessage->wBlockStatus)) || (TRUE == bIsErrorInData) )
		{
			dmspDecodedMessage->wDataWordCount = wMinimalWordCount;
			void* vp; // A pointer to a void.
			vp = memcpy (((void*)(dmspDecodedMessage->waData)), ((void*)wpDataStackSection), (size_t)(wMinimalWordCount << 1U));
		}
		break;

	/// If the type of given message is RT-broadcast:
	///		If the actual number of data words isn't zero and a RT-to-RT command error wasn't identified:
	///			Set command-2 of the decoded message to the first available data word.
	///			If there are any more data words and good data received:
	///				Set status-1 of the decoded message to the second available data word.
	///					Set data-word-count of the decoded message to the minimum number of data words.
	///					Copy the rest of the data words to the decoded message.
	case sitalMessageType_BROADCAST_RT_TO_RT:
		// For such a message the command stack contains the Rx command, which is the first of the two command that together compose these messages.
		// For such a message the data stack contains: Tx command, Tx status, data.
		if ( ((U16BIT)0U < wActualDataWordCount) && ((U16BIT)0U == ((U16BIT)sitalRtBlockStatusWord_RT_TO_RT_COMMAND_ERROR & dmspDecodedMessage->wBlockStatus)) )
		{
			dmspDecodedMessage->wCommandWord2 = (*wpDataStackSection);
			dmspDecodedMessage->bIsCommandWord2Relevant = TRUE;
			wActualDataWordCount--;

			if ( (0U < wActualDataWordCount) && (sitalMtBlockStatusWord_GOOD_DATA == (sitalMtBlockStatusWord_GOOD_DATA & dmspDecodedMessage->wBlockStatus)) )
			{
				dmspDecodedMessage->wStatus1 = (*(wpDataStackSection + 1U));
				dmspDecodedMessage->bIsStatus1Relevant = TRUE;
				wActualDataWordCount--;

				dmspDecodedMessage->wDataWordCount = wMinimalWordCount;
				void* vp; // A pointer to a void.
				vp = memcpy (((void*)(dmspDecodedMessage->waData)), ((void*)(wpDataStackSection + 2U)), (size_t)(wMinimalWordCount << 1U));
			}
		}
		break;

	/// If the type of given message is broadcast-mode-data:
	///		If the actual number of data words isn't zero and good data received:
	///			Set data-word-count of the decoded message to 1.
	///			Copy a single data word to the decoded message.
	case sitalMessageType_BROADCAST_MODE_DATA:
		// For such a message the data stack contains: data (1 word).
		if ( (0U < wActualDataWordCount) && (sitalMtBlockStatusWord_GOOD_DATA == (sitalMtBlockStatusWord_GOOD_DATA & dmspDecodedMessage->wBlockStatus)) )
		{
			dmspDecodedMessage->wDataWordCount = 1U;
			// NB Bug fix 26.11.2014 - In case of BCST with data it is Rx ,message thus the relevant data is as offset 0 and not offset 1.
			//dmspDecodedMessage->waData[0] = (*(wpDataStackSection + 1U));
			dmspDecodedMessage->waData[0] = (*(wpDataStackSection));
		}
		break;

	case sitalMessageType_BROADCAST_MODE_NO_DATA:
		break;

	default:
		break;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Decode given message of given HOO9 MT device into given structure.
///
/// Note:
/// - This function does not really require the logical number of the relevant device, which isn't removed only in order to stay compatible with DDC.
///   (See the documentation for the corresponding 1553 function, sitalMt_Message_DecodeRaw, which is DDC compatible.)
/// - This function assumes that given buffer is at least sitalMtMaximum_MESSAGE_SIZE words long.
/// - This function assumes that given buffer has been previously filled by function sitalHoo9_Mt_Message_GetFromStackRaw.
///   See the documentation for this function for information on the contents of its returned buffer.
/// - The status-related fields of the sitalDecodedMessageStructure are filled with dummy values, as no statuses are returned in the HOO9 protocol.
///
/// @param swDevice (in)	Logical number of device (0-31, unused)
/// @param wapBuffer (in)	A pointer to a buffer in which a raw message is stored
/// @param dmspDecodedMessage (out)	A pointer to a structure into which a message is decoded
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalHoo9_Mt_Message_DecodeRaw (S16BIT swDevice, U16BIT* wapBuffer, sitalDecodedMessageStructure* dmspDecodedMessage)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.

	/// Convert the command word of the currently pointed raw message from HOO9 into 1553.
	// That's in preparation for calling function sitalMt_Message_DecodeRaw, which expects a command word in the 1553 format.
	U16BIT* wpCommand; // A pointer to the command word of the currently handled raw message.
	wpCommand = (wapBuffer + mtCommandStackEntry_OFFSET_OF_COMMAND);
	CONVERT_HOO9_COMMAND_WORD_TO_1553_COMMAND_WORD(*wpCommand);

	/// Use the 1553 MT raw message reader function.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalMt_Message_DecodeRaw (swDevice, wapBuffer, dmspDecodedMessage);

	/// Convert back the command word of the currently pointed raw message from 1553 into HOO9.
	CONVERT_1553_COMMAND_WORD_TO_HOO9_COMMAND_WORD(*wpCommand);

	/// Convert back the command word of the currently pointed raw message from 1553 into HOO9.
	if (dmspDecodedMessage->bIsCommandWord1Relevant)
	{
		CONVERT_1553_COMMAND_WORD_TO_HOO9_COMMAND_WORD(dmspDecodedMessage->wCommandWord1); // Condition is always true with HOO9, and was added just for sanity.
	}

	if (dmspDecodedMessage->bIsCommandWord2Relevant)
	{
		CONVERT_1553_COMMAND_WORD_TO_HOO9_COMMAND_WORD(dmspDecodedMessage->wCommandWord2); // Condition is never true with HOO9, and was added just for sanity.
	}

	return swResult;
}


/// <summary>
/// Decode given message of given PP194 MT device into given structure.
///
/// Note:
/// - This function does not really require the logical number of the relevant device, which isn't removed only in order to stay compatible with DDC.
///   (See the documentation for the corresponding 1553 function, sitalMt_Message_DecodeRaw, which is DDC compatible.)
/// - This function assumes that given buffer is at least sitalMtMaximum_MESSAGE_SIZE words long.
/// - This function assumes that given buffer has been previously filled by function sitalPp194_Mt_Message_GetFromStackRaw.
///   See the documentation for this function for information on the contents of its returned buffer.
/// - The status-related fields of the sitalDecodedMessageStructure are filled with dummy values, as no statuses are returned in the PP194 protocol.
///
/// @param swDevice (in)	Logical number of device (0-31, unused)
/// @param wapBuffer (in)	A pointer to a buffer in which a raw message is stored
/// @param dmspDecodedMessage (out)	A pointer to a structure into which a message is decoded
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalPp194_Mt_Message_DecodeRaw (S16BIT swDevice, U16BIT* wapBuffer, sitalDecodedMessageStructure* dmspDecodedMessage)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.

	/// Use the 1553 MT raw message decoder function.
	return sitalMt_Message_DecodeRaw (swDevice, wapBuffer, dmspDecodedMessage);
}


/// <summary>
/// Read from given stack of given MT device into given buffer as many currently available raw messages as possible (that is, as the size of given buffer permits).
/// Remove from the stack the messages that were read.
///
/// Note:
/// - Given buffer is first zeroed, and then filled with available messages, where each message is stored as follows:
///   - A number of sitalMtMaximum_MESSAGE_SIZE memory words is dedicated per message, never mind its actual size.
///   - The target MT stack entry is copied into given buffer.
///   - The data stack pointer is replaced with a word whose:
///     - LSByte contains the type of the message that was read (sitalMessageType_*).
///     - The MSbit (bit #7) of the MSByte is set in case an error has been discovered with the data words.
///     - The rest of the bits (bits #0-6) of the MSByte contain the count of data words of given message.
///   - The data words are stored right after the stack entry, that is, starting at offset sitalMtMemoryObjectSize_COMMAND_STACK_ENTRY.
///     In case of a mode code message with data, this data word is returned as the first (actually the single) data word.
/// - In case a host buffer is assigned to a device, then right after any new message is recorded in this host buffer, that message is purged from the stack.
///   In other words, the usage of a host buffer and the usage of sital*_Message_Get* functions is basically mutually exclussive.
///
/// Equivalent DDC definition: aceMTGetStkMsgsRaw
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wapBuffer (out)	A pointer to a buffer in which the raw messages are stored
/// @param wBufferSize (in)	The size (in words) of the data buffer that is pointed by wapBuffer (>=sitalMtMaximum_MESSAGE_SIZE)
/// @param wStackSelector (in)	A selector that specifies the stack to read from (sitalMtStack_*)
/// @return Non-negative integer	The number of messages that were read
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalMt_Message_GetFromStackRaw (	S16BIT swDevice,
												U16BIT* wapBuffer,
												U16BIT wBufferSize,
												U16BIT wStackSelector)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalMode_MT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (((U16BIT*)NULL) == wapBuffer)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if ((0U > wBufferSize) || (sitalMtMaximum_MESSAGE_SIZE > wBufferSize))
	{
		return sitalReturnCode_INVALID_BUFFER;
	}

	if ((0U > wStackSelector) || (mtStack_BORDER <= wStackSelector))
	{
		return sitalReturnCode_MT_INVALID_STACK_SELECTOR;
	}

	/// Use given stack selection to determine the target stack and set suitable indicators.
	U16BIT wTargetStack; // The target stack.
	U32BIT dwTargetStackPointer; // The device memory address of the stack pointer of the target stack.
	dwTargetStackPointer = 0U;
	MtStackStateStructure* mssspTargetStackState; // A pointer to the state structure of the target stack.
	mssspTargetStackState = ((MtStackStateStructure*)NULL);
	S16BIT swResult; // Result of operation or function call.
	switch (wStackSelector)
	{
	case sitalMtStack_STACK_A:
		wTargetStack = sitalMtStackSelector_STACK_A;
		dwTargetStackPointer = mtAddressMap_MT_COMMAND_STACK_A_POINTER;
		mssspTargetStackState = (MtStackStateStructure*)&(dsspDeviceState->rms.msMtState.msssStackStateA);
		break;

	case sitalMtStack_STACK_B:
		wTargetStack = sitalMtStackSelector_STACK_B;
		dwTargetStackPointer = mtAddressMap_MT_COMMAND_STACK_B_POINTER;
		mssspTargetStackState = (MtStackStateStructure*)&(dsspDeviceState->rms.msMtState.msssStackStateB);
		break;

	case sitalMtStack_ACTIVE:
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, sitalRegisterAddress_CONFIGURATION_1, sitalDeviceMemorySection_Registers, 1U, &wTargetStack);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
		wTargetStack &= sitalConfigurationRegister1_MT_ACTIVE_STACK;
		if (sitalMtStackSelector_STACK_A == wTargetStack)
		{
			dwTargetStackPointer = mtAddressMap_MT_COMMAND_STACK_A_POINTER;
			mssspTargetStackState = (MtStackStateStructure*)&(dsspDeviceState->rms.msMtState.msssStackStateA);
		}
		else
		{
			dwTargetStackPointer = mtAddressMap_MT_COMMAND_STACK_B_POINTER;
			mssspTargetStackState = (MtStackStateStructure*)&(dsspDeviceState->rms.msMtState.msssStackStateB);
		}
		break;

	case sitalMtStack_INACTIVE:
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, sitalRegisterAddress_CONFIGURATION_1, sitalDeviceMemorySection_Registers, 1U, &wTargetStack);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
		wTargetStack = ((~wTargetStack) & sitalConfigurationRegister1_MT_ACTIVE_STACK);
		if (sitalMtStackSelector_STACK_A == wTargetStack)
		{
			dwTargetStackPointer = mtAddressMap_MT_COMMAND_STACK_A_POINTER;
			mssspTargetStackState = (MtStackStateStructure*)&(dsspDeviceState->rms.msMtState.msssStackStateA);
		}
		else
		{
			dwTargetStackPointer = mtAddressMap_MT_COMMAND_STACK_B_POINTER;
			mssspTargetStackState = (MtStackStateStructure*)&(dsspDeviceState->rms.msMtState.msssStackStateB);
		}
		break;

	default:
		// Irrelevant: All possible cases were already handled.
		break;
	}

	/// Read the target command stack pointer.
	U16BIT wAddressOfMessageToWrite; // The current value of the stack pointer.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, dwTargetStackPointer, sitalDeviceMemorySection_Ram, 1U, &wAddressOfMessageToWrite);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Update the target command stack pointer.
	// Note: In order to save CPU time, no ISR is set with MT devices while no host buffer is installed, so in such case the current stack pointer and stack statistics are updated only when the user calls functions sitalMt_Message_GetFromStackRaw and sitalMt_Message_GetFromStackDecoded.
	mssspTargetStackState->dwAddressOfMessageToWrite = wAddressOfMessageToWrite;

	///	If configured to collect operational statistics for given device:
	///		Update stack fullness statistics for given device.
	if (TRUE == dsspDeviceState->bIsOperationalStatisticsCollected)
	{
		mssspTargetStackState->wFullnessPercentage = (U16BIT)( (double)100.0 * (((mssspTargetStackState->dwAddressOfMessageToRead > mssspTargetStackState->dwAddressOfMessageToWrite) ? mssspTargetStackState->wCommandStackSize : 0U) + mssspTargetStackState->dwAddressOfMessageToWrite - mssspTargetStackState->dwAddressOfMessageToRead) / mssspTargetStackState->wCommandStackSize );
		mssspTargetStackState->wMaximumFullnessPercentage = ( (mssspTargetStackState->wMaximumFullnessPercentage < mssspTargetStackState->wFullnessPercentage) ? mssspTargetStackState->wFullnessPercentage : mssspTargetStackState->wMaximumFullnessPercentage );
	}

	///	If configured to collect operational statistics for given device:
	///		Update stack fullness statistics for given device.
	if (TRUE == dsspDeviceState->bIsOperationalStatisticsCollected)
	{
		mssspTargetStackState->wFullnessPercentage = (U16BIT)( (double)100.0 * (((mssspTargetStackState->dwAddressOfMessageToRead > mssspTargetStackState->dwAddressOfMessageToWrite) ? mssspTargetStackState->wCommandStackSize : 0U) + mssspTargetStackState->dwAddressOfMessageToWrite - mssspTargetStackState->dwAddressOfMessageToRead) / mssspTargetStackState->wCommandStackSize );
		mssspTargetStackState->wMaximumFullnessPercentage = ( (mssspTargetStackState->wMaximumFullnessPercentage < mssspTargetStackState->wFullnessPercentage) ? mssspTargetStackState->wFullnessPercentage : mssspTargetStackState->wMaximumFullnessPercentage );
	}

	/// While there are more unread messages in the stack and there's still place for another message in given buffer and reading succeeds:
	///		Point to the place in given buffer where the next message should be stored.
	///		Decrement the size of the buffer to reflect the remaining size.
	///		Increment the count of raw messages that have been copied.
	U16BIT wReadMessagesCount = 0U; // The number of messages that were read.
	wReadMessagesCount = 0U;
	swResult = 1;
	while	(
				(mssspTargetStackState->dwAddressOfMessageToRead != wAddressOfMessageToWrite)
				&&
				(sitalMtMaximum_MESSAGE_SIZE <= wBufferSize)
				&&
				(1 == swResult)
			)
	{
		swResult = mt_Message_GetFromStackRaw (swDevice, mssspTargetStackState, wapBuffer, ((U16BIT*)NULL), (BOOLEAN)TRUE, (BOOLEAN)TRUE);
		if (1 == swResult)
		{
			wapBuffer += sitalMtMaximum_MESSAGE_SIZE;
			wBufferSize -= sitalMtMaximum_MESSAGE_SIZE;
			wReadMessagesCount++;
		}
	}

	if ((S16BIT)0U > swResult)
	{
		return swResult;
	}

	return (S16BIT)wReadMessagesCount;
}


/// <summary>
/// Read from given stack of given HOO9 MT device into given buffer as many currently available raw messages as possible (that is, as the size of given buffer permits).
/// Remove from the stack the messages that were read.
///
/// Note:
/// - Given buffer is first zeroed, and then filled with available messages, where each message is stored as follows:
///   - A number of sitalMtMaximum_MESSAGE_SIZE memory words is dedicated per message, never mind its actual size.
///   - The target MT stack entry is copied into given buffer.
///   - The data stack pointer is replaced with a word whose:
///     - LSByte contains the type of the message that was read (sitalMessageType_*).
///     - The MSbit (bit #7) of the MSByte is set in case an error has been discovered with the data words.
///     - The rest of the bits (bits #0-6) of the MSByte contain the count of data words of given message.
///   - The data words are stored right after the stack entry, that is, starting at offset sitalMtMemoryObjectSize_COMMAND_STACK_ENTRY.
///     In case of a mode code message with data, this data word is returned as the first (actually the single) data word.
/// - In case a host buffer is assigned to a device, then right after any new message is recorded in this host buffer, that message is purged from the stack.
///   In other words, the usage of a host buffer and the usage of sital*_Message_Get* functions is basically mutually exclussive.
/// - The status-related fields of the sitalDecodedMessageStructure are filled with dummy values, as no statuses are returned in the HOO9 protocol.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wapBuffer (out)	A pointer to a buffer in which the raw messages are stored
/// @param wBufferSize (in)	The size (in words) of the data buffer that is pointed by wapBuffer (>=sitalMtMaximum_MESSAGE_SIZE)
/// @param wStackSelector (in)	A selector that specifies the stack to read from (sitalMtStack_*)
/// @return Non-negative integer	The number of messages that were read
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalHoo9_Mt_Message_GetFromStackRaw (	S16BIT swDevice,
													U16BIT* wapBuffer,
													U16BIT wBufferSize,
													U16BIT wStackSelector)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.

	/// Use the 1553 MT raw message reader function.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalMt_Message_GetFromStackRaw (swDevice, wapBuffer, wBufferSize, wStackSelector);
	if ((S16BIT)0U > swResult)
	{
		return swResult;
	}

	/// Loop over all the raw messages that were read:
	S16BIT swMessageCount; // The number of messages that were read.
	swMessageCount = swResult;
	U16BIT* wpCommand; // A pointer to the command word of the currently handled raw message.
	wpCommand = (wapBuffer + mtCommandStackEntry_OFFSET_OF_COMMAND);
	for (S16BIT i=0; i<swMessageCount; i++, wpCommand+=sitalMtMaximum_MESSAGE_SIZE)
	{
		///		Convert the command word of the current raw message from 1553 into HOO9.
		CONVERT_1553_COMMAND_WORD_TO_HOO9_COMMAND_WORD(*wpCommand);
	}

	return swResult;
}


/// <summary>
/// Read from given stack of given PP194 MT device into given buffer as many currently available raw messages as possible (that is, as the size of given buffer permits).
/// Remove from the stack the messages that were read.
///
/// Note:
/// - Given buffer is first zeroed, and then filled with available messages, where each message is stored as follows:
///   - A number of sitalMtMaximum_MESSAGE_SIZE memory words is dedicated per message, never mind its actual size.
///   - The target MT stack entry is copied into given buffer.
///   - The data stack pointer is replaced with a word whose:
///     - LSByte contains the type of the message that was read (sitalMessageType_*).
///     - The MSbit (bit #7) of the MSByte is set in case an error has been discovered with the data words.
///     - The rest of the bits (bits #0-6) of the MSByte contain the count of data words of given message.
///   - The data words are stored right after the stack entry, that is, starting at offset sitalMtMemoryObjectSize_COMMAND_STACK_ENTRY.
///     In case of a mode code message with data, this data word is returned as the first (actually the single) data word.
/// - In case a host buffer is assigned to a device, then right after any new message is recorded in this host buffer, that message is purged from the stack.
///   In other words, the usage of a host buffer and the usage of sital*_Message_Get* functions is basically mutually exclussive.
/// - The status-related fields of the sitalDecodedMessageStructure are filled with dummy values, as no statuses are returned in the PP194 protocol.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wapBuffer (out)	A pointer to a buffer in which the raw messages are stored
/// @param wBufferSize (in)	The size (in words) of the data buffer that is pointed by wapBuffer (>=sitalMtMaximum_MESSAGE_SIZE)
/// @param wStackSelector (in)	A selector that specifies the stack to read from (sitalMtStack_*)
/// @return Non-negative integer	The number of messages that were read
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalPp194_Mt_Message_GetFromStackRaw (	S16BIT swDevice,
														U16BIT* wapBuffer,
														U16BIT wBufferSize,
														U16BIT wStackSelector)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.

	/// Use the 1553 MT raw message reader function.
	return sitalMt_Message_GetFromStackRaw (swDevice, wapBuffer, wBufferSize, wStackSelector);
}


/// <summary>
/// Read from given stack of given MT device the message at given location, decode it into given structure, and purge it if so required.
///
/// Note:
/// - In case of a mode code message with data, this data word is returned as the first (actually the single) data word.
/// - In case a host buffer is assigned to a device, then right after any new message is recorded in this host buffer, that message is purged from the stack.
///   In other words, the usage of a host buffer and the usage of sital*_Message_Get* functions is basically mutually exclussive.
///
/// Equivalent DDC definition: aceMTGetStkMsgDecoded
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param dmspDecodedMessage (out)	A pointer to a structure into which a message is decoded
/// @param wMessageLocationAndRemoval (in)	The location in the stack or host buffer of the message to read, and removal instructions (sitalMessageLocationAndRemoval_*)
/// @param wStackSelector (in)	A selector that specifies the stack to read from (sitalMtStack_*)
/// @return One (1)	The [single] requested message was read and decoded
/// @return Zero (0)	No message available, though no error occurred
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalMt_Message_GetFromStackDecoded (	S16BIT swDevice,
													sitalDecodedMessageStructure* dmspDecodedMessage,
													U16BIT wMessageLocationAndRemoval,
													U16BIT wStackSelector)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalMode_MT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (((sitalDecodedMessageStructure*)NULL) == dmspDecodedMessage)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if ((0U > wMessageLocationAndRemoval) || (messageLocationAndRemoval_BORDER <= wMessageLocationAndRemoval))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if ((0U > wStackSelector) || (mtStack_BORDER <= wStackSelector))
	{
		return sitalReturnCode_MT_INVALID_STACK_SELECTOR;
	}

	// Use given stack selection to determine the target stack and set suitable indicators.
	U16BIT wTargetStack; // The target stack.
	U32BIT dwTargetStackPointer; // The device memory address of the stack pointer of the target stack.
	dwTargetStackPointer = 0U; // An assignment that prevents a casual compilation warning.
	MtStackStateStructure* mssspTargetStackState; // A pointer to the state structure of the target stack.
	mssspTargetStackState = ((MtStackStateStructure*)NULL); // An assignment that prevents a casual compilation warning.
	S16BIT swResult; // Result of operation or function call.
	switch (wStackSelector)
	{
	case sitalMtStack_STACK_A:
		wTargetStack = sitalMtStackSelector_STACK_A;
		dwTargetStackPointer = mtAddressMap_MT_COMMAND_STACK_A_POINTER;
		mssspTargetStackState = (MtStackStateStructure*)&(dsspDeviceState->rms.msMtState.msssStackStateA);
		break;

	case sitalMtStack_STACK_B:
		wTargetStack = sitalMtStackSelector_STACK_B;
		dwTargetStackPointer = mtAddressMap_MT_COMMAND_STACK_B_POINTER;
		mssspTargetStackState = (MtStackStateStructure*)&(dsspDeviceState->rms.msMtState.msssStackStateB);
		break;

	case sitalMtStack_ACTIVE:
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, sitalRegisterAddress_CONFIGURATION_1, sitalDeviceMemorySection_Registers, 1U, &wTargetStack);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
		wTargetStack &= sitalConfigurationRegister1_MT_ACTIVE_STACK;
		if (sitalMtStackSelector_STACK_A == wTargetStack)
		{
			dwTargetStackPointer = mtAddressMap_MT_COMMAND_STACK_A_POINTER;
			mssspTargetStackState = (MtStackStateStructure*)&(dsspDeviceState->rms.msMtState.msssStackStateA);
		}
		else
		{
			dwTargetStackPointer = mtAddressMap_MT_COMMAND_STACK_B_POINTER;
			mssspTargetStackState = (MtStackStateStructure*)&(dsspDeviceState->rms.msMtState.msssStackStateB);
		}
		break;

	case sitalMtStack_INACTIVE:
		swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, sitalRegisterAddress_CONFIGURATION_1, sitalDeviceMemorySection_Registers, 1U, &wTargetStack);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
		wTargetStack = ((~wTargetStack) & sitalConfigurationRegister1_MT_ACTIVE_STACK);
		if (sitalMtStackSelector_STACK_A == wTargetStack)
		{
			dwTargetStackPointer = mtAddressMap_MT_COMMAND_STACK_A_POINTER;
			mssspTargetStackState = (MtStackStateStructure*)&(dsspDeviceState->rms.msMtState.msssStackStateA);
		}
		else
		{
			dwTargetStackPointer = mtAddressMap_MT_COMMAND_STACK_B_POINTER;
			mssspTargetStackState = (MtStackStateStructure*)&(dsspDeviceState->rms.msMtState.msssStackStateB);
		}
		break;

	default:
		// Irrelevant: All possible cases were already handled.
		break;
	}

	/// Read the target command stack pointer.
	U16BIT wAddressOfMessageToWrite; // The current value of the stack pointer.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, dwTargetStackPointer, sitalDeviceMemorySection_Ram, 1U, &wAddressOfMessageToWrite);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Update the target command stack pointer.
	// Note: In order to save CPU time, no ISR is set with MT devices while no host buffer is installed, so in such case the current stack pointer and stack statistics are updated only when the user calls functions sitalMt_Message_GetFromStackRaw and sitalMt_Message_GetFromStackDecoded.
	mssspTargetStackState->dwAddressOfMessageToWrite = wAddressOfMessageToWrite;

	///	If configured to collect operational statistics for given device:
	///		Update stack fullness statistics for given device.
	if (TRUE == dsspDeviceState->bIsOperationalStatisticsCollected)
	{
		mssspTargetStackState->wFullnessPercentage = (U16BIT)( (double)100.0 * (((mssspTargetStackState->dwAddressOfMessageToRead > mssspTargetStackState->dwAddressOfMessageToWrite) ? mssspTargetStackState->wCommandStackSize : 0U) + mssspTargetStackState->dwAddressOfMessageToWrite - mssspTargetStackState->dwAddressOfMessageToRead) / mssspTargetStackState->wCommandStackSize );
		mssspTargetStackState->wMaximumFullnessPercentage = ( (mssspTargetStackState->wMaximumFullnessPercentage < mssspTargetStackState->wFullnessPercentage) ? mssspTargetStackState->wFullnessPercentage : mssspTargetStackState->wMaximumFullnessPercentage );
	}

	/// Interpret given message location directive.
	BOOLEAN bIsNextMessageRequired; // A flag that says whether to read the stack record of the next message (or, otherwise, of the last message).
	bIsNextMessageRequired = (BOOLEAN)((U16BIT)sitalMessageLocation_NEXT == ((U16BIT)messageLocationAndRemoval_LOCATION & wMessageLocationAndRemoval));

	/// Interpret given message removal directive.
	BOOLEAN bIsMessagePurgeRequired; // A flag that says whether to delete the record of the message that's read.
	bIsMessagePurgeRequired = (BOOLEAN)((U16BIT)sitalMessageRemoval_PURGE == ((U16BIT)messageLocationAndRemoval_REMOVAL & wMessageLocationAndRemoval));

	/// Get the requested stack message in its raw state.
	U16BIT waBuffer[sitalMtMaximum_MESSAGE_SIZE]; // A temporary buffer to store within a message in its raw state.
	swResult = mt_Message_GetFromStackRaw (swDevice, mssspTargetStackState, waBuffer, ((U16BIT*)NULL), bIsNextMessageRequired, bIsMessagePurgeRequired);
	if (1 != swResult)
	{
		return swResult;
	}

	/// Decode the requested stack message from its raw state.
	swResult = sitalMt_Message_DecodeRaw (swDevice, waBuffer, dmspDecodedMessage);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	return 1;
}


/// <summary>
/// Read from given stack of given HOO9 MT device the message at given location, decode it into given structure, and purge it if so required.
///
/// Note:
/// - In case a host buffer is assigned to a device, then right after any new message is recorded in this host buffer, that message is purged from the stack.
///   In other words, the usage of a host buffer and the usage of sital*_Message_Get* functions is basically mutually exclussive.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param dmspDecodedMessage (out)	A pointer to a structure into which a message is decoded
/// @param wMessageLocationAndRemoval (in)	The location in the stack or host buffer of the message to read, and removal instructions (sitalMessageLocationAndRemoval_*)
/// @param wStackSelector (in)	A selector that specifies the stack to read from (sitalMtStack_*)
/// @return One (1)	The [single] requested message was read and decoded
/// @return Zero (0)	No message available, though no error occurred
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalHoo9_Mt_Message_GetFromStackDecoded (	S16BIT swDevice,
														sitalDecodedMessageStructure* dmspDecodedMessage,
														U16BIT wMessageLocationAndRemoval,
														U16BIT wStackSelector)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.

	/// Use the 1553 MT decoded message reader function.
	// Note that no preparation is needed before calling function sitalMt_Message_DecodeRaw, as the raw message contains a command word in the 1553 format, which is exactly what this function expects.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalMt_Message_GetFromStackDecoded (swDevice, dmspDecodedMessage, wMessageLocationAndRemoval, wStackSelector);

	/// Convert the command word of the currently pointed raw message from 1553 into HOO9.
	if (dmspDecodedMessage->bIsCommandWord1Relevant)
	{
		CONVERT_1553_COMMAND_WORD_TO_HOO9_COMMAND_WORD(dmspDecodedMessage->wCommandWord1); // Condition is always true with HOO9, and was added just for sanity.
	}
	if (dmspDecodedMessage->bIsCommandWord2Relevant)
	{
		CONVERT_1553_COMMAND_WORD_TO_HOO9_COMMAND_WORD(dmspDecodedMessage->wCommandWord2); // Condition is never true with HOO9, and was added just for sanity.
	}

	return swResult;
}


/// <summary>
/// Read from given stack of given PP194 MT device the message at given location, decode it into given structure, and purge it if so required.
///
/// Note:
/// - In case a host buffer is assigned to a device, then right after any new message is recorded in this host buffer, that message is purged from the stack.
///   In other words, the usage of a host buffer and the usage of sital*_Message_Get* functions is basically mutually exclussive.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param dmspDecodedMessage (out)	A pointer to a structure into which a message is decoded
/// @param wMessageLocationAndRemoval (in)	The location in the stack or host buffer of the message to read, and removal instructions (sitalMessageLocationAndRemoval_*)
/// @param wStackSelector (in)	A selector that specifies the stack to read from (sitalMtStack_*)
/// @return One (1)	The [single] requested message was read and decoded
/// @return Zero (0)	No message available, though no error occurred
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalPp194_Mt_Message_GetFromStackDecoded (	S16BIT swDevice,
															sitalDecodedMessageStructure* dmspDecodedMessage,
															U16BIT wMessageLocationAndRemoval,
															U16BIT wStackSelector)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.

	/// Use the 1553 MT decoded message reader function.
	return sitalMt_Message_GetFromStackDecoded (swDevice, dmspDecodedMessage, wMessageLocationAndRemoval, wStackSelector);
}


/// <summary>
/// Initialize (or re-initialize) given MT device's host buffer.
///
/// Note:
/// - Given size of host buffer must be large enough to contain sitalMtMinimum_COMMAND_STACKS_IN_HOST_BUFFER times the number of raw messages that the command stack of given MT device may contain.
///   The number of messages that may be contained by the command stack (N) is its configured size in words divided by sitalMtMemoryObjectSize_COMMAND_STACK_ENTRY.
///   As the maximum possible size of message is allocated for each message in the host buffer, the corresponding size (in words) is (N / sitalMtMaximum_MESSAGE_SIZE).
///   Therefore, given size must be not less than (sitalMtMinimum_COMMAND_STACKS_IN_HOST_BUFFER * (N / sitalMtMaximum_MESSAGE_SIZE)).
///
/// Equivalent DDC definition: aceMTInstallHBuf
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param dwHostBufferSize (in)	The desired size (in words) of the host buffer (<above-defined-minimum-size-of-RT-host-buffer>-sitalMaximum_SIZE_OF_HOST_BUFFER)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
S16BIT _DECL sitalMt_HostBuffer_Initialize (S16BIT swDevice, U32BIT dwHostBufferSize)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if ((sitalMode_MT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((((sitalMtMinimum_COMMAND_STACKS_IN_HOST_BUFFER * ((U32BIT)(dsspDeviceState->rms.msMtState.msssStackStateA.wCommandStackSize) / sitalMtMemoryObjectSize_COMMAND_STACK_ENTRY) * sitalMtMaximum_MESSAGE_SIZE)) > dwHostBufferSize) || (sitalMaximum_SIZE_OF_HOST_BUFFER < dwHostBufferSize))
	{
		return sitalReturnCode_INVALID_HOST_BUFFER_SIZE;
	}

	/// If given device's host buffer is currently in use:
	///		Reset given device's host buffer.
	HostBufferStructure* hbspHostBuffer; // A host buffer structure.
	hbspHostBuffer = &(dsspDeviceState->rms.msMtState.hbsHostBuffer);
	S16BIT swResult; // Result of operation or function call.
	if (0U != hbspHostBuffer->dwHostBufferSize)
	{
		swResult = sitalMt_HostBuffer_Free (swDevice);
	}

	///	Properly set given device's host buffer.
	hbspHostBuffer->dwHostBufferSize = ( dwHostBufferSize - (dwHostBufferSize % sitalMtMaximum_MESSAGE_SIZE) );
	hbspHostBuffer->dwLastMessageTimeTag = 0U;
	hbspHostBuffer->dwOffsetOfNextMessageToRead = 0U;
	hbspHostBuffer->dwOffsetOfNextMessageToWrite = 0U;
	hbspHostBuffer->dwMessageCount = 0U;
	hbspHostBuffer->dwLostMessageCount = 0U;
	hbspHostBuffer->wFullnessPercentage = 0U;
	hbspHostBuffer->wMaximumFullnessPercentage = 0U;

	/// In case of a real device:
	///		Set a suitable ISR for given device.
	///		Configure the user's interrupt mask pseudo register to issue those interrupts that are relevant while recording messages in a host buffer of a RT device.
	if (sitalAccess_CARD == dsspDeviceState->wAccess)
	{
		swResult = sitalProcess_SetInterruptServiceRoutine ( (ISR_FUNCTION)(((U16BIT)sitalMode_MT == dsspDeviceState->wMode) ? mt_HandleInterrupt : /* sitalMode_RT_AND_MT */ rtmt_HandleInterrupt) );

		dsspDeviceState->dwInternalImr |= (sitalInterruptRegister2_MT_COMMAND_STACK_HALF_ROLLOVER | sitalInterruptRegister2_MT_DATA_STACK_HALF_ROLLOVER | sitalInterruptRegister1_MT_COMMAND_STACK_ROLLOVER | sitalInterruptRegister1_MT_DATA_STACK_ROLLOVER | sitalInterruptRegister1_TIME_TAG_ROLLOVER);
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Free given MT device's host buffer.
///
/// Note:
/// - See the documentation of function sitalRtMt_HostBuffer_Initialize for more information on using functions sitalRt_HostBuffer_* or sitalMt_HostBuffer_* combined with functions sitalRtMt_HostBuffer_*.
///
/// Equivalent DDC definition: aceMTUninstallHBuf
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
S16BIT _DECL sitalMt_HostBuffer_Free (S16BIT swDevice)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if ((sitalMode_MT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (0U == dsspDeviceState->rms.msMtState.hbsHostBuffer.dwHostBufferSize)
	{
		return sitalReturnCode_INVALID_HOST_BUFFER_SIZE;
	}

	HostBufferStructure* hbspHostBuffer; // A host buffer structure.
	hbspHostBuffer = &(dsspDeviceState->rms.msMtState.hbsHostBuffer);
	if (0U == hbspHostBuffer->dwHostBufferSize)
	{
		return sitalReturnCode_HOST_BUFFER_NOT_INSTALLED;
	}

	///	Free given device's host buffer.
	hbspHostBuffer->dwHostBufferSize = 0U;
	hbspHostBuffer->dwLastMessageTimeTag = 0U;
	hbspHostBuffer->dwOffsetOfNextMessageToRead = 0U;
	hbspHostBuffer->dwOffsetOfNextMessageToWrite = 0U;
	hbspHostBuffer->dwMessageCount = 0U;
	hbspHostBuffer->dwLostMessageCount = 0U;
	hbspHostBuffer->wFullnessPercentage = 0U;
	hbspHostBuffer->wMaximumFullnessPercentage = 0U;

	/// In case of a real device:
	///		Set a suitable ISR for given device.
	///		Configure the user's interrupt mask pseudo register to avoid raising those host buffer filling interrupts which are not required anymore.
	// Note:
	// - With a RTMT device:
	//   - The RTMT ISR is set as long as at least one of the RT and MT host buffers is installed.
	//   - Interrupts that are relevant while recording messages in a host buffer of a RT device are passed to the user's ISR (if one is defined at all) as long as the RT host buffer is installed.
	//   - Interrupts that are relevant while recording messages in a host buffer of a MT device are passed to the user's ISR (if one is defined at all) as long as the MT host buffer is installed.
	S16BIT swResult; // Result of operation or function call.
	if (sitalAccess_CARD == dsspDeviceState->wAccess)
	{
		if (sitalMode_RT_AND_MT == dsspDeviceState->wMode)
		{
			if (0U == dsspDeviceState->rms.rsRtState.hbsHostBuffer.dwHostBufferSize)
			{
				swResult = sitalProcess_SetInterruptServiceRoutine ((ISR_FUNCTION)NULL);
				dsspDeviceState->dwInternalImr &= ( ~ (sitalInterruptRegister2_RT_COMMAND_STACK_HALF_ROLLOVER | sitalInterruptRegister2_MT_COMMAND_STACK_HALF_ROLLOVER | sitalInterruptRegister2_MT_DATA_STACK_HALF_ROLLOVER | sitalInterruptRegister1_BC_RT_COMMAND_STACK_ROLLOVER | sitalInterruptRegister1_MT_COMMAND_STACK_ROLLOVER | sitalInterruptRegister1_MT_DATA_STACK_ROLLOVER | sitalInterruptRegister1_TIME_TAG_ROLLOVER | sitalInterruptRegister1_END_OF_MESSAGE) );
			}
			else // RT host buffer still installed for given RT&MT device:
			{
				dsspDeviceState->dwInternalImr &= ( ~ (sitalInterruptRegister2_MT_COMMAND_STACK_HALF_ROLLOVER | sitalInterruptRegister2_MT_DATA_STACK_HALF_ROLLOVER | sitalInterruptRegister1_MT_COMMAND_STACK_ROLLOVER | sitalInterruptRegister1_MT_DATA_STACK_ROLLOVER) );
			}
		}
		else // sitalMode_MT
		{
			swResult = sitalProcess_SetInterruptServiceRoutine ((ISR_FUNCTION)NULL);
			dsspDeviceState->dwInternalImr &= ( ~ (sitalInterruptRegister2_MT_COMMAND_STACK_HALF_ROLLOVER | sitalInterruptRegister2_MT_DATA_STACK_HALF_ROLLOVER | sitalInterruptRegister1_MT_COMMAND_STACK_ROLLOVER | sitalInterruptRegister1_MT_DATA_STACK_ROLLOVER | sitalInterruptRegister1_TIME_TAG_ROLLOVER) );
		}
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Record the newly received messages from the active command and data stacks of given MT device into its host buffer.
///
/// Note:
/// - User applications should not principally use this function, as it is automatically called by this library whenever a relevant interrupt occurs.
///   This function has been originally exported only in order to enable working with operating systems that does not support interrupts.
/// - Messages are recorded in the host buffer only as long that it isn't full, that is, there's no override of old messages by new ones.
///   The user must repeatedly get messages from the host buffer in order to empty it.
///
/// Equivalent DDC definition: aceMTStkToHBuf
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalMt_HostBuffer_Message_Record (S16BIT swDevice)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalMode_MT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	HostBufferStructure* hbspHostBuffer; // A host buffer structure.
	hbspHostBuffer = (HostBufferStructure*)&(dsspDeviceState->rms.msMtState.hbsHostBuffer);
	if (0U == hbspHostBuffer->dwHostBufferSize)
	{
		return sitalReturnCode_MT_HOST_BUFFER_NOT_INSTALLED;
	}

	/// If given MT device has been configured as having double stack:
	///		Swap between its active and inactive stacks.
	///		If the stack that became active is stack A:
	///			Make the originally active stack, which is stack B, the target stack, and set suitable indicators.
	///		Else:
	///			Make the originally active stack, which is stack A, the target stack, and set suitable indicators.
	/// Else:
	///		Make the active stack, which is stack A, the target stack, and set suitable indicators.
	U16BIT wTargetStack; // The target stack.
	MtStackStateStructure* mssspTargetStackState; // A pointer to the state structure of the target stack.
	U32BIT dwTargetStackPointer; // The device memory address of the stack pointer of the target stack.
	S16BIT swResult; // Result of operation or function call.
	if (sitalMtStackOption_DOUBLE == dsspDeviceState->rms.msMtState.wStackMode)
	{
		swResult = sitalMt_Stack_Swap (swDevice);
		if ((S16BIT)0U > swResult)
		{
			return swResult;
		}

		wTargetStack = (U16BIT)swResult;
		if (sitalMtStack_STACK_A == wTargetStack)
		{
			mssspTargetStackState = (MtStackStateStructure*)&(dsspDeviceState->rms.msMtState.msssStackStateB);
			dwTargetStackPointer = mtAddressMap_MT_COMMAND_STACK_B_POINTER;
		}
		else
		{
			mssspTargetStackState = (MtStackStateStructure*)&(dsspDeviceState->rms.msMtState.msssStackStateA);
			dwTargetStackPointer = mtAddressMap_MT_COMMAND_STACK_A_POINTER;
		}

		mssspTargetStackState->dwAddressOfMessageToRead = mssspTargetStackState->dwCommandStackInitialAddress;
	}
	else
	{
		mssspTargetStackState = (MtStackStateStructure*)&(dsspDeviceState->rms.msMtState.msssStackStateA);
		dwTargetStackPointer = mtAddressMap_MT_COMMAND_STACK_A_POINTER;
	}

	/// Update the target command stack pointer.
	U16BIT wIoContents; // The variable into which the contents of a device word is read, or the variable whose contents are written to device.
	wIoContents = (U16BIT)mssspTargetStackState->dwAddressOfMessageToWrite;
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, dwTargetStackPointer, sitalDeviceMemorySection_Ram, 1U, &wIoContents);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	///	If configured to collect operational statistics for given device:
	///		Update stack fullness statistics for given device.
	if (TRUE == dsspDeviceState->bIsOperationalStatisticsCollected)
	{
		mssspTargetStackState->wFullnessPercentage = (U16BIT)( (double)100.0 * (((mssspTargetStackState->dwAddressOfMessageToRead > mssspTargetStackState->dwAddressOfMessageToWrite) ? mssspTargetStackState->wCommandStackSize : 0U) + mssspTargetStackState->dwAddressOfMessageToWrite - mssspTargetStackState->dwAddressOfMessageToRead) / mssspTargetStackState->wCommandStackSize );
		mssspTargetStackState->wMaximumFullnessPercentage = ( (mssspTargetStackState->wMaximumFullnessPercentage < mssspTargetStackState->wFullnessPercentage) ? mssspTargetStackState->wFullnessPercentage : mssspTargetStackState->wMaximumFullnessPercentage );
	}

	/// If the data block pointer of the previously read command stack message isn't anymore reset to zero:
	///		Count all stack message entries from the next to read until then currently written into (including) as lost messages.
	///		Promote the address of the next stack entry to read to the entry that cyclically follows the one currently written into.
	// Note:
	// - The MT device does not save invalid messages in its stack, so the data block pointer, which is the second word in each stack message entry, may not be zero, as zero is an invalid value for the data block pointer (this library allocates the MT management tables in the beginning of the MT memory, so address zero will never be used for message data blocks).
	// - The data block pointer is set zero only when purged by this library. Therefore, if the data block pointer of the previously read message isn't zero anymore, it says that the device refilled this stack message entry after its last purge.
	// - If the previously read message entry has been refilled by the device, then the device also refilled all the stack message entries from the next one to read to the currently written one (included). All these messages are considered lost.
	// - This library should in this case quickly move to the stack entry next to the one that's currently written into, and cyclically read all the messages from this entry and on, until getting to the stack entry that's currently written into.
	U32BIT dwAddressOfPrecedingMessage; // The device memory address of the command stack entry that physically precedes the next message to read.
	dwAddressOfPrecedingMessage = ( ( (mssspTargetStackState->dwCommandStackBaseAddress == mssspTargetStackState->dwAddressOfMessageToRead) ? (mssspTargetStackState->dwCommandStackBorderAddress) : mssspTargetStackState->dwAddressOfMessageToRead) - sitalMtMemoryObjectSize_COMMAND_STACK_ENTRY );
	U32BIT dwAddressOfDataBlockPointerOfPrecedingMessage; // The device memory address where the pointer to the data block of the stack entry that physically precedes the next message to read is recorded.
	dwAddressOfDataBlockPointerOfPrecedingMessage = (dwAddressOfPrecedingMessage + mtCommandStackEntry_OFFSET_OF_DATA_BLOCK_ADDRESS);
	U16BIT wDataBlockPointerOfPrecedingMessage; // The device memory address of the message data block of the stack entry that physically precedes the next message to read.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Read, dwAddressOfDataBlockPointerOfPrecedingMessage, sitalDeviceMemorySection_Ram, 1U, &wDataBlockPointerOfPrecedingMessage);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	if (0U != wDataBlockPointerOfPrecedingMessage)
	{
		mssspTargetStackState->dwLostMessageCount += ( ( (((mssspTargetStackState->dwAddressOfMessageToRead > mssspTargetStackState->dwAddressOfMessageToWrite) ? mssspTargetStackState->wCommandStackSize : 0U) + mssspTargetStackState->dwAddressOfMessageToWrite - mssspTargetStackState->dwAddressOfMessageToRead) / sitalMtMemoryObjectSize_COMMAND_STACK_ENTRY ) + 1 );

		mssspTargetStackState->dwAddressOfMessageToRead = (mssspTargetStackState->dwAddressOfMessageToWrite + sitalMtMemoryObjectSize_COMMAND_STACK_ENTRY);
		mssspTargetStackState->dwAddressOfMessageToRead = ( (mssspTargetStackState->dwCommandStackBorderAddress == mssspTargetStackState->dwAddressOfMessageToRead) ? mssspTargetStackState->dwCommandStackBaseAddress : mssspTargetStackState->dwAddressOfMessageToRead );
	}

	/// While there are more unread messages in the target command stack of given MT device:
	///		If the host buffer of given device isn't full:
	///			Copy another unread message from the target command stack of given MT device into its host buffer.
	///		Else:
	///			Copy another unread message from the target command stack of given MT device into a temporary buffer.
	///			Increment the number of lost messages for the host buffer of given device.
	///		If a message capture trigger has been defined by the user:
	///			Examine the just read message using the defined trigger.
	///		If another message was read into the host buffer of given device:
	///			Cyclically update the offset where to record the next message in the host buffer of given device.
	///			If no message capture trigger is currently triggered:
	///				Update the count of messages for the host buffer of given device.
	///				If configured to collect operational statistics for given device:
	///					Update host buffer fullness statistics for the host buffer given device.
	///			Else:
	///				If the number of words currently used to store messages in the host buffer of given device became greater than allowed:
	///					Purge the oldest recorded message in the host buffer of given device.
	// Note:
	// - The trigger, if set at all, is checked with the new message:
	//   - Even in case this message couldn't be recorded in the host buffer due to lack of space.
	//   - Only until the first message that meets it is detected.
	// - Messages are recorded using the full capacity of MT host buffers in two cases: 1 - No trigger has been set by the user; 2 - A trigger has been set by the user, and a message that triggered it (i.e., mets the trigger's terms) was already detected.
	//   Otherwise, messages are recorded using a limited capacity of MT host buffers, as specified by the user app when it defined the trigger.
	// - Messages are officially counted only while messages are recorded using the full capacity of MT host buffers.
	U16BIT* wpNextMessage; // A pointer to the place in the currently filled host buffer where the next message should be written.
	wpNextMessage = (hbspHostBuffer->waBuffer + hbspHostBuffer->dwOffsetOfNextMessageToWrite);
	U16BIT* wpNextTimeTagRolloverCount; // A pointer to the place in the time tag rollover count array of the currently filled host buffer where the time tag rollover count next message should be written.
	wpNextTimeTagRolloverCount = (hbspHostBuffer->waTimeTagRolloverCount + (hbspHostBuffer->dwOffsetOfNextMessageToWrite / sitalMtMaximum_MESSAGE_SIZE));
	U16BIT waBuffer[sitalMtMaximum_MESSAGE_SIZE]; // A temporary buffer to store within a message in its raw state.
	BOOLEAN bHostBufferIsFull; // A flag that says whether the host buffer is full.
	U16BIT* wapBuffer; // A pointer to where the next message is written.
	U16BIT* wpTimeTagRolloverCount; // A pointer to where the time tag rollover count of the next message is written.
	U32BIT dwHostBufferMessageWordsCount = 0U; // The number of words in the part of the host buffer that currently contains messages.
	while (mssspTargetStackState->dwAddressOfMessageToRead != mssspTargetStackState->dwAddressOfMessageToWrite)
	{
		if ((hbspHostBuffer->dwOffsetOfNextMessageToWrite != hbspHostBuffer->dwOffsetOfNextMessageToRead) || (0U == hbspHostBuffer->dwMessageCount))
		{
			bHostBufferIsFull = FALSE;
			wapBuffer = wpNextMessage;
			wpTimeTagRolloverCount = wpNextTimeTagRolloverCount;
		}
		else
		{
			bHostBufferIsFull = TRUE;
			wapBuffer = waBuffer;
			hbspHostBuffer->dwLostMessageCount++;
			wpTimeTagRolloverCount = ((U16BIT*)NULL);
		}

		swResult = mt_Message_GetFromStackRaw (swDevice, mssspTargetStackState, wapBuffer, wpTimeTagRolloverCount, (BOOLEAN)TRUE, (BOOLEAN)TRUE);
		if ((S16BIT)0U > swResult)
		{
			return swResult;
		}

		if (TRUE == dsspDeviceState->rms.msMtState.bIsMessageCaptureTriggerOn)
		{
			swResult = mt_MessageCaptureTrigger_ExamineMessage (swDevice, wapBuffer);
		}

		if ( (FALSE == bHostBufferIsFull) && (1 == swResult) )
		{
			hbspHostBuffer->dwOffsetOfNextMessageToWrite += sitalMtMaximum_MESSAGE_SIZE;
			wpNextMessage += sitalMtMaximum_MESSAGE_SIZE;
			wpNextTimeTagRolloverCount++;
			if (hbspHostBuffer->dwHostBufferSize == hbspHostBuffer->dwOffsetOfNextMessageToWrite)
			{
				hbspHostBuffer->dwOffsetOfNextMessageToWrite = 0U;
				wpNextMessage = hbspHostBuffer->waBuffer;
				wpNextTimeTagRolloverCount = hbspHostBuffer->waTimeTagRolloverCount;
			}

			if (FALSE == dsspDeviceState->rms.msMtState.bIsMessageCaptureTriggerOn)
			{
				hbspHostBuffer->dwMessageCount = ( (((hbspHostBuffer->dwOffsetOfNextMessageToRead > hbspHostBuffer->dwOffsetOfNextMessageToWrite) ? hbspHostBuffer->dwHostBufferSize : 0U) + hbspHostBuffer->dwOffsetOfNextMessageToWrite - hbspHostBuffer->dwOffsetOfNextMessageToRead) / sitalRtMaximum_MESSAGE_SIZE );

				if (TRUE == dsspDeviceState->bIsOperationalStatisticsCollected)
				{
					hbspHostBuffer->wFullnessPercentage = (U16BIT)( (double)100.0 * (double)(((hbspHostBuffer->dwOffsetOfNextMessageToRead > hbspHostBuffer->dwOffsetOfNextMessageToWrite) ? hbspHostBuffer->dwHostBufferSize : 0U) + hbspHostBuffer->dwOffsetOfNextMessageToWrite - hbspHostBuffer->dwOffsetOfNextMessageToRead) / ((double)(hbspHostBuffer->dwHostBufferSize)) );
					hbspHostBuffer->wMaximumFullnessPercentage = ( (hbspHostBuffer->wMaximumFullnessPercentage < hbspHostBuffer->wFullnessPercentage) ? hbspHostBuffer->wFullnessPercentage : hbspHostBuffer->wMaximumFullnessPercentage );
				}
			}
			else
			{
				dwHostBufferMessageWordsCount = (((hbspHostBuffer->dwOffsetOfNextMessageToRead > hbspHostBuffer->dwOffsetOfNextMessageToWrite) ? hbspHostBuffer->dwHostBufferSize : 0U) + hbspHostBuffer->dwOffsetOfNextMessageToWrite - hbspHostBuffer->dwOffsetOfNextMessageToRead);

				if (dsspDeviceState->rms.msMtState.dwPreTriggerMessageStoreSize < dwHostBufferMessageWordsCount)
				{
					hbspHostBuffer->dwOffsetOfNextMessageToRead += sitalMtMaximum_MESSAGE_SIZE;
					hbspHostBuffer->dwOffsetOfNextMessageToRead = ( (hbspHostBuffer->dwHostBufferSize == hbspHostBuffer->dwOffsetOfNextMessageToRead) ? 0 : hbspHostBuffer->dwOffsetOfNextMessageToRead );
				}
			}
		}
	}

	/// If given MT device has been configured as having double stack:
	///		Reset the now-inactive stack.wCurrentSizeOfStack (i.e., the one that was active when this function has been entered).
	if (sitalMtStackOption_DOUBLE == dsspDeviceState->rms.msMtState.wStackMode)
	{
		swResult = mt_ResetStack (swDevice, mssspTargetStackState);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Get the number of messages that are currently available in the host buffer that is assigned with given MT device.
///
/// Equivalent DDC definition: aceMTGetHBufMsgCount
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @return Non-negative integer	The number of messages that are currently available in the host buffer that is assigned with given device
/// @return Negative sitalReturnCode_*	Error condition or function failed
S16BIT _DECL sitalMt_HostBuffer_Message_GetCount (S16BIT swDevice)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalMode_MT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	HostBufferStructure* hbspHostBuffer; // A host buffer structure.
	hbspHostBuffer = (HostBufferStructure*)&(dsspDeviceState->rms.msMtState.hbsHostBuffer);
	if (0U == hbspHostBuffer->dwHostBufferSize)
	{
		return sitalReturnCode_HOST_BUFFER_NOT_INSTALLED;
	}

	return (S16BIT)hbspHostBuffer->dwMessageCount;
}


/// <summary>
/// Read from the host buffer of given MT device the message at given location, decode it into given structure, and purge it if so required.
/// Also get the number of retrieved messages (actually only 0 or 1), the host buffer's current number of lost messages, and the current number of lost messages for both given MT device's MT stacks
///
/// Note:
/// - In case of a mode code message with data, this data word is returned as the first (actually the single) data word.
/// - In case a host buffer is assigned to a device, then right after any new message is recorded in this host buffer, that message is purged from the stack.
///   In other words, the usage of a host buffer and the usage of sital*_Message_Get* functions is basically mutually exclussive.
///
/// Equivalent DDC definition: aceMTGetStkMsgDecoded
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param dmspDecodedMessage (out)	A pointer to a structure into which a message is decoded
/// @param dwpMessageCount (out)	A pointer to a variable in which the number of retrieved messages (actually only 0 or 1) is returned
/// @param dwpStackLostMessageCount (out)	A pointer to a variable in which given device stack's current number of lost messages is returned
/// @param dwpHostBufferLostMessageCount (out)	A pointer to a variable in which the host buffer's current number of lost messages is returned
/// @param wMessageLocationAndRemoval (in)	The location in the stack or host buffer of the message to read, and removal instructions (sitalMessageLocationAndRemoval_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
S16BIT _DECL sitalMt_HostBuffer_Message_GetDecoded (	S16BIT swDevice,
														sitalDecodedMessageStructure* dmspDecodedMessage,
														U32BIT* dwpMessageCount,
														U32BIT* dwpStackLostMessageCount,
														U32BIT* dwpHostBufferLostMessageCount,
														U16BIT wMessageLocationAndRemoval)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalMode_MT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((((sitalDecodedMessageStructure*)NULL) == dmspDecodedMessage) || (((U32BIT*)NULL) == dwpMessageCount) || (((U32BIT*)NULL) == dwpHostBufferLostMessageCount) || (((U32BIT*)NULL) == dwpStackLostMessageCount))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if ((0U > wMessageLocationAndRemoval) || (messageLocationAndRemoval_BORDER <= wMessageLocationAndRemoval))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	HostBufferStructure* hbspHostBuffer; // A host buffer structure.
	hbspHostBuffer = (HostBufferStructure*)&(dsspDeviceState->rms.msMtState.hbsHostBuffer);
	if (0U == hbspHostBuffer->dwHostBufferSize)
	{
		return sitalReturnCode_HOST_BUFFER_NOT_INSTALLED;
	}

	///	Set the returned counts of lost messages.
	(*dwpHostBufferLostMessageCount) = hbspHostBuffer->dwLostMessageCount;
	(*dwpStackLostMessageCount) = (dsspDeviceState->rms.msMtState.msssStackStateA.dwLostMessageCount + dsspDeviceState->rms.msMtState.msssStackStateB.dwLostMessageCount);

	/// If no messages are available in the host buffer of given device:
	///		Properly set the returned count of messages.
	///		Return.
	if ((0U == hbspHostBuffer->dwMessageCount) || (hbspHostBuffer->dwOffsetOfNextMessageToRead == hbspHostBuffer->dwOffsetOfNextMessageToWrite))
	{
		(*dwpMessageCount) = 0U;
		return sitalReturnCode_SUCCESS;
	}

	/// Interpret given message location directive.
	BOOLEAN bIsNextMessageRequired; // A flag that says whether to read the next available message (or, else, the last available one).
	bIsNextMessageRequired = (BOOLEAN)((U16BIT)sitalMessageLocation_NEXT == ((U16BIT)messageLocationAndRemoval_LOCATION & wMessageLocationAndRemoval));

	/// Interpret given message removal directive.
	BOOLEAN bIsMessagePurgeRequired; // A flag that says whether to delete the record of the message that's read.
	bIsMessagePurgeRequired = (BOOLEAN)((U16BIT)sitalMessageRemoval_PURGE == ((U16BIT)messageLocationAndRemoval_REMOVAL & wMessageLocationAndRemoval));

	/// Use given message location and purge directives to:
	///		Point the place in host buffer of given device where the requested message is presumably stored.
	///		If the returned message should be purged:
	///			Purge returned message.
	// With all above operations the possibility of an interim rollover is, of course, taken in account below.
	// Note that here 'Purge' solely means a proper update of the host buffer's internal offsets, not an actual zeroing of the message, so it still may be later on decoded (see below).
	U16BIT* wapBuffer; // A pointer to the place in the host buffer in which the requested raw message is stored.
	if (bIsNextMessageRequired)
	{
		wapBuffer = (hbspHostBuffer->waBuffer + hbspHostBuffer->dwOffsetOfNextMessageToRead);

		if (bIsMessagePurgeRequired)
		{
			hbspHostBuffer->dwOffsetOfNextMessageToRead += sitalMtMaximum_MESSAGE_SIZE;
			hbspHostBuffer->dwOffsetOfNextMessageToRead = ( (hbspHostBuffer->dwHostBufferSize == hbspHostBuffer->dwOffsetOfNextMessageToRead) ? 0 : hbspHostBuffer->dwOffsetOfNextMessageToRead );

			hbspHostBuffer->dwMessageCount--;
		}
	}
	else // Last message required
	{
		U32BIT dwOffsetOfLatestWrittenMessage; // The offset (in words) from the beginning of the host buffer of the location where the latest message has been written.
		dwOffsetOfLatestWrittenMessage = ( ((0U == hbspHostBuffer->dwOffsetOfNextMessageToWrite) ? hbspHostBuffer->dwHostBufferSize : hbspHostBuffer->dwOffsetOfNextMessageToWrite) - sitalMtMaximum_MESSAGE_SIZE );
		wapBuffer = (hbspHostBuffer->waBuffer + dwOffsetOfLatestWrittenMessage);

		if (bIsMessagePurgeRequired)
		{
			hbspHostBuffer->dwOffsetOfNextMessageToRead = hbspHostBuffer->dwOffsetOfNextMessageToWrite;
			hbspHostBuffer->dwMessageCount = 0U;
		}
	}

	///	If the returned message should be purged and configured to collect operational statistics for given device:
	///		Update the fullness statistics for given device.
	if ((TRUE == bIsMessagePurgeRequired) && (TRUE == dsspDeviceState->bIsOperationalStatisticsCollected))
	{
		hbspHostBuffer->wFullnessPercentage = (U16BIT)( (double)100.0 * (double)(((hbspHostBuffer->dwOffsetOfNextMessageToRead > hbspHostBuffer->dwOffsetOfNextMessageToWrite) ? hbspHostBuffer->dwHostBufferSize : 0U) + hbspHostBuffer->dwOffsetOfNextMessageToWrite - hbspHostBuffer->dwOffsetOfNextMessageToRead) / ((double)(hbspHostBuffer->dwHostBufferSize)) );
	}

	/// If succeeds to decode a new message starting at the pointed place in host buffer of given device:
	///		Properly set the returned count of messages.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalMt_Message_DecodeRaw (swDevice, wapBuffer, dmspDecodedMessage);
	(*dwpMessageCount) = ( (sitalReturnCode_SUCCESS == swResult) ? 1 : 0U );

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Read from the host buffer of given HOO9 MT device the message at given location, decode it into given structure, and purge it if so required.
/// Also get the number of retrieved messages (actually only 0 or 1), the host buffer's current number of lost messages, and the current number of lost messages for both given MT device's MT stacks
///
/// Note:
/// - In case a host buffer is assigned to a device, then right after any new message is recorded in this host buffer, that message is purged from the stack.
///   In other words, the usage of a host buffer and the usage of sital*_Message_Get* functions is basically mutually exclussive.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param dmspDecodedMessage (out)	A pointer to a structure into which a message is decoded
/// @param dwpMessageCount (out)	A pointer to a variable in which the number of retrieved messages (actually only 0 or 1) is returned
/// @param dwpStackLostMessageCount (out)	A pointer to a variable in which given device stack's current number of lost messages is returned
/// @param dwpHostBufferLostMessageCount (out)	A pointer to a variable in which the host buffer's current number of lost messages is returned
/// @param wMessageLocationAndRemoval (in)	The location in the stack or host buffer of the message to read, and removal instructions (sitalMessageLocationAndRemoval_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
S16BIT _DECL sitalHoo9_Mt_HostBuffer_Message_GetDecoded (	S16BIT swDevice,
															sitalDecodedMessageStructure* dmspDecodedMessage,
															U32BIT* dwpMessageCount,
															U32BIT* dwpStackLostMessageCount,
															U32BIT* dwpHostBufferLostMessageCount,
															U16BIT wMessageLocationAndRemoval)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.

	/// Use the 1553 MT decoded host buffer message reader function.
	// Note that no preparation is needed before calling function sitalMt_HostBuffer_Message_GetDecoded, as the raw host buffer message contains a command word in the 1553 format, which is exactly what this function expects.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalMt_HostBuffer_Message_GetDecoded (swDevice, dmspDecodedMessage, dwpMessageCount, dwpStackLostMessageCount, dwpHostBufferLostMessageCount, wMessageLocationAndRemoval);

	/// Convert the command word of the currently pointed raw message from 1553 into HOO9.
	if (dmspDecodedMessage->bIsCommandWord1Relevant)
	{
		CONVERT_1553_COMMAND_WORD_TO_HOO9_COMMAND_WORD(dmspDecodedMessage->wCommandWord1); // Condition is always true with HOO9, and was added just for sanity.
	}
	if (dmspDecodedMessage->bIsCommandWord2Relevant)
	{
		CONVERT_1553_COMMAND_WORD_TO_HOO9_COMMAND_WORD(dmspDecodedMessage->wCommandWord2); // Condition is never true with HOO9, and was added just for sanity.
	}

	return swResult;
}


/// <summary>
/// Read from the host buffer of given PP194 MT device the message at given location, decode it into given structure, and purge it if so required.
/// Also get the number of retrieved messages (actually only 0 or 1), the host buffer's current number of lost messages, and the current number of lost messages for both given MT device's MT stacks
///
/// Note:
/// - In case a host buffer is assigned to a device, then right after any new message is recorded in this host buffer, that message is purged from the stack.
///   In other words, the usage of a host buffer and the usage of sital*_Message_Get* functions is basically mutually exclussive.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param dmspDecodedMessage (out)	A pointer to a structure into which a message is decoded
/// @param dwpMessageCount (out)	A pointer to a variable in which the number of retrieved messages (actually only 0 or 1) is returned
/// @param dwpStackLostMessageCount (out)	A pointer to a variable in which given device stack's current number of lost messages is returned
/// @param dwpHostBufferLostMessageCount (out)	A pointer to a variable in which the host buffer's current number of lost messages is returned
/// @param wMessageLocationAndRemoval (in)	The location in the stack or host buffer of the message to read, and removal instructions (sitalMessageLocationAndRemoval_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
S16BIT _DECL sitalPp194_Mt_HostBuffer_Message_GetDecoded (	S16BIT swDevice,
															sitalDecodedMessageStructure* dmspDecodedMessage,
															U32BIT* dwpMessageCount,
															U32BIT* dwpStackLostMessageCount,
															U32BIT* dwpHostBufferLostMessageCount,
															U16BIT wMessageLocationAndRemoval)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.

	/// Use the 1553 MT decoded host buffer message reader function.
	return sitalMt_HostBuffer_Message_GetDecoded (swDevice, dmspDecodedMessage, dwpMessageCount, dwpStackLostMessageCount, dwpHostBufferLostMessageCount, wMessageLocationAndRemoval);
}


/// <summary>
/// Read from the host buffer of given MT device as many currently available raw messages as possible (that is, as the size of given buffer permits).
/// Remove from the host buffer the messages that were read.
///
/// Note:
/// - Given buffer is first zeroed, and then filled with available messages, where each message is stored as follows:
///   - A number of sitalMtMaximum_MESSAGE_SIZE memory words is dedicated per message, never mind its actual size.
///   - The target MT stack entry is copied into given buffer.
///   - The data stack pointer is replaced with a word whose:
///     - MSByte contains the count of data words for the message that was read.
///     - LSByte contains the type of the message that was read (sitalMessageType_*).
///   - The data words are stored right after the stack entry, that is, starting at offset sitalMtMemoryObjectSize_COMMAND_STACK_ENTRY.
///     In case of a mode code message with data, this data word is returned as the first (actually the single) data word.
/// - In case a host buffer is assigned to a device, then right after any new message is recorded in this host buffer, that message is purged from the stack.
///   In other words, the usage of a host buffer and the usage of sital*_Message_Get* functions is basically mutually exclussive.
///
/// Equivalent DDC definition: aceMTGetHBufMsgsRaw
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wapBuffer (out)	A pointer to a buffer in which the raw messages are stored
/// @param wBufferSize (in)	The size (in words) of the data buffer that is pointed by wapBuffer (>0)
/// @param dwpMessageCount (out)	A pointer to a variable in which the number of retrieved messages (>=0) is returned
/// @param dwpStackLostMessageCount (out)	A pointer to a variable in which given device stack's current number of lost messages is returned
/// @param dwpHostBufferLostMessageCount (out)	A pointer to a variable in which the host buffer's current number of lost messages is returned
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
S16BIT _DECL sitalMt_HostBuffer_Message_GetRaw (	S16BIT swDevice,
													U16BIT* wapBuffer,
													U16BIT wBufferSize,
													U32BIT* dwpMessageCount,
													U32BIT* dwpStackLostMessageCount,
													U32BIT* dwpHostBufferLostMessageCount)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalMode_MT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((((U16BIT*)NULL) == wapBuffer) || (((U32BIT*)NULL) == dwpMessageCount) || (((U32BIT*)NULL) == dwpHostBufferLostMessageCount) || (((U32BIT*)NULL) == dwpStackLostMessageCount))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if (sitalMtMaximum_MESSAGE_SIZE > wBufferSize)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	HostBufferStructure* hbspHostBuffer; // A host buffer structure.
	hbspHostBuffer = (HostBufferStructure*)&(dsspDeviceState->rms.msMtState.hbsHostBuffer);
	if (0U == hbspHostBuffer->dwHostBufferSize)
	{
		return sitalReturnCode_HOST_BUFFER_NOT_INSTALLED;
	}

	/// Zero given buffer.
	memset ((void*)wapBuffer, (int)0U, (size_t)(wBufferSize << 1U));

	///	Set the returned counts of lost messages.
	(*dwpHostBufferLostMessageCount) = hbspHostBuffer->dwLostMessageCount;
	(*dwpStackLostMessageCount) = (dsspDeviceState->rms.msMtState.msssStackStateA.dwLostMessageCount + dsspDeviceState->rms.msMtState.msssStackStateB.dwLostMessageCount);

	/// Zero the count of returned messages.
	/// While there are more unread messages in the host buffer and there's still place for another message in given buffer:
	///		Copy another message from the host buffer to given buffer.
	///		Point to the place in given buffer where the next message should be stored, if at all.
	///		Decrement the size of the buffer to reflect the remaining size.
	///		Increment the count of raw messages that have been copied.
	///		Purge the message that was just read from the host buffer.
	///		Increment the count of returned messages.
	(*dwpMessageCount) = 0U;
	while ((0U < hbspHostBuffer->dwMessageCount) && (sitalMtMaximum_MESSAGE_SIZE <= wBufferSize))
	{
		void* vp; // A pointer to a void.
		vp = memcpy ((void*)wapBuffer, (void*)(hbspHostBuffer->waBuffer + hbspHostBuffer->dwOffsetOfNextMessageToWrite), (size_t)(sitalMtMaximum_MESSAGE_SIZE << 1U));

		wapBuffer += sitalMtMaximum_MESSAGE_SIZE;
		wBufferSize -= sitalMtMaximum_MESSAGE_SIZE;

		hbspHostBuffer->dwOffsetOfNextMessageToRead += sitalMtMaximum_MESSAGE_SIZE;
		hbspHostBuffer->dwOffsetOfNextMessageToRead = ( (hbspHostBuffer->dwHostBufferSize == hbspHostBuffer->dwOffsetOfNextMessageToRead) ? 0U : hbspHostBuffer->dwOffsetOfNextMessageToRead );

		hbspHostBuffer->dwMessageCount--;

		(*dwpMessageCount)++;
	}

	///	If the returned message should be purged and configured to collect operational statistics for given device:
	///		Update the fullness statistics for given device.
	if ((0U < (*dwpMessageCount)) && (TRUE == dsspDeviceState->bIsOperationalStatisticsCollected))
	{
		hbspHostBuffer->wFullnessPercentage = (U16BIT)( (double)100.0 * (double)(((hbspHostBuffer->dwOffsetOfNextMessageToRead > hbspHostBuffer->dwOffsetOfNextMessageToWrite) ? hbspHostBuffer->dwHostBufferSize : 0U) + hbspHostBuffer->dwOffsetOfNextMessageToWrite - hbspHostBuffer->dwOffsetOfNextMessageToRead) / ((double)(hbspHostBuffer->dwHostBufferSize)) );
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Read from the host buffer of given HOO9 MT device as many currently available raw messages as possible (that is, as the size of given buffer permits).
/// Remove from the host buffer the messages that were read.
///
/// Note:
/// - Given buffer is first zeroed, and then filled with available messages, where each message is stored as follows:
///   - A number of sitalMtMaximum_MESSAGE_SIZE memory words is dedicated per message, never mind its actual size.
///   - The target MT stack entry is copied into given buffer.
///   - The data stack pointer is replaced with a word whose:
///     - MSByte contains the count of data words for the message that was read.
///     - LSByte contains the type of the message that was read (sitalMessageType_*).
///   - The data words are stored right after the stack entry, that is, starting at offset sitalMtMemoryObjectSize_COMMAND_STACK_ENTRY.
///     In case of a mode code message with data, this data word is returned as the first (actually the single) data word.
/// - In case a host buffer is assigned to a device, then right after any new message is recorded in this host buffer, that message is purged from the stack.
///   In other words, the usage of a host buffer and the usage of sital*_Message_Get* functions is basically mutually exclussive.
/// - The status-related fields of the sitalDecodedMessageStructure are filled with dummy values, as no statuses are returned in the HOO9 protocol.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wapBuffer (out)	A pointer to a buffer in which the raw messages are stored
/// @param wBufferSize (in)	The size (in words) of the data buffer that is pointed by wapBuffer (>0)
/// @param dwpMessageCount (out)	A pointer to a variable in which the number of retrieved messages (>=0) is returned
/// @param dwpStackLostMessageCount (out)	A pointer to a variable in which given device stack's current number of lost messages is returned
/// @param dwpHostBufferLostMessageCount (out)	A pointer to a variable in which the host buffer's current number of lost messages is returned
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
S16BIT _DECL sitalHoo9_Mt_HostBuffer_Message_GetRaw (	S16BIT swDevice,
														U16BIT* wapBuffer,
														U16BIT wBufferSize,
														U32BIT* dwpMessageCount,
														U32BIT* dwpStackLostMessageCount,
														U32BIT* dwpHostBufferLostMessageCount)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.

	/// Use the 1553 MT raw host buffer message reader function.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalMt_HostBuffer_Message_GetRaw (swDevice, wapBuffer, wBufferSize, dwpMessageCount, dwpStackLostMessageCount, dwpHostBufferLostMessageCount);
	if ((S16BIT)0U > swResult)
	{
		return swResult;
	}

	/// Loop over all the raw messages that were read:
	U16BIT* wpCommand; // A pointer to the command word of the currently handled raw message.
	wpCommand = (wapBuffer + mtCommandStackEntry_OFFSET_OF_COMMAND);
	for (U32BIT i=0; i<(*dwpMessageCount); i++, wpCommand+=sitalMtMaximum_MESSAGE_SIZE)
	{
		///		Convert the command word of the current raw message from 1553 into HOO9.
		CONVERT_1553_COMMAND_WORD_TO_HOO9_COMMAND_WORD(*wpCommand);
	}

	return swResult;
}


/// <summary>
/// Read from the host buffer of given PP194 MT device as many currently available raw messages as possible (that is, as the size of given buffer permits).
/// Remove from the host buffer the messages that were read.
///
/// Note:
/// - Given buffer is first zeroed, and then filled with available messages, where each message is stored as follows:
///   - A number of sitalMtMaximum_MESSAGE_SIZE memory words is dedicated per message, never mind its actual size.
///   - The target MT stack entry is copied into given buffer.
///   - The data stack pointer is replaced with a word whose:
///     - MSByte contains the count of data words for the message that was read.
///     - LSByte contains the type of the message that was read (sitalMessageType_*).
///   - The data words are stored right after the stack entry, that is, starting at offset sitalMtMemoryObjectSize_COMMAND_STACK_ENTRY.
///     In case of a mode code message with data, this data word is returned as the first (actually the single) data word.
/// - In case a host buffer is assigned to a device, then right after any new message is recorded in this host buffer, that message is purged from the stack.
///   In other words, the usage of a host buffer and the usage of sital*_Message_Get* functions is basically mutually exclussive.
/// - The status-related fields of the sitalDecodedMessageStructure are filled with dummy values, as no statuses are returned in the PP194 protocol.
///
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wapBuffer (out)	A pointer to a buffer in which the raw messages are stored
/// @param wBufferSize (in)	The size (in words) of the data buffer that is pointed by wapBuffer (>0)
/// @param dwpMessageCount (out)	A pointer to a variable in which the number of retrieved messages (>=0) is returned
/// @param dwpStackLostMessageCount (out)	A pointer to a variable in which given device stack's current number of lost messages is returned
/// @param dwpHostBufferLostMessageCount (out)	A pointer to a variable in which the host buffer's current number of lost messages is returned
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
S16BIT _DECL sitalPp194_Mt_HostBuffer_Message_GetRaw (	S16BIT swDevice,
														U16BIT* wapBuffer,
														U16BIT wBufferSize,
														U32BIT* dwpMessageCount,
														U32BIT* dwpStackLostMessageCount,
														U32BIT* dwpHostBufferLostMessageCount)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.

	/// Use the 1553 MT raw host buffer message reader function.
	return sitalMt_HostBuffer_Message_GetRaw (swDevice, wapBuffer, wBufferSize, dwpMessageCount, dwpStackLostMessageCount, dwpHostBufferLostMessageCount);
}


/// <summary>
/// Return performance information about the host buffer of given MT device.
///
/// Equivalent DDC definition: aceMTGetHBufMetric
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param hbosspHostBufferOperationalStatistics (out)	A pointer to the host buffer operational statistics structure into which the required operational statistics are written
/// @param bIsResetOfHighestRecordedPercentageRequired (in)	A flag that says whether the record of the highest percentage reached by now should be reset
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalMt_HostBuffer_GetOperationalStatistics (S16BIT swDevice, sitalHostBufferOperationalStatisticsStructure* hbosspHostBufferOperationalStatistics, U16BIT bIsResetOfHighestRecordedPercentageRequired)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if ((sitalMode_MT != dsspDeviceState->wMode) && (sitalMode_RT_AND_MT != dsspDeviceState->wMode))
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (((sitalHostBufferOperationalStatisticsStructure*)NULL) == hbosspHostBufferOperationalStatistics)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if (FALSE == dsspDeviceState->bIsOperationalStatisticsCollected)
	{
		return sitalReturnCode_OPERATIONAL_STATISTICS_NOT_ENABLED;
	}

	HostBufferStructure* hbspHostBuffer; // A host buffer structure.
	hbspHostBuffer = (HostBufferStructure*)&(dsspDeviceState->rms.msMtState.hbsHostBuffer);
	if (0U == hbspHostBuffer->dwHostBufferSize)
	{
		return sitalReturnCode_HOST_BUFFER_NOT_INSTALLED;
	}

	hbosspHostBufferOperationalStatistics->dwMessageCount = hbspHostBuffer->dwMessageCount;
	hbosspHostBufferOperationalStatistics->dwLostMessageCount = hbspHostBuffer->dwLostMessageCount;
	hbosspHostBufferOperationalStatistics->dwFullnessPercentage = hbspHostBuffer->wFullnessPercentage;
	hbosspHostBufferOperationalStatistics->dwMaximumFullnessPercentage = hbspHostBuffer->wMaximumFullnessPercentage;

	if ((U16BIT)0U != bIsResetOfHighestRecordedPercentageRequired)
	{
		hbspHostBuffer->wMaximumFullnessPercentage = 0U;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Initialize given device as a RT&MT in accordance with given initialization options.
/// Release any past allocations of device memory.
///
/// Note:
/// - This function assumes that function sitalDevice_Initialize has already been called, initialized given device, and inquired its capabilities.
///   This function then lets the user reinitialize given device with a non default configuration.
/// - This function illegalizes messages for all address type, direction, subaddress, and word-count-or-mode-code combinations.
///   To legalize a specific combination, either of the following functions may be used, as appropriate: sitalRt_DataBlock_MapToSubaddress, sitalRt_MessageLegality_Enable.
/// - Both MT stacks, command and data, must be aligned in the device memory to their size (e.g., a 4096 word stack may be placed only at an address of  the form 4096xN where N=0,1,2,...).
/// - In case the caller specifies stack sizes that the memory of given device is too small to contain, the function call will be rejected.
///
/// Equivalent DDC definition: aceRTMTConfigure
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wRtCommandStackSize (in)	The desired size (in words) of the RT command stack (sitalRtCommandStackSize_*)
/// @param wMtStackMode (in)	MT stack mode (principally sitalMtStackOption_*, actually limited to sitalMtStackOption_SINGLE)
/// @param wMtCommandStackSize (in)	Size of MT command stack (sitalMtCommandStackSize_*)
/// @param wMtDataStackSize (in)	Size of MT data stack (sitalMtDataStackSize_*)
/// @param dwOptions (in)	Initialization options (An or-ed combination of sitalRtSetupOption_*, sitalMtSetupOption_*, and sitalRtMtSetupOption_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRtMt_Initialize (	S16BIT swDevice,
									U16BIT wRtCommandStackSize,
									U16BIT wMtStackMode,
									U16BIT wMtCommandStackSize,
									U16BIT wMtDataStackSize,
									U32BIT dwOptions)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_RT_AND_MT != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (0U != (rtCommandStackSize_BORDER & wRtCommandStackSize))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if (sitalMtStackOption_SINGLE != wMtStackMode)
	{
		return sitalReturnCode_MT_INVALID_STACK_OPTION;
	}

	if (0U != ((~mtCommandStackSize_MASK) & wMtCommandStackSize))
	{
		return sitalReturnCode_MT_INVALID_COMMAND_STACK_SIZE;
	}

	if ( (0U == wMtDataStackSize) || (0U != ((~mtDataStackSize_MASK) & wMtDataStackSize)) )
	{
		return sitalReturnCode_MT_INVALID_DATA_STACK_SIZE;
	}

	/// Clear device memory.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_Zero, 0U, sitalDeviceMemorySection_Ram, dsspDeviceState->dcsDeviceCapabilities.dwRamSize, ((U16BIT*)NULL));
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Initialize device memory management.
	swResult = Device_Memory_Initialize (&(dsspDeviceState->hdmmsDeviceMemoryMap), dsspDeviceState->dcsDeviceCapabilities.dwRamSize);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Catch any permanently allocated regions of device memory.
	swResult = Device_Memory_TopSection_CatchRegion (&(dsspDeviceState->hdmmsDeviceMemoryMap), 0U, (rtmtAddressMap_FREE_MEMORY - 1U));

	/// Initialize MT.
	swResult = mt_Initialize (swDevice, wMtStackMode, wMtCommandStackSize, wMtDataStackSize, dwOptions);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Initialize RT.
	swResult = rt_Initialize (swDevice, wRtCommandStackSize, dwOptions);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// In case of a real device:
	///		Set a suitable internal ISR.
	///		Configure the user's interrupt mask pseudo register.
	if (sitalAccess_CARD == dsspDeviceState->wAccess)
	{
		swResult = sitalProcess_SetInterruptServiceRoutine ((ISR_FUNCTION)rtmt_HandleInterrupt);
		dsspDeviceState->dwInternalImr = 0U;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Make given RT&MT device start responding and capturing messages.
///
/// Equivalent DDC definition: aceRTMTStart
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRtMt_Start (S16BIT swDevice)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_RT_AND_MT != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((sitalAccess_CARD != dsspDeviceState->wAccess) && (sitalAccess_USER != dsspDeviceState->wAccess))
	{
		return sitalReturnCode_INVALID_ACCESS;
	}

	/// Virtually configure given RT&MT device to be able to start receiving messages.
	S16BIT swResult; // Result of operation or function call.
	swResult = rt_Start (swDevice);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Virtually configure given RT&MT device to be able to start capturing messages.
	swResult = mt_Start (swDevice);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Copy the registers from host to device memory.
	swResult = device_Register_UpdateDevice (swDevice);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Actually start the device.
	U16BIT wRegisterValue; // The current value of a target register, or the value to set for a target register.
	wRegisterValue = (sitalConfigurationRegister1_FUNCTION_RT | sitalConfigurationRegister1_RT_MESSAGE_MONITOR_ENABLED);
	swResult = sitalDevice_AccessMemory (swDevice, sitalDeviceAccessOperation_WriteMasked, sitalRegisterAddress_CONFIGURATION_1, sitalDeviceMemorySection_Registers, wRegisterValue, &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Update the state of given device.
	//swResult = sitalProcess_Log_PrintLine ("#StldDll.Device.State.Change: device - %i, old - %i, new - %i\n", swDevice, dsspDeviceState->wCurrentState, sitalDeviceState_RUN);
	dsspDeviceState->wCurrentState = sitalDeviceState_RUN;

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Stop given RT&MT device from responding to received messages.
///
/// Equivalent DDC definition: aceRTMTStop
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRtMt_Stop (S16BIT swDevice)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_RT_AND_MT != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_RUN != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((sitalAccess_CARD != dsspDeviceState->wAccess) && (sitalAccess_USER != dsspDeviceState->wAccess))
	{
		return sitalReturnCode_INVALID_ACCESS;
	}

	///	Actually stop given RT&MT device.
	U16BIT wRegisterValue; // The current value of a target register, or the value to set for a target register.
	wRegisterValue = registerMask_ALL_BITS_OFF;
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalDevice_AccessMemory	(swDevice, sitalDeviceAccessOperation_WriteMasked, sitalRegisterAddress_CONFIGURATION_1, sitalDeviceMemorySection_Registers, (sitalConfigurationRegister1_FUNCTION_RT | sitalConfigurationRegister1_FUNCTION_MT), &wRegisterValue);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Designate given device as ready.
	//swResult = sitalProcess_Log_PrintLine ("#StldDll.Device.State.Change: device - %i, old - %i, new - %i\n", swDevice, dsspDeviceState->wCurrentState, sitalDeviceState_READY);
	dsspDeviceState->wCurrentState = sitalDeviceState_READY;

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Initialize (or re-initialize) given device's RT&MT combined host buffer.
///
/// Note:
/// - The RT&MT combined host buffer is actually a combination of two separate host buffers, RT host buffer and MT host buffer, each of which manipulated exactly like when used by regular RT or MT devices, respectively.
///   No additional or temporary host buffers are used.
///   In this mode of operation, whenever relevant, functions sitalRtMt_HostBuffer_Message_GetRaw/Decoded search the RT and MT host buffers to find the earliest available message, and fetch it.
///   In order to use this mode of operation, the user application must specify option sitalRtMtSetupOption_COMBINED_HOST_BUFFER when calling function sitalRtMt_Initialize.
///   Yet, even in case it specified this option, the caller user application, the user may prefer to use functions sitalRt_HostBuffer_* or sitalMt_HostBuffer_* over functions sitalRtMt_HostBuffer_*, or somehow combine these functions.
///   In the last case, the user application must be fully aware of the state of the RT and MT host buffers; for example:
///   - After getting a message using function sitalMt_HostBuffer_Message_GetRaw, this message may not, of course, be read again using function sitalRtMt_HostBuffer_Message_GetRaw.
///   - After freeing the MT host buffer using function sitalMt_HostBuffer_Free, no MT messages will be, of course, read by further calls to function sitalRtMt_HostBuffer_Message_GetRaw.
/// - Given size of host buffer must be large enough to contain sitalRtMinimum_COMMAND_STACKS_IN_HOST_BUFFER times the number of raw messages that the command stack of given RT device may contain.
///   The number of messages that may be contained by the command stack (N) is its configured size in words divided by sitalRtMemoryObjectSize_COMMAND_STACK_ENTRY.
///   As the maximum possible size of message is allocated for each message in the host buffer, the corresponding size (in words) is (N / sitalRtMaximum_MESSAGE_SIZE).
///   Therefore, given size must be not less than (sitalRtMinimum_COMMAND_STACKS_IN_HOST_BUFFER * (N / sitalRtMaximum_MESSAGE_SIZE)).
/// - Given size of host buffer must be large enough to contain sitalMtMinimum_COMMAND_STACKS_IN_HOST_BUFFER times the number of raw messages that the command stack of given MT device may contain.
///   The number of messages that may be contained by the command stack (N) is its configured size in words divided by sitalMtMemoryObjectSize_COMMAND_STACK_ENTRY.
///   As the maximum possible size of message is allocated for each message in the host buffer, the corresponding size (in words) is (N / sitalMtMaximum_MESSAGE_SIZE).
///   Therefore, given size must be not less than (sitalMtMinimum_COMMAND_STACKS_IN_HOST_BUFFER * (N / sitalMtMaximum_MESSAGE_SIZE)).
///
/// Equivalent DDC definition: aceRTMTInstallHBuf
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param dwHostBufferSize (in)	The desired size (in words) of each of the RT and MT host buffer (<above-defined-minimum-size-of-RT&MT-host-buffer>-sitalMaximum_SIZE_OF_HOST_BUFFER)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
S16BIT _DECL sitalRtMt_HostBuffer_Initialize (S16BIT swDevice, U32BIT dwHostBufferSize)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_RT_AND_MT != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (0U == (sitalRtMtSetupOption_COMBINED_HOST_BUFFER & dsspDeviceState->rms.msMtState.dwOptions))
	{
		return sitalReturnCode_RT_AND_MT_NON_COMBINED_HOST_BUFFER_MODE;
	}

	if	(
				(((sitalRtMinimum_COMMAND_STACKS_IN_HOST_BUFFER * ((U32BIT)(dsspDeviceState->rms.rsRtState.rsssStackState.wCommandStackSize) / sitalRtMemoryObjectSize_COMMAND_STACK_ENTRY) * sitalRtMaximum_MESSAGE_SIZE)) > dwHostBufferSize)
			||
				(((sitalMtMinimum_COMMAND_STACKS_IN_HOST_BUFFER * ((U32BIT)(dsspDeviceState->rms.msMtState.msssStackStateA.wCommandStackSize) / sitalMtMemoryObjectSize_COMMAND_STACK_ENTRY) * sitalMtMaximum_MESSAGE_SIZE)) > dwHostBufferSize)
			||
				(sitalMaximum_SIZE_OF_HOST_BUFFER < dwHostBufferSize))
	{
		return sitalReturnCode_INVALID_HOST_BUFFER_SIZE;
	}

	/// If given device's combined host buffer is currently in use:
	///		Reset given device's combined host buffer.
	HostBufferStructure* hbspHostBuffer; // A host buffer structure.
	hbspHostBuffer = &(dsspDeviceState->rms.rsRtState.hbsHostBuffer);
	S16BIT swResult; // Result of operation or function call.
	if (0U != hbspHostBuffer->dwHostBufferSize)
	{
		swResult = sitalRt_HostBuffer_Free (swDevice);
	}

	hbspHostBuffer = &(dsspDeviceState->rms.msMtState.hbsHostBuffer);
	if (0U != hbspHostBuffer->dwHostBufferSize)
	{
		swResult = sitalMt_HostBuffer_Free (swDevice);
	}

	///	Properly set given device's combined host buffer.
	hbspHostBuffer = &(dsspDeviceState->rms.rsRtState.hbsHostBuffer);
	hbspHostBuffer->dwHostBufferSize = ( dwHostBufferSize - (dwHostBufferSize % sitalRtMaximum_MESSAGE_SIZE) );
	hbspHostBuffer->dwLastMessageTimeTag = 0U;
	hbspHostBuffer->dwOffsetOfNextMessageToRead = 0U;
	hbspHostBuffer->dwOffsetOfNextMessageToWrite = 0U;
	hbspHostBuffer->dwMessageCount = 0U;
	hbspHostBuffer->dwLostMessageCount = 0U;
	hbspHostBuffer->wFullnessPercentage = 0U;
	hbspHostBuffer->wMaximumFullnessPercentage = 0U;

	hbspHostBuffer = &(dsspDeviceState->rms.msMtState.hbsHostBuffer);
	hbspHostBuffer->dwHostBufferSize = ( dwHostBufferSize - (dwHostBufferSize % sitalMtMaximum_MESSAGE_SIZE) );
	hbspHostBuffer->dwLastMessageTimeTag = 0U;
	hbspHostBuffer->dwOffsetOfNextMessageToRead = 0U;
	hbspHostBuffer->dwOffsetOfNextMessageToWrite = 0U;
	hbspHostBuffer->dwMessageCount = 0U;
	hbspHostBuffer->dwLostMessageCount = 0U;
	hbspHostBuffer->wFullnessPercentage = 0U;
	hbspHostBuffer->wMaximumFullnessPercentage = 0U;

	/// In case of a real device:
	///		Set a suitable ISR for given device.
	///		Configure the user's interrupt mask pseudo register to issue those interrupts that are relevant while recording messages in given device's combined host buffer.
	if (sitalAccess_CARD == dsspDeviceState->wAccess)
	{
		swResult = sitalProcess_SetInterruptServiceRoutine ((ISR_FUNCTION)rtmt_HandleInterrupt);

		dsspDeviceState->dwInternalImr |= (sitalInterruptRegister2_RT_COMMAND_STACK_HALF_ROLLOVER| sitalInterruptRegister2_MT_COMMAND_STACK_HALF_ROLLOVER | sitalInterruptRegister2_MT_DATA_STACK_HALF_ROLLOVER | sitalInterruptRegister1_BC_RT_COMMAND_STACK_ROLLOVER | sitalInterruptRegister1_MT_COMMAND_STACK_ROLLOVER | sitalInterruptRegister1_MT_DATA_STACK_ROLLOVER | sitalInterruptRegister1_TIME_TAG_ROLLOVER | sitalInterruptRegister1_END_OF_MESSAGE);
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Free given device's RT&MT combined host buffer.
///
/// Note:
/// - See the documentation of function sitalRtMt_HostBuffer_Initialize for more information on using functions sitalRt_HostBuffer_* or sitalMt_HostBuffer_* combined with functions sitalRtMt_HostBuffer_*.
///
/// Equivalent DDC definition: aceRTMTUninstallHBuf
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
S16BIT _DECL sitalRtMt_HostBuffer_Free (S16BIT swDevice)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
							= &(s_dssaDevices[swDevice]);
	if (sitalMode_RT_AND_MT != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if (sitalDeviceState_READY != dsspDeviceState->wCurrentState)
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((0U == dsspDeviceState->rms.rsRtState.hbsHostBuffer.dwHostBufferSize) && (0U == dsspDeviceState->rms.msMtState.hbsHostBuffer.dwHostBufferSize))
	{
		return sitalReturnCode_HOST_BUFFER_NOT_INSTALLED;
	}

	///	Free given device's combined host buffer.
	HostBufferStructure* hbspHostBuffer; // A host buffer structure.
	hbspHostBuffer = &(dsspDeviceState->rms.rsRtState.hbsHostBuffer);
	hbspHostBuffer->dwHostBufferSize = 0U;
	hbspHostBuffer->dwLastMessageTimeTag = 0U;
	hbspHostBuffer->dwOffsetOfNextMessageToRead = 0U;
	hbspHostBuffer->dwOffsetOfNextMessageToWrite = 0U;
	hbspHostBuffer->dwMessageCount = 0U;
	hbspHostBuffer->dwLostMessageCount = 0U;
	hbspHostBuffer->wFullnessPercentage = 0U;
	hbspHostBuffer->wMaximumFullnessPercentage = 0U;

	hbspHostBuffer = &(dsspDeviceState->rms.msMtState.hbsHostBuffer);
	hbspHostBuffer->dwHostBufferSize = 0U;
	hbspHostBuffer->dwLastMessageTimeTag = 0U;
	hbspHostBuffer->dwOffsetOfNextMessageToRead = 0U;
	hbspHostBuffer->dwOffsetOfNextMessageToWrite = 0U;
	hbspHostBuffer->dwMessageCount = 0U;
	hbspHostBuffer->dwLostMessageCount = 0U;
	hbspHostBuffer->wFullnessPercentage = 0U;
	hbspHostBuffer->wMaximumFullnessPercentage = 0U;

	/// In case of a real device:
	///		Set a suitable ISR for given device.
	///		Configure the user's interrupt mask pseudo register to avoid raising those host buffer filling interrupts which are not required anymore.
	// Note:
	// - With a RTMT device:
	//   - The RTMT ISR is set as long as at least one of the RT and MT host buffers is installed.
	//   - Interrupts that are relevant while recording messages in a host buffer of a RT device are passed to the user's ISR (if one is defined at all) as long as the RT host buffer is installed.
	//   - Interrupts that are relevant while recording messages in a host buffer of a MT device are passed to the user's ISR (if one is defined at all) as long as the MT host buffer is installed.
	S16BIT swResult; // Result of operation or function call.
	if (sitalAccess_CARD == dsspDeviceState->wAccess)
	{
		swResult = sitalProcess_SetInterruptServiceRoutine ((ISR_FUNCTION)NULL);
		dsspDeviceState->dwInternalImr &= ( ~ (sitalInterruptRegister2_RT_COMMAND_STACK_HALF_ROLLOVER | sitalInterruptRegister2_MT_COMMAND_STACK_HALF_ROLLOVER | sitalInterruptRegister2_MT_DATA_STACK_HALF_ROLLOVER | sitalInterruptRegister1_BC_RT_COMMAND_STACK_ROLLOVER | sitalInterruptRegister1_MT_COMMAND_STACK_ROLLOVER | sitalInterruptRegister1_MT_DATA_STACK_ROLLOVER | sitalInterruptRegister1_TIME_TAG_ROLLOVER | sitalInterruptRegister1_END_OF_MESSAGE) );
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Record the newly received messages from the active command and data stacks of given RT&MT device into its combined host buffer.
///
/// Note:
/// - User applications should not principally use this function, as it is automatically called by this library whenever a relevant interrupt occurs.
///   This function has been originally exported only in order to enable working with operating systems that does not support interrupts.
/// - Messages are recorded in the host buffer only as long that it isn't full, that is, there's no override of old messages by new ones.
///   The user must repeatedly get messages from the host buffer in order to empty it.
/// - See the documentation of function sitalRtMt_HostBuffer_Initialize for more information on using functions sitalRt_HostBuffer_* or sitalMt_HostBuffer_* combined with functions sitalRtMt_HostBuffer_*.
///
/// Equivalent DDC definition: aceRTMTStkToHBuf
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRtMt_HostBuffer_Message_Record (S16BIT swDevice)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalMode_RT_AND_MT != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((0U == dsspDeviceState->rms.rsRtState.hbsHostBuffer.dwHostBufferSize) && (0U == dsspDeviceState->rms.msMtState.hbsHostBuffer.dwHostBufferSize))
	{
		return sitalReturnCode_HOST_BUFFER_NOT_INSTALLED;
	}

	///	Update the host buffers assigned with given RT&MT device.
	S16BIT swResult; // Result of operation or function call.
	swResult = sitalRt_HostBuffer_Message_Record (swDevice);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	swResult = sitalMt_HostBuffer_Message_Record (swDevice);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Get the number of messages that are currently available in the combined host buffer that is assigned with given RT&MT device.
///
/// Note:
/// - See the documentation of function sitalRtMt_HostBuffer_Initialize for more information on using functions sitalRt_HostBuffer_* or sitalMt_HostBuffer_* combined with functions sitalRtMt_HostBuffer_*.
///
/// Equivalent DDC definition: aceRTMTGetHBufMsgCount
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @return Non-negative integer	The number of messages that are currently available in the host buffer that is assigned with given device
/// @return Negative sitalReturnCode_*	Error condition or function failed
S16BIT _DECL sitalRtMt_HostBuffer_Message_GetCount (S16BIT swDevice)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalMode_RT_AND_MT != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((0U == dsspDeviceState->rms.rsRtState.hbsHostBuffer.dwHostBufferSize) || (0U == dsspDeviceState->rms.msMtState.hbsHostBuffer.dwHostBufferSize))
	{
		return sitalReturnCode_HOST_BUFFER_NOT_INSTALLED;
	}

	return (S16BIT)(dsspDeviceState->rms.rsRtState.hbsHostBuffer.dwMessageCount + dsspDeviceState->rms.msMtState.hbsHostBuffer.dwMessageCount);
}


/// <summary>
/// Read from the combined host buffer of given RT&MT device the message at given location, decode it into given structure, and purge it if so required.
/// Also get the number of retrieved messages (actually only 0 or 1), the combined host buffer's current number of lost messages, the current number of lost messages for given RT&MT device's RT stack, and the current number of lost messages for both given RT&MT device's MT stacks.
///
/// Note:
/// - In case of a mode code message with data, this data word is returned as the first (actually the single) data word.
/// - In case a host buffer is assigned to a device, then right after any new message is recorded in this host buffer, that message is purged from the stack.
///   In other words, the usage of a host buffer and the usage of sital*_Message_Get* functions is basically mutually exclussive.
/// - See the documentation of function sitalRtMt_HostBuffer_Initialize for more information on using functions sitalRt_HostBuffer_* or sitalMt_HostBuffer_* combined with functions sitalRtMt_HostBuffer_*.
///
/// Equivalent DDC definition: aceRTMTGetStkMsgDecoded
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param dmspDecodedMessage (out)	A pointer to a structure into which a message is decoded
/// @param dwpMessageCount (out)	A pointer to a variable in which the number of retrieved messages (actually only 0 or 1) is returned
/// @param dwpRtStackLostMessageCount (out)	A pointer to a variable in which the current number of lost messages for given RT&MT device's RT stack is returned
/// @param dwpMtStackLostMessageCount (out)	A pointer to a variable in which the current number of lost messages for both given RT&MT device's MT stacks is returned
/// @param dwpHostBufferLostMessageCount (out)	A pointer to a variable in which the combined host buffer's current number of lost messages is returned
/// @param wMessageLocationAndRemoval (in)	The location in the stack or host buffer of the message to read, and removal instructions (sitalMessageLocationAndRemoval_*)
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
S16BIT _DECL sitalRtMt_HostBuffer_Message_GetDecoded (	S16BIT swDevice,
														sitalDecodedMessageStructure* dmspDecodedMessage,
														U32BIT* dwpMessageCount,
														U32BIT* dwpRtStackLostMessageCount,
														U32BIT* dwpMtStackLostMessageCount,
														U32BIT* dwpHostBufferLostMessageCount,
														U16BIT wMessageLocationAndRemoval)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalMode_RT_AND_MT != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((((sitalDecodedMessageStructure*)NULL) == dmspDecodedMessage) || (((U32BIT*)NULL) == dwpMessageCount) || (((U32BIT*)NULL) == dwpRtStackLostMessageCount) || (((U32BIT*)NULL) == dwpMtStackLostMessageCount) || (((U32BIT*)NULL) == dwpHostBufferLostMessageCount))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if ((0U > wMessageLocationAndRemoval) || (messageLocationAndRemoval_BORDER <= wMessageLocationAndRemoval))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	HostBufferStructure* hbspRtHostBuffer; // A host buffer structure.
	hbspRtHostBuffer = (HostBufferStructure*)&(dsspDeviceState->rms.rsRtState.hbsHostBuffer);
	if (0U == hbspRtHostBuffer->dwHostBufferSize)
	{
		return sitalReturnCode_HOST_BUFFER_NOT_INSTALLED;
	}

	HostBufferStructure* hbspMtHostBuffer; // A host buffer structure.
	hbspMtHostBuffer = (HostBufferStructure*)&(dsspDeviceState->rms.msMtState.hbsHostBuffer);
	if (0U == hbspMtHostBuffer->dwHostBufferSize)
	{
		return sitalReturnCode_HOST_BUFFER_NOT_INSTALLED;
	}

	if (0U == (sitalRtMtSetupOption_COMBINED_HOST_BUFFER & dsspDeviceState->rms.msMtState.dwOptions))
	{
		return sitalReturnCode_RT_AND_MT_NON_COMBINED_HOST_BUFFER_MODE;
	}

	/// Calculate requested statistics.
	(*dwpRtStackLostMessageCount) = dsspDeviceState->rms.rsRtState.rsssStackState.dwLostMessageCount;
	(*dwpMtStackLostMessageCount) = (dsspDeviceState->rms.msMtState.msssStackStateA.dwLostMessageCount + dsspDeviceState->rms.msMtState.msssStackStateB.dwLostMessageCount);
	(*dwpHostBufferLostMessageCount) = (hbspRtHostBuffer->dwLostMessageCount + hbspMtHostBuffer->dwLostMessageCount);

	/// Find the host buffer from which the requested message should be read.
	// The caller wants to get the next/last message in the RT&MT combined host buffer.
	// But each of the host buffers that together make up this combined host buffer, i.e., the RT and the MT host buffers, principally has a next/last message of its own, and it should be here decided from which of them to read.
	// The way to decide from which host buffer to read the requested message is to select the one that stores the earlier/later of these two messages, in case the next/last message is requested, respectively.
	U16BIT wRequestedMessageContainerHostBuffer; // The identity of the host buffer in which the requested message is stored (i.e., the one that stores the earlier/later of these two messages, in case the next/last message is requested, respectively).
	S16BIT swResult; // Result of operation or function call.
	swResult = rtmt_HostBuffer_Message_FindContainer (swDevice, wMessageLocationAndRemoval, &wRequestedMessageContainerHostBuffer);
	if (sitalReturnCode_SUCCESS != swResult)
	{
		return swResult;
	}

	/// Get the requested message from its container host buffer.
	U32BIT dwStackLostMessageCount; // Number of lost messages for the target RT/MT stack.
	U32BIT dwHostBufferLostMessageCount; // Number of lost messages for the target host buffer.
	switch (wRequestedMessageContainerHostBuffer)
	{
	case rtMtMessageContainerHostBuffer_RT:
		swResult = sitalRt_HostBuffer_Message_GetDecoded (swDevice, dmspDecodedMessage, dwpMessageCount, &dwStackLostMessageCount, &dwHostBufferLostMessageCount, wMessageLocationAndRemoval);
		break;
	case rtMtMessageContainerHostBuffer_MT:
		swResult = sitalMt_HostBuffer_Message_GetDecoded (swDevice, dmspDecodedMessage, dwpMessageCount, &dwStackLostMessageCount, &dwHostBufferLostMessageCount, wMessageLocationAndRemoval);
		break;
	case rtMtMessageContainerHostBuffer_NONE:
		(*dwpMessageCount) = 0U;
		return sitalReturnCode_SUCCESS;
	default:
		return sitalReturnCode_UNKNOWN_ERROR;
	}

	return swResult;
}


/// <summary>
/// Read from the combined host buffer of given RT&MT device as many currently available raw messages as possible (that is, as the size of given buffer permits).
/// Remove from the combined host buffer the messages that were read.
///
/// Note:
/// - Given buffer is first zeroed, and then filled with available messages, where each message is stored as follows:
///   - A number of sitalRtMtMaximum_MESSAGE_SIZE memory words is dedicated per message, never mind its actual size.
///   - The target RT&MT stack entry is copied into given buffer.
///   - The data stack pointer is replaced with a word whose:
///     - MSByte contains the count of data words for the message that was read.
///     - LSByte contains the type of the message that was read (sitalMessageType_*).
///   - The data words are stored right after the stack entry, that is, starting at offset sitalRtMtMemoryObjectSize_COMMAND_STACK_ENTRY.
///     In case of a mode code message with data, this data word is returned as the first (actually the single) data word.
/// - In case a host buffer is assigned to a device, then right after any new message is recorded in this host buffer, that message is purged from the stack.
///   In other words, the usage of a host buffer and the usage of sital*_Message_Get* functions is basically mutually exclussive.
/// - See the documentation of function sitalRtMt_HostBuffer_Initialize for more information on using functions sitalRt_HostBuffer_* or sitalMt_HostBuffer_* combined with functions sitalRtMt_HostBuffer_*.
///
/// Equivalent DDC definition: aceRTMTGetHBufMsgsRaw
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param wapBuffer (out)	A pointer to a buffer in which the raw messages are stored
/// @param wBufferSize (in)	The size (in words) of the data buffer that is pointed by wapBuffer (>0)
/// @param dwpMessageCount (out)	A pointer to a variable in which the number of retrieved messages (>=0) is returned
/// @param dwpRtStackLostMessageCount (out)	A pointer to a variable in which the current number of lost messages for given RT&MT device's RT stack is returned
/// @param dwpMtStackLostMessageCount (out)	A pointer to a variable in which the current number of lost messages for both given RT&MT device's MT stacks is returned
/// @param dwpHostBufferLostMessageCount (out)	A pointer to a variable in which the combined host buffer's current number of lost messages is returned
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
_EXTERN S16BIT _DECL sitalRtMt_HostBuffer_Message_GetRaw (	S16BIT swDevice,
															U16BIT* wapBuffer,
															U16BIT wBufferSize,
															U32BIT* dwpMessageCount,
															U32BIT* dwpRtStackLostMessageCount,
															U32BIT* dwpMtStackLostMessageCount,
															U32BIT* dwpHostBufferLostMessageCount)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalMode_RT_AND_MT != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if ((((U16BIT*)NULL) == wapBuffer) || (((U32BIT*)NULL) == dwpMessageCount) || (((U32BIT*)NULL) == dwpRtStackLostMessageCount) || (((U32BIT*)NULL) == dwpMtStackLostMessageCount) || (((U32BIT*)NULL) == dwpHostBufferLostMessageCount))
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if (sitalRtMtMaximum_MESSAGE_SIZE > wBufferSize)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	HostBufferStructure* hbspRtHostBuffer; // A host buffer structure.
	hbspRtHostBuffer = (HostBufferStructure*)&(dsspDeviceState->rms.rsRtState.hbsHostBuffer);
	if (0U == hbspRtHostBuffer->dwHostBufferSize)
	{
		return sitalReturnCode_HOST_BUFFER_NOT_INSTALLED;
	}

	HostBufferStructure* hbspMtHostBuffer; // A host buffer structure.
	hbspMtHostBuffer = (HostBufferStructure*)&(dsspDeviceState->rms.msMtState.hbsHostBuffer);
	if (0U == hbspMtHostBuffer->dwHostBufferSize)
	{
		return sitalReturnCode_HOST_BUFFER_NOT_INSTALLED;
	}

	if (0U == (sitalRtMtSetupOption_COMBINED_HOST_BUFFER & dsspDeviceState->rms.msMtState.dwOptions))
	{
		return sitalReturnCode_RT_AND_MT_NON_COMBINED_HOST_BUFFER_MODE;
	}

	/// Zero given buffer.
	memset ((void*)wapBuffer, (int)0U, (size_t)(wBufferSize << 1U));

	/// Zero the count of returned messages.
	(*dwpMessageCount) = 0U;

	/// Calculate requested statistics.
	(*dwpRtStackLostMessageCount) = dsspDeviceState->rms.rsRtState.rsssStackState.dwLostMessageCount;
	(*dwpMtStackLostMessageCount) = (dsspDeviceState->rms.msMtState.msssStackStateA.dwLostMessageCount + dsspDeviceState->rms.msMtState.msssStackStateB.dwLostMessageCount);
	(*dwpHostBufferLostMessageCount) = (hbspRtHostBuffer->dwLostMessageCount + hbspMtHostBuffer->dwLostMessageCount);

	/// Loop as long as the combined host buffer of given RT&MT device contains additional messages, given buffer isn't full, and no errors occurred:
	do
	{
		///		Find the host buffer from which the requested message should be read.
		// The caller wants to get the next message in the RT&MT combined host buffer.
		// But each of the host buffers that together make up this combined host buffer, i.e., the RT and the MT host buffers, principally has a next message of its own, and it should be here decided from which of them to read.
		// The way to decide from which host buffer to read the requested message is to select the one that stores the earlier of these two messages.
		U16BIT wRequestedMessageContainerHostBuffer; // The identity of the host buffer in which the requested message is stored (i.e., the one that stores the earlier/later of these two messages, in case the next/last message is requested, respectively).
		S16BIT swResult; // Result of operation or function call.
		swResult = rtmt_HostBuffer_Message_FindContainer (swDevice, sitalMessageLocationAndRemoval_NEXT_PURGE, &wRequestedMessageContainerHostBuffer);
		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}

		///		Get the requested message from its container host buffer.
		U32BIT dwMessageCount; // The number of retrieved messages
		U32BIT dwStackLostMessageCount; // Number of lost messages for the target RT/MT stack.
		U32BIT dwHostBufferLostMessageCount; // Number of lost messages for the target host buffer.
		switch (wRequestedMessageContainerHostBuffer)
		{
		case rtMtMessageContainerHostBuffer_RT:
			swResult = sitalRt_HostBuffer_Message_GetRaw (swDevice, wapBuffer, sitalRtMaximum_MESSAGE_SIZE, &dwMessageCount, &dwStackLostMessageCount, &dwHostBufferLostMessageCount);
			break;
		case rtMtMessageContainerHostBuffer_MT:
			swResult = sitalMt_HostBuffer_Message_GetRaw (swDevice, wapBuffer, sitalMtMaximum_MESSAGE_SIZE, &dwMessageCount, &dwStackLostMessageCount, &dwHostBufferLostMessageCount);
			break;
		case rtMtMessageContainerHostBuffer_NONE:
			return sitalReturnCode_SUCCESS;
		default:
			return sitalReturnCode_UNKNOWN_ERROR;
		}

		if (sitalReturnCode_SUCCESS != swResult)
		{
			return swResult;
		}
		(*dwpMessageCount) += dwMessageCount;
		wapBuffer += sitalRtMtMaximum_MESSAGE_SIZE;
		wBufferSize -= sitalRtMtMaximum_MESSAGE_SIZE;
	}
	while (sitalRtMtMaximum_MESSAGE_SIZE <= wBufferSize);

	return sitalReturnCode_SUCCESS;
}


/// <summary>
/// Return performance information about the combined host buffer of given RT&MT device.
///
/// Equivalent DDC definition: aceRTMTGetHBufMetric
/// @param swDevice (in)	Logical number of device (0-(sitalMaximum_DEVICES-1))
/// @param hbosspHostBufferOperationalStatistics (out)	A pointer to the host buffer operational statistics structure into which the required operational statistics are written
/// @param bIsResetOfHighestRecordedPercentageRequired (in)	A flag that says whether the record of the highest percentage reached by now should be reset
/// @return sitalReturnCode_SUCCESS	Function successfully completed
/// @return Negative sitalReturnCode_*	Error condition or function failed
/// </summary>
S16BIT _DECL sitalRtMt_HostBuffer_GetOperationalStatistics (S16BIT swDevice, sitalHostBufferOperationalStatisticsStructure* hbosspHostBufferOperationalStatistics, U16BIT bIsResetOfHighestRecordedPercentageRequired)
{
	/// @pseudocode

	/// If any state irrelevancy or illegal input parameter or operation failure is identified:
	///		Return error.
	if (((S16BIT)0 > swDevice) || ((S16BIT)sitalMaximum_DEVICES <= swDevice))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
								= &(s_dssaDevices[swDevice]);
	if (sitalMode_RT_AND_MT != dsspDeviceState->wMode)
	{
		return sitalReturnCode_INVALID_MODE;
	}

	if ((sitalDeviceState_READY != dsspDeviceState->wCurrentState) && (sitalDeviceState_RUN != dsspDeviceState->wCurrentState))
	{
		return sitalReturnCode_INVALID_STATE;
	}

	if (((sitalHostBufferOperationalStatisticsStructure*)NULL) == hbosspHostBufferOperationalStatistics)
	{
		return sitalReturnCode_INVALID_PARAMETER;
	}

	if (FALSE == dsspDeviceState->bIsOperationalStatisticsCollected)
	{
		return sitalReturnCode_OPERATIONAL_STATISTICS_NOT_ENABLED;
	}

	HostBufferStructure* hbspRtHostBuffer; // A host buffer structure.
	hbspRtHostBuffer = (HostBufferStructure*)&(dsspDeviceState->rms.rsRtState.hbsHostBuffer);
	if (0U == hbspRtHostBuffer->dwHostBufferSize)
	{
		return sitalReturnCode_HOST_BUFFER_NOT_INSTALLED;
	}

	HostBufferStructure* hbspMtHostBuffer; // A host buffer structure.
	hbspMtHostBuffer = (HostBufferStructure*)&(dsspDeviceState->rms.msMtState.hbsHostBuffer);
	if (0U == hbspMtHostBuffer->dwHostBufferSize)
	{
		return sitalReturnCode_HOST_BUFFER_NOT_INSTALLED;
	}

	double dCombinedHostBufferSize; // The size (in words) of the RT&MT combined host buffer.
	dCombinedHostBufferSize = (double)(hbspRtHostBuffer->dwHostBufferSize + hbspMtHostBuffer->dwHostBufferSize);
	double dRtHostBufferWeight; // A ratio (0.0-1.0) calculated for the RT host buffer, that designates its relative weight in the combined RT&MT host buffer.
	dRtHostBufferWeight = ((double)hbspRtHostBuffer->dwHostBufferSize / dCombinedHostBufferSize);
	double dMtHostBufferWeight; // A ratio (0.0-1.0) calculated for the MT host buffer, that designates its relative weight in the combined RT&MT host buffer.
	dMtHostBufferWeight = (1.0 - dRtHostBufferWeight); // = ((double)hbspMtHostBuffer->dwHostBufferSize / dCombinedHostBufferSize);

	hbosspHostBufferOperationalStatistics->dwMessageCount = (hbspRtHostBuffer->dwMessageCount + hbspMtHostBuffer->dwMessageCount);
	hbosspHostBufferOperationalStatistics->dwLostMessageCount = (hbspRtHostBuffer->dwLostMessageCount + hbspMtHostBuffer->dwLostMessageCount);
	hbosspHostBufferOperationalStatistics->dwFullnessPercentage = (U32BIT)( ((double)hbspRtHostBuffer->wFullnessPercentage * dRtHostBufferWeight) + ((double)hbspMtHostBuffer->wFullnessPercentage * dMtHostBufferWeight) );
	hbosspHostBufferOperationalStatistics->dwMaximumFullnessPercentage = (U32BIT)( ((double)hbspRtHostBuffer->wMaximumFullnessPercentage * dRtHostBufferWeight) + ((double)hbspMtHostBuffer->wMaximumFullnessPercentage * dMtHostBufferWeight) ); // Note that this is merely an indicative fullness percentage, as its two components, the maximum RT and MT host buffer fullness, haven't necessarily occurred at the same time.

	if ((U16BIT)0U != bIsResetOfHighestRecordedPercentageRequired)
	{
		hbspRtHostBuffer->wMaximumFullnessPercentage = 0U;
		hbspMtHostBuffer->wMaximumFullnessPercentage = 0U;
	}

	return sitalReturnCode_SUCCESS;
}


/*========================================================================
*************************************************************************
** DDC Externals Implementation
*************************************************************************
========================================================================*/

U16BIT _DECL aceGetLibVersion (void) 
{ 
	return sitalStld1553_GetShortLibraryVersion (); 
}

S16BIT _DECL aceFree (S16BIT swDevice) 
{ 
	return sitalDevice_Free (swDevice); 
}

S16BIT _DECL aceRTGetAddress (S16BIT swDevice, U16BIT* wpRtAddress) 
{ 
	return sitalRt_Address_Get (swDevice, wpRtAddress); 
}

S16BIT _DECL aceInitialize (S16BIT swDevice, U16BIT wAccess, U16BIT wMode, U32BIT dwSizeOfAllocatedMemory, U32BIT dwRegistersAddress, U32BIT dwMemoryAddress) 
{	
	return sitalDevice_Initialize (	swDevice, wAccess, wMode, dwSizeOfAllocatedMemory, dwRegistersAddress, dwMemoryAddress); 
}

S16BIT _DECL aceRTSetAddress (S16BIT swDevice, U16BIT wRtAddress) 
{ 
	return sitalRt_Address_Set (swDevice, wRtAddress); 
}

S16BIT _DECL aceSetTimeTagRes (S16BIT swDevice, U16BIT wTimeTagResolution) 
{ 
	return sitalDevice_TimeTag_SetResolution (swDevice, wTimeTagResolution); 
}

S16BIT _DECL aceMTStart (S16BIT swDevice) 
{ 
	return sitalMt_Start (swDevice); 
}

S16BIT _DECL aceMTContinue (S16BIT swDevice) 
{ 
	return sitalMt_Continue (swDevice); 
}

S16BIT _DECL aceMTGetStkMsgDecoded (S16BIT swDevice, MSGSTRUCT* dmspDecodedMessage,	U16BIT wMessageLocationAndRemoval, U16BIT wStackLocation) 
{
	sitalDecodedMessageStructure DecodedMessage = *((sitalDecodedMessageStructure *)&dmspDecodedMessage);
	return sitalMt_Message_GetFromStackDecoded (swDevice, &DecodedMessage, wMessageLocationAndRemoval, wStackLocation); 
}

S16BIT _DECL aceMTPause (S16BIT swDevice) 
{ 
	return sitalMt_Pause (swDevice); 
}

S16BIT _DECL aceMTStop (S16BIT swDevice) 
{ 
	return sitalMt_Stop (swDevice); 
}

S16BIT _DECL aceMTEnableRTFilter (S16BIT swDevice, U16BIT wRtAddress, U16BIT wMessageDirection,	U32BIT dwSubaddressMask) 
{	
	return sitalMt_MessageMonitoring_Enable (swDevice, wRtAddress, wMessageDirection, dwSubaddressMask); 
}

S16BIT _DECL aceMTDisableRTFilter (S16BIT swDevice,	U16BIT wRtAddress, U16BIT wMessageDirection, U32BIT dwSubaddressMask) 
{	
	return sitalMt_MessageMonitoring_Disable (swDevice, wRtAddress, wMessageDirection, dwSubaddressMask); 
}

S16BIT _DECL aceRTDataBlkCreate (S16BIT swDevice, S16BIT swDataBlockId,	U16BIT wDataBlockType, U16BIT* wapBuffer, U16BIT wBufferSize) 
{	
	return sitalRt_DataBlock_Create (swDevice, swDataBlockId, wDataBlockType, wapBuffer, wBufferSize); 
}

S16BIT _DECL aceRTDataBlkMapToSA (S16BIT swDevice, S16BIT swDataBlockId, U16BIT wSubaddress, U16BIT wMessageTypes, U16BIT wIrqOptions, U16BIT bIsSubaddressLegalizationRequested) 
{	
	return sitalRt_DataBlock_MapToSubaddress (swDevice, swDataBlockId, wSubaddress, wMessageTypes, wIrqOptions, bIsSubaddressLegalizationRequested); 
}

S16BIT _DECL aceRTModeCodeWriteData (S16BIT swDevice, U16BIT wDataContainingModeCode, U16BIT wData) 
{ 
	return sitalRt_ModeCode_WriteData (swDevice, wDataContainingModeCode, wData); 
}

S16BIT _DECL aceRTStart (S16BIT swDevice) 
{ 
	return sitalRt_Start (swDevice); 
}

S16BIT _DECL aceRTGetStkMsgDecoded (S16BIT swDevice, MSGSTRUCT* dmspDecodedMessage, U16BIT wMessageLocationAndRemoval) 
{ 
	sitalDecodedMessageStructure DecodedMessage = *((sitalDecodedMessageStructure *)&dmspDecodedMessage);
	return sitalRt_Message_GetFromStackDecoded (swDevice, &DecodedMessage, wMessageLocationAndRemoval); 
}

S16BIT _DECL aceRTModeCodeReadData (S16BIT swDevice, U16BIT wDataContainingModeCode, U16BIT* wpData) 
{ 
	return sitalRt_ModeCode_ReadData (swDevice, wDataContainingModeCode, wpData); 
}

S16BIT _DECL aceRTStop (S16BIT swDevice) 
{ 
	return sitalRt_Stop (swDevice); 
}

S16BIT _DECL aceRTDataBlkUnmapFromSA (S16BIT swDevice, S16BIT swDataBlockId, U16BIT wSubaddress, U16BIT wMessageTypes) 
{	
	return sitalRt_DataBlock_UnmapFromSubaddress (swDevice, swDataBlockId, wSubaddress, wMessageTypes); 
}

S16BIT _DECL aceRTDataBlkDelete ( S16BIT swDevice, S16BIT swDataBlockId) 
{ 
	return sitalRt_DataBlock_Delete (swDevice, swDataBlockId); 
}

S16BIT _DECL aceSetIrqConditions (S16BIT swDevice, U16BIT bIsInterruptEnabled, U32BIT dwIrqMask, USER_ISR_FUNCTION funcpExternalIsr) 
{	
	return sitalDevice_Irq_Manipulate (swDevice, bIsInterruptEnabled, dwIrqMask, funcpExternalIsr); 
}

S16BIT _DECL aceBCDataBlkCreate (S16BIT swDevice, S16BIT swDataBlockId, U16BIT wDataBlockType, U16BIT* wapBuffer, U16BIT wBufferSize) 
{	
	return sitalBc_DataBlock_Create (swDevice, swDataBlockId, wDataBlockType, wapBuffer, wBufferSize); 
}

S16BIT _DECL aceBCMsgCreateBCtoRT (S16BIT swDevice,	S16BIT swMessageId,	S16BIT swDataBlockId, U16BIT wReceiverRt, U16BIT wReceiverRtSubaddress,	U16BIT wWordCount, U16BIT wGapTime,	U32BIT dwOptions) 
{	
	return sitalBc_Message_CreateBcToRt (swDevice, swMessageId, swDataBlockId, wReceiverRt, wReceiverRtSubaddress, wWordCount, wGapTime, dwOptions); 
}

S16BIT _DECL aceBCMsgCreate (S16BIT swDevice, S16BIT swMessageId, S16BIT swDataBlockIdForMessage1, U16BIT wBcControlWordForMessage1, U16BIT wCommandWord1ForMessage1, U16BIT wCommandWord2ForMessage1, U16BIT wGapTimeForMessage1, S16BIT swDataBlockIdForMessage2,	U16BIT wBcControlWordForMessage2, U16BIT wCommandWord1ForMessage2, U16BIT wCommandWord2ForMessage2,	U16BIT wGapTimeForMessage2,	U32BIT dwOptions) 
{	
	return sitalBc_Message_Create (swDevice, swMessageId, swDataBlockIdForMessage1, wBcControlWordForMessage1, wCommandWord1ForMessage1, wCommandWord2ForMessage1, wGapTimeForMessage1, swDataBlockIdForMessage2, wBcControlWordForMessage2, wCommandWord1ForMessage2, wCommandWord2ForMessage2, wGapTimeForMessage2, dwOptions); 
}

S16BIT _DECL aceBCOpCodeCreate (S16BIT swDevice, S16BIT swCommandId, U16BIT wOpcode, U16BIT wCondition,	U32BIT dwParameter1, U32BIT dwParameter2, U32BIT dwReserved) 
{	
	return sitalBc_Command_Create (swDevice, swCommandId, wOpcode, wCondition, dwParameter1, dwParameter2, dwReserved); 
}

S16BIT _DECL aceBCFrameCreate (S16BIT swDevice,	S16BIT swFrameId, U16BIT wFrameType, S16BIT* swapCommandIds, U16BIT wCommandCount, U16BIT wFrameTime, U16BIT wFlags) 
{ 
	return sitalBc_Frame_Create (swDevice, swFrameId, wFrameType, swapCommandIds, wCommandCount, wFrameTime, wFlags); 
}

S16BIT _DECL aceBCGetStatus (S16BIT swDevice, U16BIT *wpCurrentState) 
{ 
	return sitalBc_GetActivationState (swDevice, wpCurrentState); 
}

S16BIT _DECL aceBCStop (S16BIT swDevice) 
{ 
	return sitalBc_Stop (swDevice); 
}

S16BIT _DECL aceBCGetMsgFromIDDecoded (	S16BIT swDevice, S16BIT swMessageId, MSGSTRUCT* dmspDecodedMessage, U16BIT wIsPurgeRequired) 
{	
	sitalDecodedMessageStructure DecodedMessage = *((sitalDecodedMessageStructure *)&dmspDecodedMessage);
	return sitalBc_Message_GetByIdDecoded (swDevice, swMessageId, &DecodedMessage, wIsPurgeRequired); 
}

S16BIT _DECL aceBCFrameDelete (S16BIT swDevice, S16BIT swFrameId) 
{ 
	return sitalBc_Frame_Delete (swDevice, swFrameId); 
}

S16BIT _DECL aceBCOpCodeDelete (S16BIT swDevice, S16BIT swCommandId) 
{ 
	return sitalBc_Command_Delete (swDevice, swCommandId); 
}

S16BIT _DECL aceBCMsgDelete (S16BIT swDevice, S16BIT swMessageId) 
{ 
	return sitalBc_Message_Delete (swDevice, swMessageId); 
}

S16BIT _DECL aceBCDataBlkDelete (S16BIT swDevice, S16BIT swDataBlockId) 
{ 
	return sitalBc_DataBlock_Delete (swDevice, swDataBlockId); 
}

/*******************************************
********************************************
**** ***** ***** RS485 **** ***** ***** ****
********************************************
*******************************************/

S16BIT _DECL rs485SetNumberOfBytes(U16BIT swDevice, U16BIT numOfBytes)
{
	return sitalDevice_AccessMemory(swDevice, sitalDeviceAccessOperation_Write, RS485_NumberOfBytesToSend, sitalDeviceMemorySection_Ram, 1, &numOfBytes);		
}

/*
#define RS485_Status_Register								0
#define RS485_Configuration_Register						1
#define RS485_BaudRate_Register								2
*/
_EXTERN S16BIT _DECL sital_RS485_Initialize (U16BIT swDevice, U32BIT dwOptions)
{
	//Verify validity of function params
	if ((0x4850 != (swDevice & 0x4850)) || ((swDevice & 0xF) > 3))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}
	//const DeviceStateStructure* dsspDeviceState // A pointer to the state structure of given device.
	//							= &(s_dssaDevices[swDevice & 0xF]);
	//if (sitalMode_RS485 != dsspDeviceState->wMode)
	//{
	//	return sitalReturnCode_INVALID_MODE;
	//}

	//if ((sitalAccess_CARD != dsspDeviceState->wAccess) && (sitalAccess_USER != dsspDeviceState->wAccess))
	//{
	//	return sitalReturnCode_INVALID_ACCESS;
	//}
	//U16BIT uLine = swDevice & 0xF;
	U16BIT content = 2;
	S16BIT res = 0;
	res = sitalDevice_AccessMemory(swDevice, sitalDeviceAccessOperation_Write, RS485_BaudRate_Register, sitalDeviceMemorySection_Registers, 1, &content);
	if(res < 0)
		return res;
	content = 0;
	res = sitalDevice_AccessMemory(swDevice, sitalDeviceAccessOperation_Write, RS485_Configuration_Register, sitalDeviceMemorySection_Registers, 1, &content);
	if(res < 0)
		return res;
	res = rs485SetNumberOfBytes(swDevice, 0); 
	if(res < 0)
		return res;
	
	return sitalReturnCode_SUCCESS;
}

S16BIT _DECL sital_RS485_Setup (U16BIT swDevice, U16BIT uiBitsCount, U16BIT peParity, U16BIT sbeStopBits, U32BIT pciSpeed, U32BIT rs485BaudRate, U16BIT rtmeRxTxMode, U16BIT* uipOffset)
{
	if ((0x4850 != (swDevice & 0x4850)) || ((swDevice & 0xF) > 3))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}	

	U16BIT uiRateDivider = (U16BIT)(((pciSpeed / rs485BaudRate) / 2) * 2);
	// verify that given setup configuration is legal.
	if ((5 > uiBitsCount) || (9 < uiBitsCount) || (0x2 > uiRateDivider) || (0x3FFF < uiRateDivider))
		return (sitalReturnCode_INVALID_PARAMETER);
	
	U16BIT ConfigLineRegister = ( (uiBitsCount - 5) | (rtmeRxTxMode << Rs422ConfigRegisterBit_RxTxModeOffset) | (peParity << Rs422ConfigRegisterBit_ParityOffset)
																	| (sbeStopBits << Rs422ConfigRegisterBit_StopBitsOffset) );
	// Stop the 485 Tx by writing 0 length
	S16BIT result = rs485SetNumberOfBytes(swDevice, 0);
	if(result < 0)
		return result;

	// Writing to HW
	//Configuration register
	result = sitalDevice_AccessMemory(swDevice, sitalDeviceAccessOperation_Write, RS485_Configuration_Register, sitalDeviceMemorySection_Registers, 1, &ConfigLineRegister);
	if(result < 0)
		return result;
	U16BIT res = 0;
	result = sitalDevice_AccessMemory(swDevice, sitalDeviceAccessOperation_Read, RS485_Configuration_Register, sitalDeviceMemorySection_Registers, 1, &res);
	if(result < 0)
		return result;
	
	// Baud Rate Register
	result = sitalDevice_AccessMemory(swDevice, sitalDeviceAccessOperation_Write, RS485_BaudRate_Register, sitalDeviceMemorySection_Registers, 1, &uiRateDivider);
	if(result < 0)
		return result;

	res = 0;
	result = sitalDevice_AccessMemory(swDevice, sitalDeviceAccessOperation_Read, RS485_BaudRate_Register, sitalDeviceMemorySection_Registers, 1, &res);
	if(result < 0)
		return result;

	// Read HW -> return status as offset
	U16BIT status;
	result = sitalDevice_AccessMemory(swDevice, sitalDeviceAccessOperation_Read, RS485_Status_Register, sitalDeviceMemorySection_Registers, 1, &status);
	if(result < 0)
		return result;
	*uipOffset = (0x3FF & status);
	
	return result;
}

S16BIT _DECL sital_RS485_Put (U16BIT swDevice, U16BIT uiLength, WORD* waBuffer)
{
	if ((0x4850 != (swDevice & 0x4850)) || ((swDevice & 0xF) > 3))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	if((1 > uiLength) || (SIZE_OF_RS485_TX_BUFFER <= uiLength))
		return (sitalReturnCode_INVALID_PARAMETER);

	U16BIT status;
	S16BIT result = sitalDevice_AccessMemory(swDevice, sitalDeviceAccessOperation_Read, RS485_Status_Register, sitalDeviceMemorySection_Registers, 1, &status);
	if(result < 0)
		return result;
	
	// verify that given RS422 line isn't currently transmitting.
	if (0 != (Rs422StatusRegisterBit_TransmitterBusy & status))
		return sitalReturnCode_DEVICE_BUSY;

	// Writing buffer to HW
	result = sitalDevice_AccessMemory(swDevice, sitalDeviceAccessOperation_Write, 0, sitalDeviceMemorySection_Ram, uiLength, waBuffer);
	if(result < 0)
		return result;
	result = rs485SetNumberOfBytes(swDevice, uiLength); 

	return result;	
}

S16BIT _DECL sital_RS485_Get (U16BIT swDevice, U16BIT* uipOffset, U16BIT uiLength, WORD* waBuffer)
{
	if ((0x4850 != (swDevice & 0x4850)) || ((swDevice & 0xF) > 3))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	if((SIZE_OF_RS485_RX_BUFFER <= (*uipOffset)) || (SIZE_OF_RS485_RX_BUFFER <= uiLength))
		return sitalReturnCode_INVALID_PARAMETER;

	U16BIT result;
	if((*uipOffset + uiLength) > 1024)
		{
			U16BIT tempLen = 1024 - *uipOffset;
			result = sitalDevice_AccessMemory(swDevice, sitalDeviceAccessOperation_Read, *uipOffset, sitalDeviceMemorySection_Ram, tempLen, waBuffer);
			result = sitalDevice_AccessMemory(swDevice, sitalDeviceAccessOperation_Read, 0, sitalDeviceMemorySection_Ram, uiLength - tempLen, &waBuffer[tempLen]);
		}
	else
		result = sitalDevice_AccessMemory(swDevice, sitalDeviceAccessOperation_Read, *uipOffset, sitalDeviceMemorySection_Ram, uiLength, waBuffer);

	// updating the offset cyclically
	(*uipOffset) += uiLength; 
	(*uipOffset) = ((*uipOffset) & 0x3FF);
	return result;
}

S16BIT _DECL sital_RS485_GetNumberOfReceivedWords (U16BIT swDevice, U16BIT uiOffset, U16BIT* uipLength)
{
	if ((0x4850 != (swDevice & 0x4850)) || ((swDevice & 0xF) > 3))
	{
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	}

	if (SIZE_OF_RS485_RX_BUFFER <= uiOffset)
		return sitalReturnCode_INVALID_PARAMETER;

	// Read HW -> return status as offset
	U16BIT status;
	U16BIT result = sitalDevice_AccessMemory(swDevice, sitalDeviceAccessOperation_Read, RS485_Status_Register, sitalDeviceMemorySection_Registers, 1, &status);
	if(result < 0)
		return result;
	
	U16BIT nextHwPointer = (0x3FF & status);
	if(nextHwPointer >= uiOffset)
		*uipLength = nextHwPointer - uiOffset;
	else
		*uipLength = nextHwPointer - uiOffset + SIZE_OF_RS485_RX_BUFFER;
	
	return result;
}

/*
* Discretes
*/
S16BIT _DECL sital_GPIO_Read (U16BIT swDevice, U16BIT* wData)
{
	if ((swDevice & 0xFFF0) != 0x6100)
		return sitalReturnCode_INVALID_DEVICE_NUMBER;

	U16BIT tData;
	S16BIT res = sitalDevice_AccessMemory(swDevice, sitalDeviceAccessOperation_Read, 0, sitalDeviceMemorySection_Registers, 1, &tData/*(wData & 0x00FF)*/);
	*wData = tData & 0x00FF;
	return res;
}

S16BIT _DECL sital_GPIO_Write (U16BIT swDevice, U16BIT wData)
{
	if ((swDevice & 0xFFF0) != 0x6100)
		return sitalReturnCode_INVALID_DEVICE_NUMBER;

	U16BIT wTest = ((wData & 0xFF) | 0xD000);
	return sitalDevice_AccessMemory(swDevice, sitalDeviceAccessOperation_Write, 0, sitalDeviceMemorySection_Registers, 1, &wTest);	
}

S16BIT _DECL sital_GPIO_Set2HiZ (U16BIT swDevice)
{
	if ((swDevice & 0xFFF0) != 0x6100)
		return sitalReturnCode_INVALID_DEVICE_NUMBER;

	U16BIT wTest = 0;
	return sitalDevice_AccessMemory(swDevice, sitalDeviceAccessOperation_Write, 0, sitalDeviceMemorySection_Registers, 1, &wTest);	
}

/*************************************************************************************************
*  ARINC 429
*************************************************************************************************/

S16BIT _DECL sital_A429_GetCount(U16BIT* swCards, U16BIT* numOfChannels){
	
	U16BIT cards;
	U16BIT channels;

	int result = sitalCard_GetCount(&cards);
	if(result < 0) return result;
	result = sitalDevice_GetCount(&channels);
	if(result < 0) return result;

	*swCards = cards;
	*numOfChannels = channels;
	return sitalReturnCode_SUCCESS;
}

S16BIT _DECL sital_A429_Channel_Open(U16BIT swCard, U16BIT channel, sital_A429ChannelInfo* channelInfo){

	// check if PCI device with A429 exists
	// if not, return error
	// if yes create staruct of Tx Rx Tx Rx
	if (((S16BIT)0 > channel) || ((S16BIT)sitalMaximum_DEVICES_ARINC429 <= channel))
		return sitalReturnCode_INVALID_DEVICE_NUMBER;
	U16BIT count;
	int result = sitalDevice_GetCount(&count);
	if(result < 0) return result;
	if(ArincDevices[swCard][channel].ChannelIsOpen == 1) return sitalReturnCode_SUCCESS;
	ArincDevices[swCard][channel].ChannelIsOpen = 1;
	return sitalReturnCode_SUCCESS;
}

S16BIT a429_Write(U16BIT card, U16BIT channel, U32BIT address, U32BIT len, U32BIT* buffer){

	U32BIT lAddress = 99;

	if(channel < 8){
		lAddress = (0x100 + (channel * 0x10) + (address & 0xF));
	}
	else if(channel < 24){
		lAddress = (0x200 + ((channel - 8) * 0x10) + (address & 0xF));
	}
	else if(channel < 25){
		lAddress = address;
	}
	else return sitalReturnCode_INVALID_DEVICE_NUMBER;

	if(lAddress == 99) return sitalReturnCode_INVALID_ADDRESS;

	return sitalCard_Write_DWORD(card, lAddress, len, buffer);
}

S16BIT a429_Read(U16BIT card, U16BIT channel, U32BIT address, U32BIT len, U32BIT* buffer){

	U32BIT lAddress = 99;

	if(channel < 8){
		lAddress = (0x100 + (channel * 0x10) + (address & 0xF));
	}
	else if(channel < 24){
		lAddress = (0x200 + ((channel - 8) * 0x10) + (address & 0xF));
	}
	else if(channel < 25){
		lAddress = address;
	}
	else return sitalReturnCode_INVALID_DEVICE_NUMBER;

	if(lAddress == 99) return sitalReturnCode_INVALID_ADDRESS;

	return sitalCard_Read_DWORD(card, lAddress, len, buffer);
}

S16BIT _DECL sital_A429_Channel_GetInformation(U16BIT swCard, U16BIT channel, sital_A429ChannelInfo* channelInfo){

	if (((S16BIT)0 > channel) || ((S16BIT)sitalMaximum_DEVICES_ARINC429 <= channel)) return sitalReturnCode_INVALID_DEVICE_NUMBER;
	U16BIT count;
	int res = sitalDevice_GetCount(&count);

	channelInfo->dwStructureSize = sizeof(sital_A429ChannelInfo);
    channelInfo->channelIsAvailable = !ArincDevices[swCard][channel].ChannelIsOpen;
    channelInfo->channelIsHighSpeed = ArincDevices[swCard][channel].ChannelIsHighSpeed;
    channelInfo->channelSupportsHighSpeed = 1; // hardcoded
    channelInfo->channelSupportsLowSpeed = 1;  // hardcoded
	channelInfo->channelIsTX = ArincDevices[swCard][channel].DeviceType_Tx_nRx;
    channelInfo->channelSupportsRX = !ArincDevices[swCard][channel].DeviceType_Tx_nRx; // hardcoded, cannot change
    channelInfo->channelSupportsTX = ArincDevices[swCard][channel].DeviceType_Tx_nRx;  // hardcoded, cannot change
    channelInfo->dwTransferSize = 256;    // hardcoded, cannot change
    channelInfo->dwCardNumber = swCard; 
    
	return sitalReturnCode_SUCCESS;
}

S16BIT _DECL sital_A429_Channel_Close(U16BIT swCard, U16BIT channel){

	if (((S16BIT)0 > channel) || ((S16BIT)sitalMaximum_DEVICES_ARINC429 <= channel)) return sitalReturnCode_INVALID_DEVICE_NUMBER;

	ArincDevices[swCard][channel].ChannelIsOpen = 0;
	
	S16BIT result = 0;
	U32BIT buff2[1];
	//buff2[0] = (0x98760000 | 0x1);
	buff2[0] = (0x9801);
	return a429_Write(swCard, channel, 0, 1, buff2);
}

S16BIT _DECL sital_A429_Channel_SetConfigRegister(U16BIT swCard, U16BIT channel, U32BIT chanFlags){

	if (((S16BIT)0 > channel) || ((S16BIT)sitalMaximum_DEVICES_ARINC429 <= channel)) return sitalReturnCode_INVALID_DEVICE_NUMBER;
	S16BIT result = 0;
	U32BIT buff2[1];
	buff2[0] = chanFlags;
	return a429_Write(swCard, channel, 4, 1, buff2);	
}

S16BIT _DECL sital_A429_Channel_GetConfigRegister(U16BIT swCard, U16BIT channel, U32BIT* chanFlags){
	if (((S16BIT)0 > channel) || ((S16BIT)sitalMaximum_DEVICES_ARINC429 <= channel)) return sitalReturnCode_INVALID_DEVICE_NUMBER;

	S16BIT result = 0;
	U32BIT buff2[2];
	result = a429_Read(swCard, channel, 4, 1, buff2);
	if(result != 0) return result;
	*chanFlags = buff2[0];
	return result;
}

S16BIT _DECL sital_A429_Channel_GetStatusRegister(U16BIT swCard, U16BIT channel, U32BIT* chanStats){	
	if (((S16BIT)0 > channel) || ((S16BIT)sitalMaximum_DEVICES_ARINC429 <= channel)) return sitalReturnCode_INVALID_DEVICE_NUMBER;

	S16BIT result = 0;
	U32BIT buff2[2];
	result = a429_Read(swCard, channel, 4, 1, buff2);
	if(result != 0) return result;
	*chanStats = buff2[0];
	return result;
}

S16BIT _DECL sital_A429_Channel_Reset(U16BIT swCard, U16BIT channel, U32BIT chanFlags){
	if (((S16BIT)0 > channel) || ((S16BIT)sitalMaximum_DEVICES_ARINC429 <= channel)) return sitalReturnCode_INVALID_DEVICE_NUMBER;

	return sital_A429_Channel_Close(swCard, channel);
}

S16BIT _DECL sital_A429_Card_SetConfiguration(U16BIT swCard, U32BIT cardFlags){
	S16BIT result = 0;
	U32BIT buff2[1];
	buff2[0] = 0;
	if((cardFlags & sital_A429_CARD_ENABLE_INTERNAL_LOOPBACK) == sital_A429_CARD_ENABLE_INTERNAL_LOOPBACK)
		buff2[0] = 0x12344321;
	else
		buff2[0] = 0;
	return a429_Write(swCard, 24, 0x300, 1, buff2);
}

S16BIT _DECL sital_A429_Receive (U16BIT swCard, U16BIT channel, U32BIT bufferSize, U32BIT* buffer, U32BIT* numberOfReceivedWords){
	if (((S16BIT)0 > channel) || ((S16BIT)sitalMaximum_DEVICES_ARINC429 <= channel)) return sitalReturnCode_INVALID_DEVICE_NUMBER;
	if(bufferSize == 0 || buffer == NULL || sizeof(buffer) == 0) return sitalReturnCode_INVALID_PARAMETER;
	
	if(ArincDevices[swCard][channel].DeviceType_Tx_nRx == 1) return sitalReturnCode_CANNOT_GET_ON_TX_CHANNEL;
	
	*numberOfReceivedWords = 0;
	S16BIT result = 0;
	U32BIT sr = 0x99;
	result = sital_A429_Channel_GetStatusRegister(swCard, channel, &sr);
	if(result != 0) return result;

	U16BIT avail = (sr & sital_A429_NUMBER_OF_WORDS_MASK) >> 16; // bit 25=fifo empty

	if(avail == 0){
		*numberOfReceivedWords = 0;
		return 0;
	}
	for(int i = 0 ; i < avail ; i++){
		result = a429_Read(swCard, channel, 8, 1, &buffer[i]);
		if(result != 0) return result;
		(*numberOfReceivedWords)++;
	}	
	return result;
}

S16BIT _DECL sital_A429_Send (U16BIT swCard, U16BIT channel, U32BIT bufferSize, U32BIT* buffer, U32BIT* numberOfWrittenWords){
	
	if (((S16BIT)0 > channel) || ((S16BIT)sitalMaximum_DEVICES_ARINC429 <= channel)) return sitalReturnCode_INVALID_DEVICE_NUMBER;
	if(bufferSize == 0 || buffer == NULL || sizeof(buffer) == 0) return sitalReturnCode_INVALID_PARAMETER;

	if(ArincDevices[swCard][channel].DeviceType_Tx_nRx == 0) return sitalReturnCode_CANNOT_SEND_ON_RX_CHANNEL;

	*numberOfWrittenWords = 0;
	S16BIT result = 0;
	U32BIT sr = 0x99;
	result = sital_A429_Channel_GetStatusRegister(swCard, channel, &sr);
	if(result != 0) return result;

	for(U32BIT i = 0 ; i < bufferSize ; i++){
		result = a429_Write(swCard, channel, 8, 1, &buffer[i]);
		if(result != 0) return result;
		(*numberOfWrittenWords)++;
	}
	return result;
}

S16BIT _DECL sital_A429_GetRxWordsPending(U16BIT swCard, U16BIT channel, U32BIT* numberOfWords){
	
	if (((S16BIT)0 > channel) || ((S16BIT)sitalMaximum_DEVICES_ARINC429 <= channel)) return sitalReturnCode_INVALID_DEVICE_NUMBER;
	S16BIT result = 0;
	U32BIT sr = 0x99;
	result = sital_A429_Channel_GetStatusRegister(swCard, channel, &sr);
	if(result != 0) return result;

	*numberOfWords = (sr & sital_A429_NUMBER_OF_WORDS_MASK) >> 16; // bit 25=fifo empty
	return result;
}

#ifdef _MANAGED
#pragma managed(pop)
#endif

